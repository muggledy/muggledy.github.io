<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Python基础 - 程序结构与函数编程 | Muggledy's Blog</title><meta name="robots" content="noindex"><meta name="author" content="Muggledy"><meta name="copyright" content="Muggledy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="📚 文档目录 🎃 类型和对象 - 🎈 程序结构与函数编程 - 🎏 面向对象编程  程序结构与执行 Python程序由一些语句序列组成，这些语句包括变量赋值、函数定义、类和模块导入等，加载源文件时，解释器始终顺序执行每条语句，直到再无语句可以执行，这种执行模式同样适用于作为主程序运行的文件和通过import加载的库文件 条件语句循环与迭代异常上下文管理器断言条件语句可由if以及可省的elif"><meta property="og:type" content="article"><meta property="og:title" content="Python基础 - 程序结构与函数编程"><meta property="og:url" content="https://muggledy.github.io/posts/176/index.html"><meta property="og:site_name" content="Muggledy&#39;s Blog"><meta property="og:description" content="📚 文档目录 🎃 类型和对象 - 🎈 程序结构与函数编程 - 🎏 面向对象编程  程序结构与执行 Python程序由一些语句序列组成，这些语句包括变量赋值、函数定义、类和模块导入等，加载源文件时，解释器始终顺序执行每条语句，直到再无语句可以执行，这种执行模式同样适用于作为主程序运行的文件和通过import加载的库文件 条件语句循环与迭代异常上下文管理器断言条件语句可由if以及可省的elif"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@v2.1/compress/13.jpg"><meta property="article:published_time" content="2021-04-25T12:55:45.000Z"><meta property="article:modified_time" content="2021-05-24T07:30:13.858Z"><meta property="article:author" content="Muggledy"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@v2.1/compress/13.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210207091812.png"><link rel="canonical" href="https://muggledy.github.io/posts/176/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v1.9/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:{limitDay:500,position:"top",messagePrev:"这篇文章已经发表了",messageNext:"天了，其中某些内容可能已经过时。"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: Muggledy",link:"链接: ",source:"来源: Muggledy's Blog",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!0,isToc:!0,postUpdate:"2021-05-24 15:30:13"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,n={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(n))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=(new Date).getHours();void 0===t?o<=6||o>=18?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode();const a=saveToLocal.get("aside-status");void 0!==a&&("hide"===a?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"))})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v1.9/css/mystyle.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/data/font_awesome/font-awesome-animation.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/data/button/buttons.min.css"><script src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@v0.2/data/katong_font/katong-font.js"></script><script src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@v0.9/data/img_preview/article_img_preview.js"></script><script src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@v1.0/data/bubble/bubble.js"></script><script src="https://cdn.staticfile.org/moment.js/2.24.0/moment.js"></script><script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script><script src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/data/is_pc/is-pc.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Muggledy's Blog" type="application/atom+xml"></head><div class="dyminibox"></div><body><div class="dy-show-cbg" id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@v0.1/img/20210202152223.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210328224511.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-book"></i> <span>文章</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="fa-fw fas fa-archive faa-tada"></i> <span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="fa-fw fas fa-tags faa-tada"></i> <span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-folder-open faa-tada"></i> <span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart card-announcement-animation"></i> <span>关于</span></a></div><div class="menus_item"><a class="site-page" href="/note/"><i class="fa-fw fas fa-bullhorn"></i> <span>公示</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i> <span>更多</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/gallery/"><i class="fa-fw fas fa-image faa-tada"></i> <span>图册</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><i class="fa-fw fas fa-video faa-tada"></i> <span>电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@v2.1/compress/13.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Muggledy's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw faa-wrench animated"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-book"></i> <span>文章</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="fa-fw fas fa-archive faa-tada"></i> <span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="fa-fw fas fa-tags faa-tada"></i> <span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-folder-open faa-tada"></i> <span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart card-announcement-animation"></i> <span>关于</span></a></div><div class="menus_item"><a class="site-page" href="/note/"><i class="fa-fw fas fa-bullhorn"></i> <span>公示</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i> <span>更多</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/gallery/"><i class="fa-fw fas fa-image faa-tada"></i> <span>图册</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><i class="fa-fw fas fa-video faa-tada"></i> <span>电影</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Python基础 - 程序结构与函数编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-25T12:55:45.000Z" title="发表于 2021-04-25 20:55:45">2021-04-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-24T07:30:13.858Z" title="更新于 2021-05-24 15:30:13">2021-05-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>55分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Python基础 - 程序结构与函数编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/176/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/posts/176/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><div class="note green icon flat"><i class="note-icon fas fa-rocket"></i><p>📚 文档目录<br>🎃 <a href="/posts/5311/"><span style="color:#3a96dd">类型和对象</span></a> - 🎈 程序结构与函数编程 - 🎏 <a href="/posts/22901/"><span style="color:#3a96dd">面向对象编程</span></a></p></div><h2 id="程序结构与执行">程序结构与执行</h2><p>Python程序由一些语句序列组成，这些语句包括变量赋值、函数定义、类和模块导入等，加载源文件时，解释器始终顺序执行每条语句，直到再无语句可以执行，这种执行模式同样适用于作为主程序运行的文件和通过<code>import</code>加载的库文件</p><div class="tabs" id="py2-1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#py2-1-1">条件语句</button></li><li class="tab"><button type="button" data-href="#py2-1-2">循环与迭代</button></li><li class="tab"><button type="button" data-href="#py2-1-3">异常</button></li><li class="tab"><button type="button" data-href="#py2-1-4">上下文管理器</button></li><li class="tab"><button type="button" data-href="#py2-1-5">断言</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="py2-1-1"><p>条件语句可由<code>if</code>以及可省的<code>elif</code>、<code>else</code>子句构成</p><p>在一些编程语言中存在<code>switch</code>语句，譬如C语言中实现成绩等级判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Input your score:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">  <span class="keyword">switch</span>(a/<span class="number">10</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>: <span class="built_in">printf</span>(<span class="string">&quot;\nA&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>: <span class="built_in">printf</span>(<span class="string">&quot;\nB&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>: <span class="built_in">printf</span>(<span class="string">&quot;\nC&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">&quot;\nD&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python中没有<code>switch</code>关键字，可以通过以下方式替代<a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.zzvips.com/article/117299.html">实现</a>：</p><ol><li>利用字典实现：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch=&#123;</span><br><span class="line">    <span class="number">10</span>: <span class="string">&#x27;A&#x27;</span>, <span class="comment">#此处需重复定义内容</span></span><br><span class="line">     <span class="number">9</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">     <span class="number">8</span>: <span class="string">&#x27;B&#x27;</span>,</span><br><span class="line">     <span class="number">7</span>: <span class="string">&#x27;C&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a=<span class="built_in">input</span>(<span class="string">&#x27;Input your score:&#x27;</span>)</span><br><span class="line">print(switch.get(<span class="built_in">int</span>(<span class="built_in">int</span>(a)/<span class="number">10</span>),<span class="string">&#x27;D&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li>创建一个<code>switch</code>类来处理程序的流转：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">switch</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,value</span>):</span></span><br><span class="line">        self.value=value</span><br><span class="line">        self.fall=<span class="literal">False</span> <span class="comment">#如果case匹配，且没有break，则置为True，表示继续向下执行，且不论下面的case是否匹配</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">yield</span> self.match <span class="comment">#由于yield关键字，__iter__方法变成一个生成器方法，当调用该方法时将返回一个生成器对象，而生成器又是迭代器，因此switch是一个可迭代对象</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span>(<span class="params">self,*args</span>):</span> <span class="comment">#args只允许接收0或1个参数</span></span><br><span class="line">        <span class="keyword">if</span> self.fall <span class="keyword">or</span> <span class="keyword">not</span> args: <span class="comment">#如果fall为True，则返回True表示继续执行当前的case子句，或当前case子句没有匹配参数，则表示为default默认分支（请将default放在最后一行，但并无代码严格检查，此代码仅为demo展示）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> args[<span class="number">0</span>]==self.value: <span class="comment">#匹配成功</span></span><br><span class="line">            self.fall=<span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment">#匹配失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">score=<span class="number">96</span></span><br><span class="line"><span class="keyword">for</span> case <span class="keyword">in</span> switch(score//<span class="number">10</span>): <span class="comment">#这个for只迭代一次</span></span><br><span class="line">    <span class="keyword">if</span> case(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">if</span> case(<span class="number">9</span>):</span><br><span class="line">        print(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case(<span class="number">8</span>):</span><br><span class="line">        print(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case(<span class="number">7</span>):</span><br><span class="line">        print(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case(): <span class="comment">#default分支</span></span><br><span class="line">        print(<span class="string">&#x27;D&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><p>不过实在没必要，特别是上述第二种方式，过于词不达意，这种<code>for</code>循环的写法就很迷，但是好像也找不到更好的写法</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="py2-1-2"><p>可以使用<code>while</code>（满足条件时不断循环直至条件不再满足）或<code>for</code>（遍历可迭代对象）实现循环，一般推荐使用<code>for</code>循环，如果想在迭代过程中同时获取下标索引，可以将可迭代对象<code>iterable</code>替换成<code>enumerate(iterable)</code>，其等同于<code>zip(range(len(iterable)),iterable)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">10</span></span><br><span class="line"><span class="keyword">while</span> (a&gt;<span class="number">0</span>): <span class="comment">#while expression等同于while(expression)，即加不加括号都一样，expression表达式所得也是一个python对象嘛，而(obj)就并未变成一个元组对象，它仍是obj对象本身，有obj is (obj)成立，除非写成(obj,)，这才变成了一个长度为1的元组对象。括号常用于表达式中，用于界定不同运算的优先级别，最内层的括号中的子表达式最先运算，譬如：((a+b)*c)-2</span></span><br><span class="line">    a-=<span class="number">1</span></span><br><span class="line">    print(a)</span><br><span class="line">print() <span class="comment">#输出一个空行</span></span><br><span class="line"></span><br><span class="line">i=<span class="number">888</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    print(i)</span><br><span class="line">print(<span class="string">f&#x27;i:<span class="subst">&#123;i&#125;</span>&#x27;</span>) <span class="comment">#注意输出的是i:9，因为迭代变量（i）的作用域并非for语句私有，即如果前面已经定义过一个相同名称的变量，它的值将被改写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#迭代过程中同时获取下标索引</span></span><br><span class="line">a=<span class="string">&#x27;muggledy&#x27;</span></span><br><span class="line"><span class="keyword">for</span> index,element <span class="keyword">in</span> <span class="built_in">enumerate</span>(a):</span><br><span class="line">    print(index,element)</span><br></pre></td></tr></table></figure><p>注（<code>for-else</code>语句）：<code>else</code>语句会在<code>for</code>循环结束之后执行，除非循环过程中遇到<code>break</code>（或者遇到其他意外如抛出异常，当然也不会执行到<code>else</code>语句），特别地，如果循环根本就没有开始（可迭代序列长度为0时），也会执行<code>else</code>语句，一般来说，<code>else</code>语句可以用于编写循环正常结束时的某些后续操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;demo1: for循环全部遍历结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> []:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;demo2: for循环全部遍历结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;demo3: for循环全部遍历结束&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">demo1: for循环全部遍历结束</span></span><br><span class="line"><span class="string">demo2: for循环全部遍历结束</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="py2-1-3"><p>异常会中断正常的程序执行流，可以使用<code>raise exception([value])</code>来手动抛出异常（<code>exception</code>是异常类型，内置异常类型请查阅文献[1]-p70，<code>value</code>是一个与指定异常相关的可选参数，通常是一条自定义的错误消息，如果<code>raise</code>语句不带任何参数，则将会重复引发最近一次出现的异常，如果最近没有出现异常，则抛出运行时异常<code>RuntimeError: No active exception to reraise</code>），使用<code>try-except</code>（能够嵌套使用）可以捕捉异常，<code>except</code>语句中用于编写异常处理程序，其还有一个可选的修饰符<code>as var</code>，可以将捕捉到的异常实例赋给变量<code>var</code>，另外可以在一个<code>try</code>块后跟随多个<code>except</code>块以捕捉多种不同类型的异常，当然也可以在一个<code>except</code>中同时捕捉，这时你可以在<code>except</code>语句块内使用<code>isinstance</code>进行异常类型判断，示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#示例1</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">except</span>: <span class="comment">#不带任何异常类型时将捕捉所有异常，也可以捕捉指定类型异常：except RuntimeError:</span></span><br><span class="line">    print(<span class="string">&#x27;出现异常！&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例2</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;运行错误啦！&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e: <span class="comment">#将异常实例赋值给变量e（Exception是所有非退出异常类型的基类，这样你就可以捕捉任意派生自Exception的异常类型）</span></span><br><span class="line">    print(<span class="string">&#x27;异常:&#x27;</span>,e)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#示例3（示例3和示例4都是不可执行的伪代码）</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    do something may cause IOError, TypeError <span class="keyword">or</span> NameError...</span><br><span class="line"><span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">    process IOError...</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    process TypeError...</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    process NameError...</span><br><span class="line">    </span><br><span class="line"><span class="comment">#示例4（示例3的另一种写法）</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    do something may cause IOError, TypeError <span class="keyword">or</span> NameError...</span><br><span class="line"><span class="keyword">except</span> (IOError,TypeError,NameError) <span class="keyword">as</span> e: <span class="comment">#注意括号不可省略</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(e,IOError):</span><br><span class="line">        process IOError...</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(e,TypeError):</span><br><span class="line">        process TypeError...</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">isinstance</span>(e,NameError):</span><br><span class="line">        process NameError...</span><br></pre></td></tr></table></figure><p><code>try-except</code>支持<code>else</code>子句（可省），但必须跟随在最后一个<code>except</code>子句后，如果<code>try</code>块中的内容并未引发异常，就会执行<code>else</code>子句中的代码（除非<code>try</code>块直接<code>return</code>返回了）。<code>try-except</code>还支持<code>finally</code>子句（可省），其必须写在最最后，无论<code>try</code>是否出现异常都会执行<code>finally</code>块中的内容（即使在<code>try</code>块、<code>except</code>块或<code>else</code>块中遇到<code>return</code>，也会执行<code>finally</code>块），且在<code>except</code>或<code>else</code>之后执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f=<span class="built_in">open</span>(<span class="string">&#x27;foo.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">f&#x27;Fail to open!(<span class="subst">&#123;e&#125;</span>)&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;Open successfully!&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>: <span class="comment">#如果文件打开（f存在）则关闭之，否则什么也不做</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f.close()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#小结：try-except是基本的异常捕获流程，else和finally则都是可选的，一般的执行顺序是：首先执行try中语句，如果没有异常，则跳转到else块，最后是finally块；如果try块中存在异常，则由except捕获异常，最后进入finally块</span></span><br></pre></td></tr></table></figure><p>关于异常捕捉中<code>return</code>返回值的问题，试想，如果<code>try</code>块中存在<code>return</code>语句，通常我们认为函数遇到<code>return</code>会立即返回，确实如此吗？如果存在<code>finally</code>块，那么其中的代码还会执行吗？具体看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#try-except-finally结构</span></span><br><span class="line"><span class="comment">#示例1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> a+<span class="number">1</span> <span class="comment">#首先计算表达式a+1的值然后保存下来，暂不return，转而执行finally块，（由于finally中没有遇到return，于是）结束后会回到此处，return之前保存的表达式值</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> a-<span class="number">1</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        a+=<span class="number">4</span></span><br><span class="line">        print(<span class="string">f&#x27;a=<span class="subst">&#123;a&#125;</span>&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">print(f(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">a=5</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> a/<span class="number">0</span> <span class="comment">#出现除0异常，显然此return永远也不会执行，直接进入except块</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> a-<span class="number">1</span> <span class="comment">#计算表达式a-1的值，然后先保存下来，继续执行finally中的代码，（由于finally中没有遇到return，于是）结束后回到此处，return之前保存的表达式值</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        a+=<span class="number">4</span></span><br><span class="line">        print(<span class="string">f&#x27;a=<span class="subst">&#123;a&#125;</span>&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">print(f(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">a=5</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> a+<span class="number">1</span> <span class="comment">#首先计算表达式a+1的值然后保存下来，暂不return，转而执行finally块</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> a-<span class="number">1</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        a+=<span class="number">4</span></span><br><span class="line">        print(<span class="string">f&#x27;a=<span class="subst">&#123;a&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> a <span class="comment">#在finally中遇到return，那就不管了，函数直接返回，OVER</span></span><br><span class="line">        </span><br><span class="line">print(f(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">a=5</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#try-except-else-finally结构</span></span><br><span class="line"><span class="comment">#示例4</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> a+<span class="number">1</span> <span class="comment">#首先计算表达式a+1的值然后保存下来，暂不return，但因为return的存在，虽然没有异常也不会执行else块，但是finally必须执行，（由于finally中没有遇到return，于是）结束后仍回到此处，return之前保存下来的a+1的值，OVER</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> a-<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> a+<span class="number">2</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        a+=<span class="number">4</span></span><br><span class="line">        print(<span class="string">f&#x27;a=<span class="subst">&#123;a&#125;</span>&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">print(f(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">a=5</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a+<span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> a-<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> a+<span class="number">2</span> <span class="comment">#try中没有异常和return，于是执行else块，首先保存下表达式a+2的值，然后进入finally，（由于finally中没有遇到return，于是）结束后仍回到此处，return之前保存下来的值，OVER</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        a+=<span class="number">4</span></span><br><span class="line">        print(<span class="string">f&#x27;a=<span class="subst">&#123;a&#125;</span>&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">print(f(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">a=5</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例6</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a+<span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> a-<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> a+<span class="number">2</span> <span class="comment">#try中没有异常和return，于是跳转到else块，（由于finally的存在）首先保存下表达式a+2的值，然后进入finally</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        a+=<span class="number">4</span></span><br><span class="line">        print(<span class="string">f&#x27;a=<span class="subst">&#123;a&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> a <span class="comment">#finally中有return，于是不会再回到else块中的return位置处，此时函数直接返回，OVER</span></span><br><span class="line">        </span><br><span class="line">print(f(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">a=5</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>要自定义异常类型，需继承<code>Exception</code>基类，引发异常时传递的参数即是<code>__init__()</code>构造函数的参数，可以重载<code>__str__()</code>方法，以自定义异常输出的错误消息，示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myException</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,*args</span>):</span> <span class="comment">#可以接收n个（任意个）错误信息</span></span><br><span class="line">        self.args=args</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;myException: <span class="subst">&#123;<span class="string">&#x27;,&#x27;</span>.join(<span class="built_in">map</span>(<span class="keyword">lambda</span> i:<span class="built_in">str</span>(i),self.args))&#125;</span>&quot;</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> myException(<span class="string">&#x27;错误信息1&#x27;</span>,<span class="string">&#x27;错误信息2&#x27;</span>,<span class="number">8848</span>)</span><br><span class="line"><span class="keyword">except</span> myException <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="py2-1-4"><p>正确地管理各种资源（如文件句柄的获取与关闭、互斥锁的获取与释放和数据库的连接与断开等），在涉及异常时通常都比较棘手，异常的引发很可能导致控制流跳过负责释放某些关键资源的语句，<code>with</code>语句支持在由上下文管理器对象控制的运行时上下文中执行一系列语句，譬如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以下是不可执行的伪代码（此种写法可以确保文件资源被安全释放）</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;debuglog.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;Debugging\n&#x27;</span>)</span><br><span class="line">    ...</span><br><span class="line">    f.write(<span class="string">&#x27;Done\n&#x27;</span>)</span><br><span class="line"><span class="comment">#在控制流离开with语句块时会自动执行文件关闭的操作，不论with语句块中是否引发异常</span></span><br></pre></td></tr></table></figure><p><code>with obj</code>语句在控制流进入和离开其后的相关代码块时，允许（上下文管理器）对象<code>obj</code>管理所发生的的事情，执行<code>with obj</code>语句时，将执行<code>obj.__enter__()</code>来指示进入一个新的上下文，当控制流离开该上下文时，就会执行<code>obj.__exit__(type,value,traceback)</code>，如果没有引发异常，<code>__exit__()</code>方法的三个参数均被设为<code>None</code>，否则，它们将包含与导致控制流离开上下文的异常相关的类型、值和跟踪信息，<code>__exit__()</code>方法返回<code>True</code>或<code>False</code>，用于指示被引发的异常是否得到处理，如果返回<code>False</code>，引发的任何异常都将被继续向外抛出。<code>with obj</code>语句接受一个可选的<code>as var</code>修饰符，此时<code>obj.__enter__()</code>方法的返回值将被赋给变量<code>var</code></p><p>自定义一个上下文管理器的伪代码示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">contextor</span>:</span> <span class="comment">#类实现的上下文管理器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,*args,**kwargs</span>):</span></span><br><span class="line">        <span class="comment">#初始化上下文管理器</span></span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment">#可以是获取资源等操作</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> something <span class="comment">#返回值将赋给with的as从句所定义的变量var</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, <span class="built_in">type</span>, value, traceback</span>):</span></span><br><span class="line">        <span class="comment">#可以是释放资源等操作</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span> <span class="comment">#是否向with外抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> contextor(*args,**kwargs) <span class="keyword">as</span> var:</span><br><span class="line">    <span class="comment">#with语句块</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>还有一种定义上下文管理器的方式，借助<code>contextlib</code>模块的<code>contextmanager</code>装饰器实现，伪代码示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">contextor</span>(<span class="params">*args,**kwargs</span>):</span> <span class="comment">#函数版本的“上下文管理器”</span></span><br><span class="line">    <span class="comment">#语句块1</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> expression</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment">#捕捉with语句块内可能发生的异常，如果不捕捉，将被抛给with的外层，这也意味着语句块2（等同于上下文管理器的__exit__()方法代码）不会执行，这与上下文管理器的精神相违背（即不论with语句块内是否引发异常，__exit__()方法都会执行），因此一般都要在yield位置捕捉可能的异常</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="comment">#语句块2</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> contextor(*args,**kwargs) <span class="keyword">as</span> var:</span><br><span class="line">    <span class="comment">#with语句块</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><code>contextmanager</code>装饰器的原理很简单，其实现依赖于一个名为<code>_GeneratorContextManager</code>的类，这是一个定义了<code>__enter__()</code>和<code>__exit__()</code>方法的上下文管理器类型，而被装饰的函数<code>contextor</code>是一个生成器函数，根据装饰器原理有<code>contextor=contextmanager(contextor)</code>，返回的是一个闭包函数对象，其包含有一个指向真实<code>contextor</code>函数地址的变量，姑且记作<code>func</code>，当你调用<code>contextor(*args,**kwargs)</code>时将使用<code>args</code>、<code>kwargs</code>和<code>func</code>来初始化构造一个<code>_GeneratorContextManager</code>类实例，姑且记作<code>c</code>，具体的，在其初始化函数<code>__init__()</code>中会执行<code>func(*args,**keargs)</code>得到一个生成器对象，并保存为实例属性，姑且记作<code>c.g</code>，配合<code>with</code>使用时（<code>with contextor(*args,**kwargs)</code>），将自动调用<code>c</code>的<code>__enter__()</code>方法，而<code>__enter__()</code>的实现即是执行<code>return c.g.__next__()</code>，换句话说，上述生成器函数中<code>yield</code>之前的语句块1将作为上下文管理器的<code>__enter__()</code>方法定义，且<code>yield</code>表达式值将赋给变量<code>var</code>，当离开<code>with</code>语句块，将自动调用<code>c</code>的<code>__exit__()</code>方法，而<code>__exit__()</code>的实现即是再一次调用<code>c.g.__next__()</code>，换句话说，<code>yield</code>之后的语句块2将作为上下文管理器的<code>__exit__()</code>方法定义，另外，由于<code>with</code>语句块内部可能引发异常，异常将被<code>c</code>的<code>__exit__()</code>方法接收，默认下<code>c.__exit__()</code>返回<code>False</code>，即异常将被抛给<code>with</code>的外层，如果你不想抛出异常，则需要在上述生成器函数的<code>yield</code>位置处捕捉，因为<code>c.__exit__()</code>内部会在存在异常的情况下，调用生成器对象的<code>throw()</code>方法，具体的，执行<code>c.g.throw(type,value,traceback)</code>，该方法会在<code>yield</code>位置处抛出参数所指异常，如果你手动捕捉了异常，程序会继续向下执行一次生成器的<code>next()</code>方法，即执行语句块2，否则意味着上下文管理器的<code>__exit__()</code>不会被调用，这一点千万注意</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#示例1（来自文献[1]-p73）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListTransaction</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,thelist</span>):</span></span><br><span class="line">        self.thelist=thelist</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.workingcopy=<span class="built_in">list</span>(self.thelist)</span><br><span class="line">        <span class="keyword">return</span> self.workingcopy</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self,<span class="built_in">type</span>,value,tb</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.thelist[:]=self.workingcopy</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="comment">#返回True，避免with语句块内的异常继续向上抛给外层</span></span><br><span class="line">        </span><br><span class="line">items=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">with</span> ListTransaction(items) <span class="keyword">as</span> working:</span><br><span class="line">    working.append(<span class="number">6</span>)</span><br><span class="line">    working.append(<span class="number">7</span>)</span><br><span class="line">    <span class="comment">#raise ValueError(&#x27;xxx&#x27;)</span></span><br><span class="line">print(items) <span class="comment">#[1, 2, 3, 6, 7]，如果上一行注释取消，则输出[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例2</span></span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ListTransaction</span>(<span class="params">thelist</span>):</span></span><br><span class="line">    workingcopy=<span class="built_in">list</span>(thelist)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> workingcopy</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">    thelist[:]=workingcopy</span><br><span class="line">    </span><br><span class="line">items=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">with</span> ListTransaction(items) <span class="keyword">as</span> working:</span><br><span class="line">    working.append(<span class="number">6</span>)</span><br><span class="line">    working.append(<span class="number">7</span>)</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">print(items)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">xxx</span></span><br><span class="line"><span class="string">[1, 2, 3, 6, 7]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例3</span></span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ListTransaction</span>(<span class="params">thelist</span>):</span></span><br><span class="line">    workingcopy=<span class="built_in">list</span>(thelist)</span><br><span class="line">    <span class="keyword">yield</span> workingcopy <span class="comment">#对比示例2，如果不在yield位置处捕捉异常，当with语句块中引发异常时候，yield后面的代码将不会被执行（该部分代码是作为上下文管理器的__exit__()方法定义）</span></span><br><span class="line">    thelist[:]=workingcopy</span><br><span class="line">    </span><br><span class="line">items=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> ListTransaction(items) <span class="keyword">as</span> working:</span><br><span class="line">        working.append(<span class="number">6</span>)</span><br><span class="line">        working.append(<span class="number">7</span>)</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line">print(items)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">xxx</span></span><br><span class="line"><span class="string">[1, 2, 3]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="py2-1-5"><p>一般格式为<code>assert expression[, msg]</code>，其中<code>expression</code>为<code>False</code>时，将触发<code>AssertionError</code>异常，<code>msg</code>是可选的自定义错误消息，注意<code>assert</code>不应用于必须执行以确保程序正确的代码，因为如果python运行在最优模式（通过对解释器使用<code>-O</code>选项进入该模式），断言语句将不会执行，那么何时使用<code>assert</code>呢？<code>assert</code>语句用于检查应该始终为真的内容</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="函数式编程">函数式编程</h2><div class="tabs" id="py2-2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#py2-2-1">函数</button></li><li class="tab"><button type="button" data-href="#py2-2-2">装饰器</button></li><li class="tab"><button type="button" data-href="#py2-2-3">偏函数</button></li><li class="tab"><button type="button" data-href="#py2-2-4"><code>yield</code>表达式与协程</button></li><li class="tab"><button type="button" data-href="#py2-2-5">生成式</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="py2-2-1"><p>函数定义使用<code>def</code>关键字（另外可以使用<code>lambda</code>关键字创建表达式形式的匿名函数，形如<code>lambda *args, **kwargs : expression</code>），通常函数的第一条语句会使用文档字符串来描述函数的用途，可以在查看函数帮助时获取到该文档（<code>help(func)</code>），譬如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;This is a demo.</span></span><br><span class="line"><span class="string">       Author: muggledy</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">help</span>())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">Help on function f in module __main__:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">f()</span></span><br><span class="line"><span class="string">    This is a demo.</span></span><br><span class="line"><span class="string">    Author: muggledy</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>函数作为对象也具有属性，譬如上述文档字符串就存储于函数对象的<code>__doc__</code>属性中，函数名存储在<code>__name__</code>属性中，事实上，可以给函数对象绑定任意属性，这些新增属性保存在函数对象的<code>__dict__</code>属性中，要查看对象的所有属性，则使用<code>dir(obj)</code>函数，或者通过<code>getattr(obj,attr)</code>获取对象的属性（另<code>hasattr(obj,attr)</code>检查对象是否具有名为<code>attr</code>的属性，<code>setattr(obj,attr,value)</code>为对象设置属性），函数是可调用的（<code>callable(func)</code>返回<code>True</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=A()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">setattr</span>(a,<span class="string">&#x27;can\&#x27;t be touched&#x27;</span>,<span class="string">&#x27;zj&#x27;</span>) <span class="comment">#setattr()相当逆天，你可以通过该方法为对象设置一些不能够通过属性访问符.号访问的属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.__dict__</span><br><span class="line">&#123;<span class="string">&quot;can&#x27;t be touched&quot;</span>: <span class="string">&#x27;zj&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.can<span class="string">&#x27;t be touched</span></span><br><span class="line"><span class="string">  File &quot;&lt;stdin&gt;&quot;, line 1</span></span><br><span class="line"><span class="string">    a.can&#x27;</span>t be touched</span><br><span class="line">                     ^</span><br><span class="line">SyntaxError: EOL <span class="keyword">while</span> scanning string literal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(a,<span class="string">&#x27;can\&#x27;t be touched&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;zj&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(a,<span class="string">&#x27;can\&#x27;t be touched&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>要调用函数，只要使用函数名加上用圆括号括起来的参数即可（函数名和括号之间允许有空格），python中函数传参的形式主要有五种，分别为位置传递、关键字传递、默认传递、包裹传递和解包裹传递（后两种在<a href="/posts/5311/">前一章</a>已经说过了，就不重复了），看示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#位置传递</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">x,y,z</span>):</span></span><br><span class="line">    print(<span class="string">f&#x27;<span class="subst">&#123;x&#125;</span>+<span class="subst">&#123;y&#125;</span>+<span class="subst">&#123;z&#125;</span>=<span class="subst">&#123;x+y+z&#125;</span>&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">f1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">#1+2+3=6 #即不具名传递，仅凭位置上的一一对应</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#关键字传递</span></span><br><span class="line">f1(<span class="number">4</span>,z=<span class="number">6</span>,y=<span class="number">5</span>) <span class="comment">#给所传递的参数值具名的一种传递方式，明确告诉某一参数值是交由函数的哪一个参数变量接收的，如此我们就不需要按照位置参数的固定位置序号排列，可以在函数定义中定义命名关键字参数或者可变字典参数，这两种参数都必须以键值对形式传递，见后</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#默认传递</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">x,y,z=<span class="number">6</span></span>):</span></span><br><span class="line">    print(<span class="string">f&#x27;<span class="subst">&#123;x&#125;</span>+<span class="subst">&#123;y&#125;</span>+<span class="subst">&#123;z&#125;</span>=<span class="subst">&#123;x+y+z&#125;</span>&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">f2(<span class="number">2</span>,<span class="number">3</span>) <span class="comment">#默认参数传递即隐式传递，具有默认值的参数在函数调用时可以不明确给出</span></span><br></pre></td></tr></table></figure><p>若按照参数类型划分，则可分为位置参数、默认参数、可变参数和命名关键字参数，其中默认参数又分为默认位置参数和默认关键字参数（且只有命名关键字参数可以有默认值，其他关键字参数没有或者说没法设置默认值），可变（长）参数又分为可变元组参数和可变关键字参数（或可变字典参数），这里只单说一下“命名关键字参数”，函数参数定义中位于<code>*</code>或<code>*args</code>（可变元组参数）之后以及可变关键字参数之前（假设存在的话）的就是命名关键字参数，在调用时其必须具名传递，命名关键字参数可以有默认值，也可以没有，譬如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span>(<span class="params">x,*,y=<span class="number">1</span>,z</span>):</span> <span class="comment">#x为位置参数，y和z是命名关键字参数，前者有默认值</span></span><br><span class="line">    print(x,y,z)</span><br><span class="line"></span><br><span class="line">f3(<span class="number">1</span>,z=<span class="number">3</span>) <span class="comment">#如果调用f3(1,1,3)将报错TypeError: f3() takes 1 positional argument but 3 were given</span></span><br></pre></td></tr></table></figure><p>不同类型参数的组合使用（定义和调用时注意顺序，基本原则是，位置参数在前，关键字参数在后）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#示例1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a,b,c=<span class="number">3</span>,*args</span>):</span> <span class="comment">#位置参数+带默认值的位置参数+可变元组参数</span></span><br><span class="line">    print(a,b,c,*args)</span><br><span class="line">    </span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,c=<span class="number">3</span>) <span class="comment">#1 2 3</span></span><br><span class="line">f(a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>) <span class="comment">#1 2 3</span></span><br><span class="line"><span class="comment">#f(a=3,b=2,c=1,0) #SyntaxError: positional argument follows keyword argument</span></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>) <span class="comment">#1 2 3 4 5 6 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a,b,*,x,y,**kwargs</span>):</span> <span class="comment">#位置参数+命名关键字参数+可变字典参数</span></span><br><span class="line">    print(a,b,x,y,kwargs)</span><br><span class="line">    </span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,x=<span class="number">3</span>,y=<span class="number">4</span>,z=<span class="number">5</span>) <span class="comment">#1 2 3 4 &#123;&#x27;z&#x27;: 5&#125;</span></span><br><span class="line"><span class="comment">#f(1,2,x=3,z=4) #TypeError: f() missing 1 required keyword-only argument: &#x27;y&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a,b,c=<span class="number">3</span>,*args,x=<span class="number">4</span>,y,**kwargs</span>):</span> <span class="comment">#最全组合：位置参数+带默认值的位置参数+可变元组参数+（带默认值的，可带可不带）命名关键字参数+可变关键字参数</span></span><br><span class="line">    print(a,b,c,args,x,y,kwargs)</span><br><span class="line">    </span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,x=<span class="number">5</span>,y=<span class="number">6</span>,z=<span class="number">7</span>) <span class="comment">#1 2 4 (3,) 5 6 &#123;&#x27;z&#x27;: 7&#125;</span></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,y=<span class="number">6</span>,z=<span class="number">7</span>) <span class="comment">#1 2 4 (3,) 4 6 &#123;&#x27;z&#x27;: 7&#125;</span></span><br><span class="line"><span class="comment">#f(b=2,a=1,3,4,y=6,x=5,z=7) #SyntaxError: positional argument follows keyword argument</span></span><br></pre></td></tr></table></figure><p>在编程时，尽量避免传递可变对象（如列表、字典等），因为在函数内部对可变对象的修改将反映在原始对象中，若无法避免，则应在函数中使用可变对象的拷贝，另外函数可以不显式写<code>return</code>语句，在运行结束时候，会默认返回<code>None</code></p><p>关于函数的作用域问题（<code>lambda</code>表达式遵循与函数相同的作用域规则），python中只有函数、类、模块会产生作用域（在作用域内定义的变量仅此作用域可见，但注意不同的作用域可能是包含关系，如全局作用域的范围包含局部作用域，全局作用域定义的变量在局部作用域也可访问），代码块不会产生作用域（如<code>for</code>循环变量会修改外面的同名变量，其实就是变量覆写），每执行一个函数，就会创建新的局部命名空间，包含函数参数名称和在函数体内定义的变量名称，在函数内访问变量首先会在局部空间中查找，找不到再去全局空间查找，具体的，python中有四种作用域：Local（局部作用域）、Enclosing（嵌套作用域）、Global（全局作用域）、Built-in（内置作用域），且变量的查找遵循“LEGB”规则，以内层嵌套函数为例，其首先搜索自己的局部命名空间，没有结果将由内而外在外层函数的局部命名空间中一层层地寻找（因为可以多层函数嵌套），仍无结果，才会到全局命名空间和内置命名空间查找，如果还没有，则引发<code>NameError</code>异常</p><p>可以在函数内部使用<code>global</code>关键字将（局部）变量动态声明为全局变量，使其位于全局命名空间，影响全局作用域，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">    <span class="keyword">global</span> x <span class="comment">#global语句可以放在函数内任意行或重复使用</span></span><br><span class="line">    x=<span class="number">8</span> <span class="comment">#如果外层已经存在此变量，则函数内部的修改将体现在外层空间</span></span><br><span class="line">    print(<span class="string">&#x27;局部命名空间:&#x27;</span>,<span class="built_in">locals</span>()) <span class="comment">#空，此函数未创建任何局部变量</span></span><br><span class="line">    print(<span class="string">&#x27;全局命名空间:&#x27;</span>,<span class="built_in">globals</span>()) <span class="comment">#上面创建的变量x位于全局命名空间</span></span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">print(x) <span class="comment">#8</span></span><br></pre></td></tr></table></figure><p>对于嵌套函数，尽管它可以访问到嵌套作用域中的变量，一旦尝试对其执行如赋值等操作，实际会在嵌套函数的局部命名空间中新建一个同名变量，python3提供了<code>nonlocal</code>关键字，该声明会将名称动态绑定为外层函数中首次访问到的同名变量（多层嵌套时，可能多个外层函数都定义了同一变量，具体绑定哪个就看谁最靠内最先被访问到），于是可以在嵌套函数中修改并体现在外层，譬如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">    i=<span class="number">4</span></span><br><span class="line">    j=<span class="number">7</span></span><br><span class="line">    k=<span class="number">13</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner1</span>():</span></span><br><span class="line">        <span class="keyword">nonlocal</span> i</span><br><span class="line">        j=<span class="number">70</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner2</span>():</span></span><br><span class="line">            <span class="keyword">nonlocal</span> i,j <span class="comment">#nonlocal限定于python3且嵌套函数使用，用于绑定至外层函数的局部变量，当声明为nonlocal变量时，该变量必须能在嵌套作用域中查获（见__closure__属性），否则报错，具体的，此处i绑定为f中的变量i，j绑定在inner1中的变量j</span></span><br><span class="line">            i=<span class="number">6</span></span><br><span class="line">            print(j) <span class="comment">#70</span></span><br><span class="line">            j=<span class="number">8</span></span><br><span class="line">            print(k) <span class="comment">#13</span></span><br><span class="line">        i=<span class="number">5</span></span><br><span class="line">        print(i) <span class="comment">#5</span></span><br><span class="line">        inner2()</span><br><span class="line">        print(i) <span class="comment">#6</span></span><br><span class="line">    inner1()</span><br><span class="line">    print(j) <span class="comment">#7</span></span><br><span class="line">    </span><br><span class="line">f()</span><br></pre></td></tr></table></figure><p>变量必须先赋值或定义才能使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">    print(i) <span class="comment">#i实际是局部变量，打印前需先赋值</span></span><br><span class="line">    i+=<span class="number">3</span></span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;C:\Users\muggledy\Desktop\ttt2.py&quot;, line 7, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    f()</span></span><br><span class="line"><span class="string">  File &quot;C:\Users\muggledy\Desktop\ttt2.py&quot;, line 3, in f</span></span><br><span class="line"><span class="string">    print(i)</span></span><br><span class="line"><span class="string">UnboundLocalError: local variable &#x27;i&#x27; referenced before assignment</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>函数作为第一类对象（所谓第一类对象的特性是，对象可以赋值给变量、对象可以被当做参数传递、对象可以被当做函数的返回值返回、对象可以作为元素被添加到容器类型中），在下面的例子中，函数接受另一个函数作为输入并调用它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义于文件foo.py，示例来自文献[1]-p79</span></span><br><span class="line">x=<span class="number">6</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callf</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="keyword">return</span> func()</span><br></pre></td></tr></table></figure><p>下面的例子使用了上述函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> foo</span><br><span class="line">x=<span class="number">8</span> <span class="comment">#如果注释掉此句，将报错NameError: name &#x27;x&#x27; is not defined</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helloworld</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&#x27;Hello World. x is <span class="subst">&#123;x&#125;</span>&#x27;</span></span><br><span class="line">    </span><br><span class="line">print(foo.callf(helloworld)) <span class="comment">#Hello World. x is 8</span></span><br></pre></td></tr></table></figure><p>注意<code>helloworld()</code>使用的<code>x</code>的值是在与它相同的环境中定义的，事实上，解释器会将函数及其所在执行环境整个打包在一起，得到的函数对象称为“闭包函数”，每个函数都拥有一个指向定义该函数的全局命名空间的<code>__globals__</code>属性，对于嵌套函数，闭包同样将捕捉嵌套函数执行所需的整个环境，因此除了<code>__globals__</code>属性，还有一个指向定义该函数的嵌套作用域空间的<code>__closure__</code>属性，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greeting_conf</span>(<span class="params">prefix</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greeting</span>(<span class="params">name</span>):</span></span><br><span class="line">        <span class="built_in">print</span> (prefix+<span class="string">&#x27; &#x27;</span>+name) <span class="comment">#greeting函数访问了外部定义的局部变量prefix，事实上在greeting_conf返回后，对greeting_conf可见的局部命名空间已经随着栈帧的销毁而销毁了，即locals()不可再获得，但是嵌套函数greeting会保存所需的执行环境，也就是说greeting_conf中定义的部分（为内层函数所使用到的）局部变量会继续存在于greeting的__closure__属性中</span></span><br><span class="line">    <span class="keyword">return</span> greeting</span><br><span class="line">    </span><br><span class="line">mGreeting=greeting_conf(<span class="string">&#x27;Good Morning&#x27;</span>)</span><br><span class="line">aGreeting=greeting_conf(<span class="string">&#x27;Good Afternoon&#x27;</span>) <span class="comment">#绑定了不同__closure__属性的闭包函数aGreeting和mGreeting是两个不同的函数对象，两者具有不同的执行环境，体现在两者id的不同</span></span><br><span class="line">mGreeting(<span class="string">&#x27;dy&#x27;</span>)</span><br><span class="line">mGreeting(<span class="string">&#x27;zj&#x27;</span>)</span><br><span class="line">aGreeting(<span class="string">&#x27;dxd&#x27;</span>)</span><br><span class="line">aGreeting(<span class="string">&#x27;zj&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(mGreeting.__closure__,mGreeting.__closure__[<span class="number">0</span>].cell_contents)</span><br><span class="line">print(aGreeting.__closure__,aGreeting.__closure__[<span class="number">0</span>].cell_contents)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">Good Morning dy</span></span><br><span class="line"><span class="string">Good Morning zj</span></span><br><span class="line"><span class="string">Good Afternoon dxd</span></span><br><span class="line"><span class="string">Good Afternoon zj</span></span><br><span class="line"><span class="string">(&lt;cell at 0x000002A9B0E97288: str object at 0x000002A9B10DA170&gt;,) Good Morning</span></span><br><span class="line"><span class="string">(&lt;cell at 0x000002A9B10687C8: str object at 0x000002A9B10DA1B0&gt;,) Good Afternoon</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="py2-2-2"><p>在开发过程中很可能需要对一些已有的函数进行改进，假设有一个用户注册函数<code>register()</code>，需要提交手机号码、用户名和注册邮箱信息，其中手机号码是数据库主键，具有唯一性，有天上司要求用户名也必须唯一，出于某些原因还不能破坏原有代码，怎么办？使用装饰器可以轻松完成这一工作，只需要编写一个检测是否存在相同用户名的装饰器函数<code>if_unique_username()</code>，然后在原有的<code>register()</code>函数定义前添加一行语句<code>@if_unique_username</code>就ok了，等价于执行<code>register=if_unique_username(register)</code>，<code>@</code>就是简化该操作的语法糖：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">if_unique_username</span>(<span class="params">func</span>):</span> <span class="comment">#装饰器函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_</span>(<span class="params">name,phone,email</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;DOC: 检测用户名唯一性函数&#x27;&#x27;&#x27;</span></span><br><span class="line">        print(<span class="string">&#x27;用户姓名唯一性检测&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(name,phone,email)</span><br><span class="line">    <span class="comment">#_.__doc__=func.__doc__ #如果借助functools模块，可以将此句替换为functools.update_wrapper(_,func)，效果等同于使用@functools.wraps(func)修饰_()函数</span></span><br><span class="line">    <span class="keyword">return</span> _</span><br><span class="line"></span><br><span class="line"><span class="meta">@if_unique_username </span><span class="comment">#装饰器的实现原理依据闭包函数可以访问其执行环境变量或者说可以访问其嵌套作用域空间变量，这个嵌套作用域空间是绑定在函数对象上的（__closure__）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">name,phone,email</span>):</span> <span class="comment">#被装饰函数</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;DOC: 用户注册函数&#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">&#x27;手机号唯一性检测&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">    print(<span class="string">f&#x27;用户(<span class="subst">&#123;name&#125;</span>,<span class="subst">&#123;phone&#125;</span>,<span class="subst">&#123;email&#125;</span>)注册成功&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">register(<span class="string">&#x27;dy&#x27;</span>,<span class="string">&#x27;152618xxxxx&#x27;</span>,<span class="string">&#x27;31012xxxxx@qq.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">用户姓名唯一性检测</span></span><br><span class="line"><span class="string">手机号唯一性检测</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">用户(dy,152618xxxxx,31012xxxxx@qq.com)注册成功</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>有时候被装饰函数带有多种类型参数，譬如上述示例中装饰器<code>if_unique_username()</code>内层函数也需要定义和被装饰函数<code>register</code>一模一样的参数，其实没必要这样麻烦，可以用<code>(*args,**kwargs)</code>参数组合来接收任意数量的位置或关键字参数，因此实现一个通用装饰器如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>) </span><span class="comment">#更简易使用我的改进版@wraps_fix，后面会详细介绍</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwds</span>):</span> <span class="comment">#即使没有参数也可以这样写</span></span><br><span class="line">        <span class="comment">#其他操作...</span></span><br><span class="line">        ret=func(*args,**kwds)</span><br><span class="line">        <span class="comment">#其他操作...</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>由于数据量太大，上司决定将用户数据分地区存储在不同的数据库里，在登陆的时候根据用户的所在地来选择相应的数据库，我们希望能够给装饰器指定不同的（地区）参数，最终效果大概是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@select_database(<span class="params">area=<span class="string">&#x27;江苏&#x27;</span></span>) </span><span class="comment">#等同于执行：register=select_database(area=&#x27;江苏&#x27;)(register)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>():</span></span><br><span class="line">    <span class="comment">#用户注册操作</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>依据装饰器的原理，该功能其实不难实现，只需要定义一个三层嵌套的装饰器函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_database</span>(<span class="params">area</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_1</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_2</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;DOC: 选择地区数据库函数&#x27;&#x27;&#x27;</span></span><br><span class="line">            print(<span class="string">f&#x27;选择<span class="subst">&#123;area&#125;</span>地区数据库&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">        <span class="comment">#_2.__doc__=func.__doc__ #如果借助functools模块，可以将此句替换为functools.update_wrapper(_2,func)，效果等同于使用@functools.wraps(func)修饰_2()函数</span></span><br><span class="line">        <span class="keyword">return</span> _2</span><br><span class="line">    <span class="keyword">return</span> _1</span><br><span class="line"></span><br><span class="line"><span class="meta">@select_database(<span class="params"><span class="string">&#x27;江苏&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">name,phone,email</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;DOC: 用户注册函数&#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">&#x27;手机号唯一性检测&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">    print(<span class="string">f&#x27;用户(<span class="subst">&#123;name&#125;</span>,<span class="subst">&#123;phone&#125;</span>,<span class="subst">&#123;email&#125;</span>)注册成功&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">register(<span class="string">&#x27;dy&#x27;</span>,<span class="string">&#x27;152618xxxxx&#x27;</span>,<span class="string">&#x27;31012xxxxx@qq.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">选择江苏地区数据库</span></span><br><span class="line"><span class="string">手机号唯一性检测</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">用户(dy,152618xxxxx,31012xxxxx@qq.com)注册成功</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>实际上，我们可以堆砌多个装饰器（装饰器链）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@select_database(<span class="params"><span class="string">&#x27;江苏&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">@if_unique_username</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">name,phone,email</span>):</span> <span class="comment">#等同于执行register=select_database(&#x27;江苏&#x27;)(if_unique_username(register))</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;DOC: 用户注册函数&#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">&#x27;手机号唯一性检测&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">    print(<span class="string">f&#x27;用户(<span class="subst">&#123;name&#125;</span>,<span class="subst">&#123;phone&#125;</span>,<span class="subst">&#123;email&#125;</span>)注册成功&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">register(<span class="string">&#x27;dy&#x27;</span>,<span class="string">&#x27;152618xxxxx&#x27;</span>,<span class="string">&#x27;31012xxxxx@qq.com&#x27;</span>)</span><br></pre></td></tr></table></figure><p>现在有一个问题，假设你查看经过修饰后的<code>register()</code>函数文档<code>register.__doc__</code>，会输出<code>DOC: 选择地区数据库函数</code>，这不符合预期，但是原因也很明显，变量名称<code>register</code>最终已实际指向<code>select_database()</code>中的内层嵌套函数<code>_2()</code>，解决这个问题也很容易，只要改一下<code>_2()</code>的函数文档就好了，于是在<code>_2()</code>函数定义后写一句<code>_2.__doc__=func.__doc__</code>、同时在<code>if_unique_username()</code>中的内层嵌套函数<code>_()</code>定义后写一句<code>_.__doc__=func.__doc__</code>即可，当然不只是<code>__doc__</code>属性，<code>__name__</code>等函数属性也发生了变化，另外，上述操作还可以通过装饰器来实现以简化调用（见下我自定义的<code>wraps()</code>函数，然后分别在<code>_2()</code>函数和<code>_()</code>函数定义上方写上一句<code>@wraps(func)</code>即可）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wraps</span>(<span class="params">foo</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_1</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_2</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">            <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">        _2.__name__=foo.__name__ <span class="comment">#此处只修改了__name__和__doc__属性，仅作为demo展示</span></span><br><span class="line">        _2.__doc__=foo.__doc__</span><br><span class="line">        <span class="keyword">return</span> _2</span><br><span class="line">    <span class="keyword">return</span> _1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span> <span class="comment">#修饰后的wrapper变量名称实际指向wraps()中的内层嵌套函数_2()，于是原始被装饰函数foo变量名称也是指向_2()函数，因此要将foo()的函数文档赋给_2.__doc__即可</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;wrapper function&#x27;&#x27;&#x27;</span></span><br><span class="line">        print(<span class="string">&#x27;功能扩展&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator </span><span class="comment">#等同于执行：foo=decorator(foo)=wraps(foo)(wrapper)，于是foo变量名实际指向wraps()中的_2()函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;foo function&#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">&#x27;原函数&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">print(foo.__name__) <span class="comment">#foo</span></span><br><span class="line">print(foo.__doc__) <span class="comment">#foo function</span></span><br></pre></td></tr></table></figure><p>不过标准的解决方案还是调用<code>functools</code>模块的<code>@wraps</code>装饰器，用法同上，官方实现如下（借助偏函数）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">WRAPPER_ASSIGNMENTS = (<span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__qualname__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__annotations__&#x27;</span>)</span><br><span class="line">RAPPER_UPDATES = (<span class="string">&#x27;__dict__&#x27;</span>,)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_wrapper</span>(<span class="params">wrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">                   wrapped,</span></span></span><br><span class="line"><span class="function"><span class="params">                   assigned = WRAPPER_ASSIGNMENTS,</span></span></span><br><span class="line"><span class="function"><span class="params">                   updated = WRAPPER_UPDATES</span>):</span></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> assigned:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            value = <span class="built_in">getattr</span>(wrapped, attr)</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">setattr</span>(wrapper, attr, value)</span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> updated:</span><br><span class="line">        <span class="built_in">getattr</span>(wrapper, attr).update(<span class="built_in">getattr</span>(wrapped, attr, &#123;&#125;))</span><br><span class="line">    wrapper.__wrapped__ = wrapped</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wraps</span>(<span class="params">wrapped,</span></span></span><br><span class="line"><span class="function"><span class="params">          assigned = WRAPPER_ASSIGNMENTS,</span></span></span><br><span class="line"><span class="function"><span class="params">          updated = WRAPPER_UPDATES</span>):</span></span><br><span class="line">    <span class="keyword">return</span> partial(update_wrapper, wrapped=wrapped,</span><br><span class="line">                   assigned=assigned, updated=updated)</span><br></pre></td></tr></table></figure><p>根据上述源码，除了使用<code>@wraps</code>修饰外，还有一种用法（直接调用<code>update_wrapper()</code>函数）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> update_wrapper</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;wrapper function&#x27;&#x27;&#x27;</span></span><br><span class="line">        print(<span class="string">&#x27;功能扩展&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    update_wrapper(wrapper,func)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;foo function&#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">&#x27;原函数&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">print(foo.__name__) <span class="comment">#foo</span></span><br><span class="line">print(foo.__doc__) <span class="comment">#foo function</span></span><br></pre></td></tr></table></figure><p>另外还可以通过<code>foo=foo.__wrapped__</code>方便地将被装饰函数恢复为原函数（即“解除装饰器”），如果没有使用<code>@functools.wraps</code>，那么<code>__wrapped__</code>属性是不可获得的，需要注意的是，这仅仅适用于单个装饰器的情况，假设你堆砌了多个装饰函数，那么访问<code>__wrapped__</code>属性获取到的就不再是原函数了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator1</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper1</span>():</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;wrapper1 function&#x27;&#x27;&#x27;</span></span><br><span class="line">        print(<span class="string">&#x27;功能扩展1&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator2</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper2</span>():</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;wrapper2 function&#x27;&#x27;&#x27;</span></span><br><span class="line">        print(<span class="string">&#x27;功能扩展2&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper2</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator2</span></span><br><span class="line"><span class="meta">@decorator1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;foo function&#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">&#x27;原函数&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">foo.__wrapped__() <span class="comment">#结果指向decorator1()中的内层函数wrapper1()，而非希望的foo()，原因也很明显，上面对foo()的修饰，等同于执行了foo=decorator2(decorator1(foo))，具体的，第一步执行temp=decorator1(foo)时，根据functools.wraps原理，于是wrapper1.__wrapped__属性被赋值为foo，即指向foo()函数，第二步执行decorator2(temp)时，于是wrapper2.__wrapped__属性被赋值为temp，而temp变量实际指向wrapper1()函数，另修饰后的foo变量实际指向wrapper2()函数，于是foo.__wrapped__返回的是wrapper1()（闭包）函数，不过这时你也发现了，要获取到原函数，只要再迈出一步，即调用foo.__wrapped__.__wrapped__，返回的就是原始的foo()函数了</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">功能扩展1</span></span><br><span class="line"><span class="string">原函数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>要想实现多装饰器的解除，可以稍稍修改<code>update_wrapper()</code>函数源码（原作者没有发现该问题吗？）：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def update_wrapper(wrapper,</span><br><span class="line">                   wrapped,</span><br><span class="line">                   assigned = WRAPPER_ASSIGNMENTS,</span><br><span class="line">                   updated = WRAPPER_UPDATES):</span><br><span class="line">    for attr in assigned:</span><br><span class="line">        try:</span><br><span class="line">            value = getattr(wrapped, attr)</span><br><span class="line">        except AttributeError:</span><br><span class="line">            pass</span><br><span class="line">        else:</span><br><span class="line">            setattr(wrapper, attr, value)</span><br><span class="line">    for attr in updated:</span><br><span class="line">        getattr(wrapper, attr).update(getattr(wrapped, attr, &#123;&#125;))</span><br><span class="line"><span class="deletion">-   wrapper.__wrapped__ = wrapped</span></span><br><span class="line"><span class="addition">+   if hasattr(wrapped, &#x27;__wrapped__&#x27;):</span></span><br><span class="line"><span class="addition">+       wrapper.__wrapped__ = getattr(wrapped, &#x27;__wrapped__&#x27;)</span></span><br><span class="line"><span class="addition">+   else:</span></span><br><span class="line"><span class="addition">+       wrapper.__wrapped__ = wrapped</span></span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure><p>如果不想修改源码，可以这样改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator1</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper1</span>():</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;wrapper1 function&#x27;&#x27;&#x27;</span></span><br><span class="line">        print(<span class="string">&#x27;功能扩展1&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="comment">###额外添加的代码</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(func,<span class="string">&#x27;__wrapped__&#x27;</span>):</span><br><span class="line">        wrapper1.__wrapped__=<span class="built_in">getattr</span>(func,<span class="string">&#x27;__wrapped__&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        wrapper1.__wrapped__=func</span><br><span class="line">    <span class="comment">###以实现多装饰器的正常解除</span></span><br><span class="line">    <span class="keyword">return</span> wrapper1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator2</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper2</span>():</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;wrapper2 function&#x27;&#x27;&#x27;</span></span><br><span class="line">        print(<span class="string">&#x27;功能扩展2&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="comment">###额外添加的代码</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(func,<span class="string">&#x27;__wrapped__&#x27;</span>):</span><br><span class="line">        wrapper2.__wrapped__=<span class="built_in">getattr</span>(func,<span class="string">&#x27;__wrapped__&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        wrapper2.__wrapped__=func</span><br><span class="line">    <span class="comment">###以实现多装饰器的正常解除</span></span><br><span class="line">    <span class="keyword">return</span> wrapper2</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator2</span></span><br><span class="line"><span class="meta">@decorator1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;foo function&#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">&#x27;原函数&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">foo.__wrapped__() <span class="comment">#原函数</span></span><br></pre></td></tr></table></figure><p>代码很简单，缺点是代码重复编写，此处我再给出一种解决方案💡：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wraps_fix</span>(<span class="params">f1</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_1</span>(<span class="params">f2</span>):</span></span><br><span class="line"><span class="meta">        @wraps(<span class="params">f1</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_2</span>(<span class="params">*args,**kwds</span>):</span></span><br><span class="line">            <span class="keyword">return</span> f2(*args,**kwds)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(f1,<span class="string">&#x27;__wrapped__&#x27;</span>):</span><br><span class="line">            _2.__wrapped__=<span class="built_in">getattr</span>(f1,<span class="string">&#x27;__wrapped__&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            _2.__wrapped__=f1</span><br><span class="line">        <span class="keyword">return</span> _2</span><br><span class="line">    <span class="keyword">return</span> _1</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator1</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps_fix(<span class="params">func</span>) </span><span class="comment">#完美！</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper1</span>():</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;wrapper1 function&#x27;&#x27;&#x27;</span></span><br><span class="line">        print(<span class="string">&#x27;功能扩展1&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator2</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps_fix(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper2</span>():</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;wrapper2 function&#x27;&#x27;&#x27;</span></span><br><span class="line">        print(<span class="string">&#x27;功能扩展2&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper2</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator2</span></span><br><span class="line"><span class="meta">@decorator1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;foo function&#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">&#x27;原函数&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">foo.__wrapped__() <span class="comment">#原函数</span></span><br></pre></td></tr></table></figure><p>除了使用三层嵌套函数实现带参数的装饰器，还可以借助偏函数实现，仍以选择地区数据库注册用户为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps,partial</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_database2</span>(<span class="params">area,func=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> func <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> partial(select_database2,area)</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        print(<span class="string">f&#x27;选择<span class="subst">&#123;area&#125;</span>地区数据库&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@select_database2(<span class="params"><span class="string">&#x27;江苏&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">name,phone,email</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;DOC: 用户注册函数&#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">&#x27;手机号唯一性检测&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">    print(<span class="string">f&#x27;用户(<span class="subst">&#123;name&#125;</span>,<span class="subst">&#123;phone&#125;</span>,<span class="subst">&#123;email&#125;</span>)注册成功&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">register(<span class="string">&#x27;dy&#x27;</span>,<span class="string">&#x27;152618xxxxx&#x27;</span>,<span class="string">&#x27;31012xxxxx@qq.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">选择江苏地区数据库</span></span><br><span class="line"><span class="string">手机号唯一性检测</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">用户(dy,152618xxxxx,31012xxxxx@qq.com)注册成功</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>网上看到一种通过类实现带参装饰器的方法，核心是借助于特殊函数<code>__call__()</code>使类实例变得可调用，此时上述案例可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">select_database3</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,area</span>):</span></span><br><span class="line">        self.area=area</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self,func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">            print(<span class="string">f&#x27;选择<span class="subst">&#123;self.area&#125;</span>地区数据库&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@select_database3(<span class="params"><span class="string">&#x27;江苏&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">name,phone,email</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;DOC: 用户注册函数&#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">&#x27;手机号唯一性检测&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">    print(<span class="string">f&#x27;用户(<span class="subst">&#123;name&#125;</span>,<span class="subst">&#123;phone&#125;</span>,<span class="subst">&#123;email&#125;</span>)注册成功&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">register(<span class="string">&#x27;dy&#x27;</span>,<span class="string">&#x27;152618xxxxx&#x27;</span>,<span class="string">&#x27;31012xxxxx@qq.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">选择江苏地区数据库</span></span><br><span class="line"><span class="string">手机号唯一性检测</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">用户(dy,152618xxxxx,31012xxxxx@qq.com)注册成功</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>不带参数的通用的基于类实现的装饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> update_wrapper</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">decorator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,func</span>):</span></span><br><span class="line">        self.func=func</span><br><span class="line">        update_wrapper(self,self.func)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self,*args,**kwargs</span>):</span></span><br><span class="line">        <span class="comment">#其他操作...</span></span><br><span class="line">        ret=self.func(*args,**kwargs)</span><br><span class="line">        <span class="comment">#其他操作...</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p>最后再看几个装饰器实现的案例，一是<code>@singledispatch</code>，被<code>@singledispatch</code>装饰的普通函数会变为泛函数，即根据第一个参数的类型以不同方式执行重载函数，称为单分派（而根据多个参数选择指定的函数，称为多分派，顾名思义<code>singledispatch</code>是单分派），如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cattle</span>:</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;牛&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;cattle&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fish</span>:</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;鱼&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;fish&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">obj</span>):</span> <span class="comment">#(1) #eat是泛函数，任意类对象只要没有“注册”都将调用该方法，对于注册了的譬如cattle和fish类，则调用对应的重载函数</span></span><br><span class="line">    print(<span class="built_in">str</span>(obj)+<span class="string">&#x27; eats something&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@eat.register(<span class="params">cattle</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span>(<span class="params">obj</span>):</span> <span class="comment">#(2) #_是一个无意义名字，当然也可取名为cattle_eat</span></span><br><span class="line">    print(<span class="built_in">str</span>(obj)+<span class="string">&#x27; eats grass&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@eat.register(<span class="params">fish</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span>(<span class="params">obj</span>):</span> <span class="comment">#(3)</span></span><br><span class="line">    print(<span class="built_in">str</span>(obj)+<span class="string">&#x27; eats shrimp&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">eat(cattle()) <span class="comment">#cattle eats grass</span></span><br><span class="line">eat(fish()) <span class="comment">#fish eats shrimp</span></span><br><span class="line">eat(<span class="string">&#x27;muggledy&#x27;</span>) <span class="comment">#muggledy eats something</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#动物都需要进食，但是不同对象“吃”的行为却各不相同，牛吃草、小鱼吃虾米等等，如果用面向对象继承方式实现，基类“吃”的方法就是上述代码中的(1)，牛继承基类并重载“吃”的方法，见(2)，同理，小鱼的“吃”见(3)</span></span><br></pre></td></tr></table></figure><p>二是带记忆装置的斐波那契数项计算，上一章我们讨论过了使用递归计算斐波那契数项的问题，代码很容易理解，但是性能却十分差，要改进它，一个合理的想法是为其配备“记忆装置”，对于计算过了的值我们直接从中获取以免重复计算造成资源浪费，利用装饰器我们不需要破坏原有代码，十分优美：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memory</span>(<span class="params">func</span>):</span></span><br><span class="line">    m=&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> m.get(n) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            m[n]=func(n)</span><br><span class="line">        <span class="keyword">return</span> m[n]</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@memory</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span>(<span class="params">n=<span class="number">6</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n-<span class="number">2</span>)+Fibonacci(n-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">print(Fibonacci(<span class="number">35</span>))</span><br></pre></td></tr></table></figure><div class="hide-toggle"><div class="hide-button toggle-title"><i class="fas fa-caret-right fa-fw"></i><span><code>@lru_cache</code></span></div><div class="hide-content"><p>由于计算机内存有限，记忆装置的缓存大小也应受限，但我们要做的不仅仅是限制缓存大小，还要基于LRU（Least Recently Used）“最近最少使用”思想来移除缓存中的过时数据，该算法的核心思想是，如果一个数据最近被访问过，则有理由相信它在将来被访问的概率也很高，反之，如果一个数据最近未被访问过，则可以认为它在将来被访问的概率也很低，实现它的最佳方式是使用“基于LRU的有序字典”来实现（按照访问频率高低按序排列，这就需要一个线性表，但是线性表查找时间复杂度为O(n)，考虑到字典查找时间复杂度为O(1)，因此可以通过next指针将字典中的元素依次串联起来，构成一个有序字典），官方文档<code>collections.OrderedDict</code>中基于<code>OrderedDict</code>实现了这样一个LRU字典，代码简洁明了（最后用下述<code>LRU</code>替换我上面写的<code>memory</code>装饰器函数中的变量<code>m</code>即可）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRU</span>(<span class="params">OrderedDict</span>):</span></span><br><span class="line">    <span class="string">&#x27;Limit size, evicting the least recently looked-up key when full&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, maxsize=<span class="number">128</span>, *args, **kwds</span>):</span></span><br><span class="line">        self.maxsize = maxsize</span><br><span class="line">        <span class="built_in">super</span>().__init__(*args, **kwds)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        value = <span class="built_in">super</span>().__getitem__(key)</span><br><span class="line">        self.move_to_end(key)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__setitem__(key, value)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self) &gt; self.maxsize:</span><br><span class="line">            oldest = <span class="built_in">next</span>(<span class="built_in">iter</span>(self))</span><br><span class="line">            <span class="keyword">del</span> self[oldest]</span><br></pre></td></tr></table></figure><p>下面进入正题，看看<code>@lru_cache</code>的具体使用，首先导入：<code>from functools import lru_cache</code>，然后用于装饰你希望被装饰的递归函数：<code>@lru_cache(maxsize=128, typed=False)</code>，待缓存条目是被装饰函数的输入（作为缓存项的键）和输出（作为缓存项的值），如果<code>maxsize</code>参数设为<code>None</code>，那么缓存可以无限制增长，而当<code>maxsize</code>是2的次幂时，LRU功能表现最佳，如果<code>typed</code>参数设为<code>True</code>，那么同一数值但类型不同的函数参数调用将对应不同的缓存项（须知，对于被装饰函数，相同输入必须具有相同输出，假设输出不具有确定性，譬如受制于随机性函数，则<code>@lru_cache</code>失效，无法达到节省时间的效果）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(<span class="params">maxsize=<span class="number">128</span>, typed=<span class="literal">False</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span>(<span class="params">n=<span class="number">6</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n-<span class="number">2</span>)+Fibonacci(n-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">print(Fibonacci(<span class="number">35</span>)) <span class="comment">#9227465</span></span><br></pre></td></tr></table></figure><p>装饰器<code>@lru_cache</code>提供了<code>cache_clear()</code>方法用于清除缓存或使缓存无效。一般说来，当我们使用装饰器之后，将“丢失”被装饰函数，被装饰函数的名字总是指向装饰函数，但<code>@lru_cache</code>类似<code>@wraps</code>还提供了<code>__wrapped__</code>属性，指向原始被装饰函数</p></div></div>三是使用<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jianshu.com/p/30a8e723efdc">装饰器修饰类对象</a>，变相地执行继承，已知有一个限定了实例属性的类，要扩展一个额外的属性，但是不允许破坏原有代码，显然解决办法是继承这个类，并使新类代替旧类，该过程可以通过装饰器实现，比较新奇：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addLength</span>(<span class="params">oldcls</span>):</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NewClass</span>(<span class="params">oldcls</span>):</span></span><br><span class="line">        __slots__=[<span class="string">&#x27;_length&#x27;</span>]</span><br><span class="line">        </span><br><span class="line"><span class="meta">        @property</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">length</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(self, <span class="string">&#x27;__len__&#x27;</span>):</span><br><span class="line">                self._length = <span class="built_in">len</span>(self)</span><br><span class="line">            <span class="keyword">return</span> self._length</span><br><span class="line">        </span><br><span class="line"><span class="meta">        @length.setter</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">length</span>(<span class="params">self, value</span>):</span></span><br><span class="line">            self._length = value</span><br><span class="line">    <span class="keyword">return</span> NewClass <span class="comment">#返回继承自（oldcls）旧类Tool的新类</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@addLength</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span>:</span> <span class="comment">#Tool=addLength(Tool)，变量名称Tool指向继承Tool的新类NewClass</span></span><br><span class="line">    __slots__=[<span class="string">&#x27;width&#x27;</span>,<span class="string">&#x27;height&#x27;</span>]</span><br><span class="line"></span><br><span class="line">t = Tool()</span><br><span class="line">t.width=<span class="number">8</span></span><br><span class="line">t.height=<span class="number">9</span></span><br><span class="line">t.length = <span class="number">10</span> <span class="comment">#新增属性</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="py2-2-3"><p>还是以用户注册功能函数<code>register()</code>为例，设其接收两个参数，用户所属国家<code>country</code>和姓名<code>name</code>，对于某一地区，绝大部分人的国家属性相同，那么理应给<code>country</code>参数设置一个默认值，从而简化调用，具体的，定义一个参数配置函数<code>configure()</code>，接收原函数<code>register</code>地址和要设置的参数<code>country</code>值，并返回一个闭包函数（称为原函数的“偏函数”），当调用此闭包函数时，只需要再传入剩下的<code>name</code>参数，闭包函数内部会根据之前保存的<code>country</code>参数和刚传入的<code>name</code>参数去执行原函数<code>register()</code>实现用户注册</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">country,name</span>):</span></span><br><span class="line">    print(<span class="string">f&#x27;[<span class="subst">&#123;country&#125;</span>]<span class="subst">&#123;name&#125;</span>用户注册&#x27;</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">register(<span class="string">&#x27;中国&#x27;</span>,<span class="string">&#x27;muggle&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">configure</span>(<span class="params">func,country</span>):</span> <span class="comment">#python内置的实现相同功能的函数名称叫做partial</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_</span>(<span class="params">name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> func(country,name)</span><br><span class="line">    <span class="keyword">return</span> _</span><br><span class="line">    </span><br><span class="line">register_china=configure(register,<span class="string">&#x27;中国&#x27;</span>)</span><br><span class="line">register_china(<span class="string">&#x27;msy&#x27;</span>)</span><br><span class="line">register_china(<span class="string">&#x27;xiaodong&#x27;</span>)</span><br><span class="line"></span><br><span class="line">register_japan=configure(register,<span class="string">&#x27;日本&#x27;</span>)</span><br><span class="line">register_japan(<span class="string">&#x27;艹&#x27;</span>)</span><br><span class="line">register_japan(<span class="string">&#x27;SB&#x27;</span>)</span><br></pre></td></tr></table></figure><p>通用的配置函数形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">configure</span>(<span class="params">func,*args1,**kwargs1</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_</span>(<span class="params">*args2,**kwargs2</span>):</span></span><br><span class="line">        <span class="keyword">return</span> func(*args1,*args2,**kwargs1,**kwargs2)</span><br><span class="line">    <span class="keyword">return</span> _</span><br></pre></td></tr></table></figure><p>所谓偏函数（或者翻译成局部应用），即是固定住原函数的部分参数（设为<code>k</code>个），以实现简化调用的目的（设原函数共有<code>n</code>个参数，局部应用将一个<code>n</code>元函数转换成一个<code>n-k</code>元函数），另有一个概念叫做“柯里化”，是一种将接受多个参数的函数转变成接受一个单一参数的函数，并且返回接受余下的参数且返回结果的新函数的技术（柯里化将一个<code>n</code>元函数转换成<code>n</code>个一元函数），可能不太好理解，直接看示例，一个实现三个数相加的加法操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a,b,c</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a+b+c</span><br></pre></td></tr></table></figure><p>其柯里化版本为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_f1</span>(<span class="params">b</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_f2</span>(<span class="params">c</span>):</span></span><br><span class="line">            <span class="keyword">return</span> a+b+c</span><br><span class="line">        <span class="keyword">return</span> _f2</span><br><span class="line">    <span class="keyword">return</span> _f1</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) <span class="comment">#6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可化简形式：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> b:<span class="keyword">lambda</span> c: a+b+c</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者：</span></span><br><span class="line">add=<span class="keyword">lambda</span> a:<span class="keyword">lambda</span> b:<span class="keyword">lambda</span> c:a+b+c</span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) <span class="comment">#6</span></span><br></pre></td></tr></table></figure><p>显然，我们不可能每次都花这么大的功夫为一个函数特别定制其柯里化版本，为此，定义了一个转换函数<code>curry()</code>，能够接收一个函数对象作为参数，并将其转换为柯里化版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这是一个更具通用性的curry()，随后你除了可以这样调用add(1)(2)(3)，还可以add(1)(2,3)或add(1,2)(3)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">curry</span>(<span class="params">func</span>):</span></span><br><span class="line">    argsnum=func.__code__.co_argcount</span><br><span class="line">    allargs=[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">curried</span>(<span class="params">*args</span>):</span></span><br><span class="line">        <span class="keyword">nonlocal</span> allargs</span><br><span class="line">        allargs+=<span class="built_in">list</span>(args)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(allargs)&gt;=argsnum:</span><br><span class="line">            ret=func(*allargs[:argsnum])</span><br><span class="line">            allargs=[]</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> curried</span><br><span class="line">    <span class="keyword">return</span> curried</span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;设计思路</span></span><br><span class="line"><span class="string">1.curry实现对一个函数的柯里化，因此只接收一个函数参数func，返回一个新的函数curried，其为func的柯里化版本</span></span><br><span class="line"><span class="string">2.每次curried被传递进参数并调用，curried都会检查是否已接收了足够的参数（使用allargs存储），当其个数大于或等于原函数参数func定义的参数个数（由argsnum记录），此时立即计算最终结果并返回，否则继续返回curried以接收更多参数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">curriedAdd=curry(add) <span class="comment">#curriedAdd是原函数add的柯里化版本，如果需要覆盖原函数，就直接add=curry(add)，而这正好可以使用装饰器的语法糖@来完成，更优美</span></span><br><span class="line">print(curriedAdd(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)) <span class="comment">#6</span></span><br><span class="line">print(curriedAdd(<span class="number">1</span>)(<span class="number">2</span>,<span class="number">3</span>)) <span class="comment">#6</span></span><br><span class="line">print(curriedAdd(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>)) <span class="comment">#6</span></span><br><span class="line">print(curriedAdd(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>)) <span class="comment">#6</span></span><br><span class="line"><span class="comment">#curriedAdd(1,2,3)(4) #TypeError: &#x27;int&#x27; object is not callable，由于curriedAdd(1,2,3)已经返回了正确结果6，整数显然是不可调用的，因此报错，对于curriedAdd(1,2)(3,4)，curriedAdd(1,2)返回的是一个函数，还能继续接收参数，但是只需要再接收一个就能正确计算，因此4被忽略（当然你也可以根据参数数量不一致raise报错），最终仍返回6</span></span><br></pre></td></tr></table></figure><p>除了上述通用的配置函数实现，我在<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.python.org/dev/peps/pep-0309/">PEP</a>文档中找到了一个利用<code>__call__()</code>实现的类版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">partial</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">        self = args[<span class="number">0</span>] <span class="comment">#__init__()的第一个参数是self对象</span></span><br><span class="line">        self.fn, self.args, self.kw = (args[<span class="number">1</span>], args[<span class="number">2</span>:], kw) <span class="comment">#args[1]是原函数，剩下的就是要预先固定的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kw</span>):</span></span><br><span class="line">        <span class="keyword">if</span> kw <span class="keyword">and</span> self.kw:</span><br><span class="line">            d = self.kw.copy()</span><br><span class="line">            d.update(kw)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d = kw <span class="keyword">or</span> self.kw</span><br><span class="line">        <span class="keyword">return</span> self.fn(*(self.args + args), **d)</span><br></pre></td></tr></table></figure><p>最后要说的是，python中实现偏函数的标准方法是通过<code>from functools import partial</code>，另外，除了为函数预设部分参数值构成偏函数，实际上任何可以通过<code>()</code>调用的都可以进行“偏应用”，譬如类、类实例、类/实例方法都可以通过<code>()</code>调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,m,n</span>):</span></span><br><span class="line">        self.m=m</span><br><span class="line">        self.n=n</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self,k,flag</span>):</span> <span class="comment"># k为乘积系数，flag表示是否输出结果</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            print(<span class="string">&#x27;m*k:&#x27;</span>,self.m*k,<span class="string">&#x27;\nn*k:&#x27;</span>,self.n*k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">self,f1,f2</span>):</span> <span class="comment"># 如果两个参数都是True，那么输出hello world，否则输出screw it</span></span><br><span class="line">        <span class="keyword">if</span> f1 <span class="keyword">and</span> f2:</span><br><span class="line">            print(<span class="string">&#x27;hello,world!&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&#x27;screw it!&#x27;</span>)</span><br><span class="line">            </span><br><span class="line"><span class="comment">#1.类A的参数m既定为3，那么我们就通过偏函数为类A的构造函数固定住这个参数m，其值为3</span></span><br><span class="line">A_m=partial(A,<span class="number">3</span>) <span class="comment"># 偏应用的类A</span></span><br><span class="line">obj_1=A_m(<span class="number">4</span>)</span><br><span class="line">print(obj_1.m,obj_1.n) <span class="comment"># 3 4</span></span><br><span class="line">obj_2=A_m(<span class="number">5</span>)</span><br><span class="line">print(obj_2.m,obj_2.n) <span class="comment"># 3 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.当类实现了__call__方法后，类实例对象将可以像函数一样被()调用，既然如此，我们为其固定住flag参数为True</span></span><br><span class="line">obj=A(<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">obj_true=partial(obj,flag=<span class="literal">True</span>)</span><br><span class="line">obj_true(<span class="number">2</span>) <span class="comment"># m*k: 14 \nn*k: 16</span></span><br><span class="line">obj_true(<span class="number">3</span>) <span class="comment"># m*k: 21 \nn*k: 24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.实例方法，本质就是函数对象，我们将hello方法的f2参数置为True，是否输出问候语只需要f1参数</span></span><br><span class="line">obj_hello=partial(obj.hello,f2=<span class="literal">True</span>) <span class="comment">#事实上，实例属性方法访问返回的也是一个固定了self参数的偏应用</span></span><br><span class="line">obj_hello(<span class="literal">True</span>) <span class="comment"># hello,world!</span></span><br><span class="line">obj_hello(<span class="literal">False</span>) <span class="comment"># screw it!</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="py2-2-4"><p>在函数内，<code>yield</code>语句还可以用作出现在赋值运算右边的表达式，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receiver</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;Ready to receive&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n=(<span class="keyword">yield</span>)</span><br><span class="line">        print(<span class="string">f&#x27;Got <span class="subst">&#123;n&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>以这种方式使用<code>yield</code>语句的函数称为“协程”（协程反映了程序逻辑的一种需求：可重入（子程序/函数的）能力。协程能保留上一次调用时的状态，每次重入时，就相当于进入上一次调用的状态），它的执行是为了响应发送给它的值，其行为也类似于生成器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r=receiver() <span class="comment">#此时函数尚未执行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.__next__() <span class="comment">#首次调用next()方法以向前执行到第一条yield语句处并暂停</span></span><br><span class="line">Ready to receive</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.send(<span class="number">1</span>) <span class="comment">#发送值到yield处，且发送的值将被直接赋给yield赋值号左边的变量，然后继续向前直至再次遇到yield并暂停</span></span><br><span class="line">Got <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(r.send(<span class="string">&#x27;Hello&#x27;</span>))</span><br><span class="line">Got Hello</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure><p>上述示例中在执行发送前需要先调用一次<code>next()</code>方法，不太方便，可以定义一个装饰器以自动调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        g=func(*args,**kwargs)</span><br><span class="line">        <span class="built_in">next</span>(g) <span class="comment">#next()返回第一个遇到的yield语句中的表达式值（yield [expression]），假设expression缺省，则返回None</span></span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line">    <span class="keyword">return</span> _</span><br><span class="line">    </span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receiver</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;Ready to receive&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n=(<span class="keyword">yield</span>)</span><br><span class="line">        print(<span class="string">f&#x27;Got <span class="subst">&#123;n&#125;</span>&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">r=receiver()</span><br><span class="line">r.send(<span class="number">1</span>)</span><br><span class="line">r.send(<span class="string">&#x27;Hello&#x27;</span>)</span><br></pre></td></tr></table></figure><p>协程的运行一般是无限期的，除非它被显式关闭（调用<code>close()</code>方法）或者自己退出，关闭后如果继续给协程发送值，将会引发<code>StopIteration</code>异常，正如之前在关于生成器的内容中所讲，<code>close()</code>操作将会在协程内部<code>yield</code>位置处引发<code>GenaratorExit</code>异常，你可以选择捕捉它。另外调用<code>throw(exctype[,value[,tb]])</code>方法也会在协程内部<code>yield</code>位置处引发异常，异常的类型、值和跟踪对象分别由<code>exctype</code>、<code>value</code>和<code>tb</code>参数指定</p><p>如果赋值号右边的<code>yield</code>语句本身含有表达式（不同于上面的<code>var=yield</code>，而是<code>var=yield expression</code>的形式），这个表达式的值将作为<code>send()</code>方法的返回值，此时协程可以使用<code>yield</code>语句同时接收和发出返回值，下面看一个生产者和消费者的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>():</span></span><br><span class="line">    r = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        print(<span class="string">&#x27;[CONSUMER] Consuming %s...&#x27;</span> % n)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        r = <span class="string">&#x27;200 OK&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">c</span>):</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        print(<span class="string">&#x27;[PRODUCER] Producing %s...&#x27;</span> % n)</span><br><span class="line">        r = c.send(n) <span class="comment">#将生产值发送给消费者，并接收消费者的反馈</span></span><br><span class="line">        print(<span class="string">&#x27;[PRODUCER] Consumer return: %s&#x27;</span> % r)</span><br><span class="line">    c.close() <span class="comment">#生产结束后关闭消费者，当然也可以在外面关闭</span></span><br><span class="line">    </span><br><span class="line">c = consumer()</span><br><span class="line">producer(c)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">[PRODUCER] Producing 1...</span></span><br><span class="line"><span class="string">[CONSUMER] Consuming 1...</span></span><br><span class="line"><span class="string">[PRODUCER] Consumer return: 200 OK</span></span><br><span class="line"><span class="string">[PRODUCER] Producing 2...</span></span><br><span class="line"><span class="string">[CONSUMER] Consuming 2...</span></span><br><span class="line"><span class="string">[PRODUCER] Consumer return: 200 OK</span></span><br><span class="line"><span class="string">[PRODUCER] Producing 3...</span></span><br><span class="line"><span class="string">[CONSUMER] Consuming 3...</span></span><br><span class="line"><span class="string">[PRODUCER] Consumer return: 200 OK</span></span><br><span class="line"><span class="string">[PRODUCER] Producing 4...</span></span><br><span class="line"><span class="string">[CONSUMER] Consuming 4...</span></span><br><span class="line"><span class="string">[PRODUCER] Consumer return: 200 OK</span></span><br><span class="line"><span class="string">[PRODUCER] Producing 5...</span></span><br><span class="line"><span class="string">[CONSUMER] Consuming 5...</span></span><br><span class="line"><span class="string">[PRODUCER] Consumer return: 200 OK</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，最开始的<code>next()</code>调用只会执行到赋值号右边的<code>(yield [expression])</code>处（且直到执行<code>send()</code>时才会完成赋值），并返回<code>yield</code>中的表达式<code>expression</code>值，在接下来的<code>send()</code>调用中，协程将从暂停处继起，直到再次遇到<code>(yield [expression])</code>暂停，并将此时计算得到的<code>expression</code>作为<code>send()</code>方法的返回值</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="py2-2-5"><ul><li><p>列表生成式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret=[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(_)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">list</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>集合生成式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret=&#123;x * x <span class="keyword">for</span> x <span class="keyword">in</span> [-<span class="number">5</span>,-<span class="number">3</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret</span><br><span class="line">&#123;<span class="number">25</span>, <span class="number">9</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(_)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">set</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>字典生成式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret=&#123;x:x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret</span><br><span class="line">&#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>, <span class="number">4</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(_)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">dict</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>生成器表达式</p><p>和列表生成式几乎一样，只不过将中括号<code>[]</code>替换成<code>()</code>即可，返回的是生成器对象</p></li></ul><p>注1，以上所有的生成式都支持多重<code>for</code>循环，如：<code>[(i,j,k) for i in range(4) for j in range(3) for k in range(2)]</code>（注意<code>for</code>循环的顺序是从左至右的，即左边<code>for</code>循环的迭代变量可以出现在右边<code>for</code>循环中但是反之不可以），譬如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret=((x,y) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>) <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(x))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x0000024BBAABBF10</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(_)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">0</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">2</span>), (<span class="number">4</span>, <span class="number">0</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">4</span>, <span class="number">2</span>), (<span class="number">4</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure><p>注2，以上所有的生成式都可以搭配<code>if</code>条件判断（没有<code>else</code>），以列表生成式为例：<code>[expression for i in iterable if condition]</code>（条件判断的作用同<code>filter()</code>函数，用于过滤序列中的部分元素），由于<code>expression</code>本身也可以是一个条件表达式，因此还可以写成：<code>[expression1 if condition else expression2 for i in iterable]</code>，示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> i%<span class="number">3</span>==<span class="number">0</span>] <span class="comment">#从0-9的序列中筛选出3的整数倍</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(<span class="number">1</span> <span class="keyword">if</span> i%<span class="number">3</span>==<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="comment">#如果是3的整数倍，则置为1否则置为0</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;3+&#x27;</span> <span class="keyword">if</span> i&gt;<span class="number">3</span> <span class="keyword">else</span> <span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> i%<span class="number">3</span>==<span class="number">0</span>] <span class="comment">#从0-9的序列中筛选出3的整数倍，且是字符串形式，进一步，如果大于6，则置为&#x27;3+&#x27;</span></span><br><span class="line">[<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;3+&#x27;</span>, <span class="string">&#x27;3+&#x27;</span>]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tip fas fa-quote-left"><p>[1] <a target="_blank" rel="noopener external nofollow noreferrer" href="https://pan.baidu.com/s/17r__wNMxIXTMWhglf3wyuw" title="密码：1y2r"><span style="color:red">Python参考手册</span></a> 第4版 修订版 [美] 大卫·M.比兹利（David M.Beazley）著，谢俊，杨越，高伟 译</p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">Muggledy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://muggledy.github.io/posts/176/">https://muggledy.github.io/posts/176/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://muggledy.github.io" target="_blank">Muggledy's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@v2.1/compress/13.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Gitalk</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@v0.1/img/20210202152223.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210328224511.gif"' alt="avatar"><div class="author-info__name">Muggledy</div><div class="author-info__description">孤筏重洋</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/muggledy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/muggledy" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210209044239.jpg" rel="external nofollow noreferrer" target="_blank" title="WeChat"><i class="fab fa-weixin"></i></a><a class="social-icon" href="mailto:zgjsycfndy2015@163.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=3101266674&amp;site=qq&amp;menu=yes" rel="external nofollow noreferrer" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><a href="/note/"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></a><div class="announcement_content">本人的更新是极慢的~</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E4%B8%8E%E6%89%A7%E8%A1%8C"><span class="toc-number">1.</span> <span class="toc-text">程序结构与执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">函数式编程</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/65257/" title="Butterfly魔改部分记录"><img src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210328214628.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210328224519.jpg"' alt="Butterfly魔改部分记录"></a><div class="content"><a class="title" href="/posts/65257/" title="Butterfly魔改部分记录">Butterfly魔改部分记录</a><time datetime="2021-03-24T16:00:00.000Z" title="发表于 2021-03-25 00:00:00">2021-03-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/17177/" title="Hexo博客简易配置"><img src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210217121829.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210328224519.jpg"' alt="Hexo博客简易配置"></a><div class="content"><a class="title" href="/posts/17177/" title="Hexo博客简易配置">Hexo博客简易配置</a><time datetime="2021-02-05T16:00:00.000Z" title="发表于 2021-02-06 00:00:00">2021-02-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By Muggledy</div><div class="footer_custom_text"><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io/zh-cn/"><img src="https://img.shields.io/badge/Frame-Hexo-blue"></a>&nbsp;&nbsp;<a target="_blank" rel="noopener external nofollow noreferrer" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-brightgreen"></a>&nbsp;&nbsp;<a target="_blank" rel="noopener external nofollow noreferrer" href="https://pages.github.com/"><img src="https://img.shields.io/badge/Hosted-Github-red"></a>&nbsp;&nbsp;<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsdelivr-blueviolet"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v1.2/js/utils.js"></script><script src="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v2.0/js/main.js"></script><script src="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v1.2/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v1.2/js/search/local-search.js"></script><div class="js-pjax"><script>document.getElementsByClassName("mermaid").length&&(window.mermaidJsLoad?mermaid.init():getScript("https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js").then(()=>{window.mermaidJsLoad=!0,mermaid.initialize({theme:"default"}),mermaid.init()}))</script><script>function loadValine(){function e(){new Valine(Object.assign({el:"#vcomment",appId:"b7x9hYzkDTy4reR4khezoDcf-gzGzoHsz",appKey:"ReeSRhiVzefUKIsJwSvUD6qV",placeholder:"快来评论吧(请注意“最新评论”只关联了Gitalk评论系统哦)~",avatar:"monsterid",meta:"nick,mail,link".split(","),pageSize:"10",lang:"zh-CN",recordIP:!1,serverURLs:"",emojiCDN:"",emojiMaps:"",enableQQ:!0,path:window.location.pathname,requiredFields:["nick,mail"],visitor:!1,master:"5f452633ebd48518f8778c240d946335".split(","),friends:"a483c79213701a5644bec62de88f974d,34c64a0cb78287b2ae889cda5d9d2a91,574fbd33aa74a09d671f4608af20fd2b".split(",")},null))}"function"==typeof Valine?e():getScript("https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js").then(e)}{function loadOtherComment(){loadValine()}setTimeout(loadValine,0)}</script><script>function addGitalkSource(){const e=document.createElement("link");e.rel="stylesheet",e.href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css",document.getElementsByTagName("head")[0].appendChild(e)}function loadGitalk(){function e(){new Gitalk(Object.assign({clientID:"05956758b57064d95a57",clientSecret:"3c4ddd74e671e3d79aac8417e708f69ff93b3e28",repo:"muggledy.github.io",owner:"muggledy",admin:["muggledy"],id:"aba8c7be9ca946afe9e9845aee09c4bd",language:"zh-CN",perPage:10,distractionFreeMode:!1,pagerDirection:"last",createIssueManually:!1,updateCountCallback:commentCount},null)).render("gitalk-container")}"function"==typeof Gitalk?e():(addGitalkSource(),getScript("https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js").then(e))}function commentCount(e){let t=document.querySelector("#post-meta .gitalk-comment-count");t&&(t.innerHTML=e)}{function loadOtherComment(){loadGitalk()}loadGitalk()}</script></div><script>window.addEventListener("load",()=>{const e=()=>{fetch("https://api.github.com/repos/muggledy/muggledy.github.io/issues/comments?sort=updated&direction=desc&per_page=6&page=1",{headers:{Accept:"application/vnd.github.v3.html+json"}}).then(e=>e.json()).then(e=>{(e=>{let a="";Promise.all(e.map(e=>fetch(e.url).then(e=>e.json()).then(e=>"utterances-bot"===e.user.login?(a=e.body.match(/https?\:\/\/[^\" ]+/gi).slice(-1),a[0]):(a=e.body.match(/https?\:\/\/[^\" ]+/i),a[0])))).then(a=>{e=e.map((e,t)=>({...e,url:a[t]})),saveToLocal.set("github-newest-comments",JSON.stringify(e),5/1440),t(e)})})(e.map(e=>{return{avatar:e.user.avatar_url,content:(t=e.body_html,""===t||(t=(t=(t=(t=t.replace(/<img.*?src="(.*?)"?[^\>]+>/gi,"[图片]")).replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi,"[链接]")).replace(/<pre><code>.*?<\/pre>/gi,"[代码]")).replace(/<[^>]+>/g,"")).length>150&&(t=t.substring(0,150)+"..."),t),nick:e.user.login,url:e.issue_url,date:e.updated_at,githubUrl:e.html_url};var t}))}).catch(e=>{document.querySelector("#card-newest-comments .aside-list").innerHTML="无法获取评论，请确认相关配置是否正确"})},t=e=>{let t="";if(e.length)for(let a=0;a<e.length;a++){t+="<div class='aside-list-item'>";{const n="src";t+=`<a href='${e[a].url}' class='thumbnail'><img ${n}='${e[a].avatar}' alt='${e[a].nick}'></a>`}t+=`<div class='content'>\n        <a class='comment' href='${e[a].url}'>${e[a].content}</a>\n        <div class='name'><span>${e[a].nick} / </span><time datetime="${e[a].date}">${btf.diffDate(e[a].date,!0)}</time></div>\n        </div></div>`}else t+="没有评论";let a=document.querySelector("#card-newest-comments .aside-list");a.innerHTML=t,window.lazyLoadInstance&&window.lazyLoadInstance.update(),window.pjax&&window.pjax.refresh(a)},a=()=>{if(document.querySelector("#card-newest-comments .aside-list")){const a=saveToLocal.get("github-newest-comments");a?t(JSON.parse(a)):e()}};a(),document.addEventListener("pjax:complete",a)})</script><script src="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v1.2/js/t_chart.js"></script><script src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/data/funny_title/funny-title-js.js"></script><script async src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/data/font_animal/font_animal.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v1.2/js/cal_rs.js"></script><script src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/data/visitors_map/vis_m.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#web_bg","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:complete",(function(){void 0!==window.ifExe_addHighlightTool&&(window.ifExe_addHighlightTool=!0),void 0!==window.ifExe_clickFnOfTagHide&&(window.ifExe_clickFnOfTagHide=!0),window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:send",(function(){if("object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="dyminimenu"><ul><li onclick="wll_menu(1)"><span>📝 添加mini便签</span></li><li onclick="wll_menu(2)"><span>🆑 清空当前页面</span></li></ul></div><script data-pjax>function history_calendar_injector_config(){var i=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载history_calendar"),i.insertAdjacentHTML("afterbegin",'<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>')}document.getElementsByClassName("sticky_layout")[0]&&"/"===location.pathname&&history_calendar_injector_config()</script><script data-pjax src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script></body><script async data-pjax>IsPC()&&btf.isJqueryLoad(image_preview_wrapper),btf.isJqueryLoad(dybubblefn)</script></html>