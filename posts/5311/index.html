<!--首页以及所有不含有顶图的页面为'dy-show-cbg'，归档页面需要额外控制，其不受page.top_img管理--><!--if is_archive()--><!--  - var temp_archive_top_img = theme.archive_img !== false ? theme.archive_img || theme.default_top_img : false--><!--  - dyshowcolorbg = temp_archive_top_img == false ? 'dy-show-cbg' : dyshowcolorbg--><!--除post页面全部设为'dy-show-cbg'--><!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Python基础 - 类型和对象 | Muggledy's Blog</title><meta name="keywords" content="Python"><meta name="author" content="Muggledy"><meta name="copyright" content="Muggledy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Python程序中保存的所有数据都是围绕对象这一概念来构建的，对象包括一些基本的数据类型，如数字、字符串、列表和字典，也可以通过类的形式创建用户自定义的对象...">
<meta property="og:type" content="article">
<meta property="og:title" content="Python基础 - 类型和对象">
<meta property="og:url" content="https://muggledy.top/posts/5311/index.html">
<meta property="og:site_name" content="Muggledy&#39;s Blog">
<meta property="og:description" content="Python程序中保存的所有数据都是围绕对象这一概念来构建的，对象包括一些基本的数据类型，如数字、字符串、列表和字典，也可以通过类的形式创建用户自定义的对象...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.staticaly.com/gh/celestezj/Mirror1ImageHosting/master/compress/zjandxiong.webp">
<meta property="article:published_time" content="2021-04-24T12:55:45.000Z">
<meta property="article:modified_time" content="2021-05-01T11:32:11.000Z">
<meta property="article:author" content="Muggledy">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.staticaly.com/gh/celestezj/Mirror1ImageHosting/master/compress/zjandxiong.webp"><link rel="shortcut icon" href="https://cdn.staticaly.com/gh/celestezj/ImageHosting/master/img/20210207091812.png"><link rel="canonical" href="https://muggledy.top/posts/5311/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="https://cdn.staticaly.com/gh/muggledy/muggledy.github.io/v6.7/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"这篇文章已经发表了","messageNext":"天了，其中某些内容可能已经过时。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Muggledy","link":"链接: ","source":"来源: Muggledy's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://unpkg.com/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://unpkg.com/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://unpkg.com/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://unpkg.com/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://unpkg.com/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2021-05-01 19:32:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="https://cdn.staticaly.com/gh/muggledy/muggledy.github.io/v6.8/css/mystyle.css"><link rel="stylesheet" href="https://cdn.staticaly.com/gh/celestezj/ImageHosting/master/data/font_awesome/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticaly.com/gh/celestezj/ImageHosting/master/data/button/buttons.min.css" media="defer" onload="this.media='all'"><script src="https://cdn.staticaly.com/gh/celestezj/ImageHosting/v0.9/data/img_preview/article_img_preview.js"></script><script src="https://cdn.staticaly.com/gh/celestezj/ImageHosting/v1.0/data/bubble/bubble.js"></script><script src="https://cdn.staticfile.org/moment.js/2.24.0/moment.js"></script><script src="https://unpkg.com/echarts@5.1.2/dist/echarts.min.js"></script><script src="https://cdn.staticaly.com/gh/celestezj/ImageHosting/master/data/is_pc/is-pc-etc.js"></script><link rel="stylesheet" href="https://cdn.staticaly.com/gh/celestezj/ImageHosting/v3.1/data/hint/hint.min.css" media="defer" onload="this.media='all'"><script>if (IsPC()){
  loadJS("/live2d-widget/autoload.js",function(){})
}</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Muggledy's Blog" type="application/atom+xml">
</head><!--.dyminibox--><body><div class="dy-show-cbg" id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.staticaly.com/gh/celestezj/Mirror1ImageHosting/master/compress/blogavatar.webp" onerror="onerror=null;src='https://cdn.staticaly.com/gh/celestezj/ImageHosting/master/img/20210328224511.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child" style="left:-74.2px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/" onclick=""><i class="fa-fw fas fa-archive faa-tada"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/" onclick=""><i class="fa-fw fas fa-tags faa-tada"></i><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/" onclick=""><i class="fa-fw fas fa-folder-open faa-tada"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/" onclick=""><i class="fa-fw fas fa-heart card-announcement-animation"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/note/" onclick=""><i class="fa-fw fas fa-bullhorn"></i><span> 公示</span></a></div><div class="menus_item"><a class="site-page" href="/link/" onclick=""><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 更多</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child" style="left:-140px;"><li><a class="site-page child faa-parent animated-hover" href="/gallery/" onclick=""><i class="fa-fw fas fa-image faa-tada"></i><span> 图册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/" onclick=""><i class="fa-fw fas fa-video faa-tada"></i><span> 电影</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:void(0);" rel="external nofollow noreferrer" onclick="dogo()"><i class="fa-fw fas fa-layer-group faa-tada"></i><span> 随便看看</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener external nofollow noreferrer" href="https://leancapp.muggledy.top" onclick=""><i class="fa-fw fas fa-comments faa-tada"></i><span> 评论</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.staticaly.com/gh/celestezj/Mirror1ImageHosting/master/compress/20210323121638.webp')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Muggledy's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw faa-wrench animated"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child" style="left:-74.2px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/" onclick=""><i class="fa-fw fas fa-archive faa-tada"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/" onclick=""><i class="fa-fw fas fa-tags faa-tada"></i><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/" onclick=""><i class="fa-fw fas fa-folder-open faa-tada"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/" onclick=""><i class="fa-fw fas fa-heart card-announcement-animation"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/note/" onclick=""><i class="fa-fw fas fa-bullhorn"></i><span> 公示</span></a></div><div class="menus_item"><a class="site-page" href="/link/" onclick=""><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 更多</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child" style="left:-140px;"><li><a class="site-page child faa-parent animated-hover" href="/gallery/" onclick=""><i class="fa-fw fas fa-image faa-tada"></i><span> 图册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/" onclick=""><i class="fa-fw fas fa-video faa-tada"></i><span> 电影</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:void(0);" rel="external nofollow noreferrer" onclick="dogo()"><i class="fa-fw fas fa-layer-group faa-tada"></i><span> 随便看看</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener external nofollow noreferrer" href="https://leancapp.muggledy.top" onclick=""><i class="fa-fw fas fa-comments faa-tada"></i><span> 评论</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Python基础 - 类型和对象</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-24T12:55:45.000Z" title="发表于 2021-04-24 20:55:45">2021-04-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-01T11:32:11.000Z" title="更新于 2021-05-01 19:32:11">2021-05-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">27.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>109分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Python基础 - 类型和对象"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/5311/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/posts/5311/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><div class="note green icon flat"><i class="note-icon fas fa-rocket"></i><p>📚 文档目录 <!--说实话后几章节普遍写得不太满意，主要是为面试公开，第三篇尚有待完善--><br>
🎃 类型和对象 - 🎈 <a href="/posts/176/"><span style="color:#3a96dd">程序结构与函数编程</span></a> - 🎏 <a href="/posts/22901/"><span style="color:#3a96dd">面向对象编程</span></a></p>
</div>
<div class="note warning simple"><p>由于页面中的某些内容嵌套在了多重标签插件下，使得宽度变得过于狭窄，特别是手机端体验会很差，建议在电脑端阅读<!--，后面我会注意避免该问题--></p>
</div>
<div style="display:none;">
<div class="note danger simple"><p>该笔记内容可能存在一些错误，如果您能够帮助指正，鄙人将非常感谢</p>
</div>
</div>
<h2 id="对象的身份与类型">对象的身份与类型</h2>
<p>Python中<span class="inline-tag red">一切皆对象</span>，包括一些常见的基础数据类型，如数字、字符串、列表、字典等，还有用户所自定义的对象（对象也称为类型的“实例”）。对象具有三大特征：</p>
<ol>
<li>身份（id），可以理解为在内存中的地址，具有唯一性，可以通过<code>id(obj)</code>查看</li>
<li>类型（type），对象都是由类实例化产生的，对象所属类型可通过<code>type(obj)</code>或<code>obj.__class__</code>查看</li>
<li>值（value），不同对象具有不同值（体现在“属性”和“方法”的不同上），这也是其存在的现实意义</li>
</ol>
<div class="note simple"><p>对象被创建后，其身份和类型就不可改变，根据其值是否可变，可以区分为“可变对象”与“不可变对象”</p>
</div>
<p>从身份、类型和值三个不同的角度分别比较对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">if</span> a <span class="keyword">is</span> b:</span><br><span class="line">        <span class="keyword">pass</span> <span class="comment">#a和b是同一个对象，或者说a和b指向同一内存地址</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(a) <span class="keyword">is</span> <span class="built_in">type</span>(b):</span><br><span class="line">        <span class="keyword">pass</span> <span class="comment">#a和b属于同一类型</span></span><br><span class="line">    <span class="keyword">if</span> a == b:</span><br><span class="line">        <span class="keyword">pass</span> <span class="comment">#a和b具有相同值</span></span><br></pre></td></tr></table></figure>
<div class="note warning flat"><p>当使用<code>==</code>运算符时，请务必确保<code>a==b</code>中的左值对象<code>a</code>所属类型已重载了<code>__eq__</code>方法（特别提醒用户自定义对象，python中已有的基础对象类型都已经重载了该方法），否则比较是无实际意义的，须知<code>a==b</code>等同于执行<code>a.__eq__(b)</code>，而一切对象继承自<code>object</code>类型，<code>object</code>类型的<code>__eq__</code>方法其实比较的是身份（<code>return a is b</code>）。一般来说<code>is</code>用得较少，因为在实际场景中，要比较两个对象是否相等，并不是通过内存地址来判断的，而是应该通过这两个对象的部分属性值，或者全部属性值来对比判断的<br>
注：在描述时，<code>obj</code>泛指的是任意python对象，而<code>object</code>则特指万物始祖之基类</p>
</div>
<div class="note info flat"><p>Python中全部8种比较运算：<code>&gt;</code>（对应<code>__gt__()</code>）, <code>&gt;=</code>（对应<code>__ge__()</code>）, <code>&lt;</code>（对应<code>__lt__()</code>）, <code>&lt;=</code>（对应<code>__le__()</code>）, <code>==</code>, <code>!==</code>（对应<code>__ne__()</code>）, <code>is</code>, <code>is not</code>。其他就不说了，<code>is</code>用在什么地方？<br>
或许你已知道<code>==None</code>是不推荐使用的，应替换为<code>is None</code>，这基于两点理由：1）<code>None</code>在python中是一个单例对象（<code>None</code>作为对象也具有自己的类型，但是你无法用这个类型创造出另一个<code>None</code>对象），其内存地址唯一，而身份比较的一个好处就是速度快，因为无需对将要比较的对象本身进行检查，<code>is</code>操作符只需对对象所在的内存地址进行比较，因此采用<code>is None</code>速度更快，2）由于<code>==</code>是可重载的，导致某些非<code>None</code>对象也可能“等于”<code>None</code>，从而致使程序出错，譬如当重载定义为<code>def __eq__(self,other): return True</code>时</p>
</div>
<h2 id="类型的类型">类型的类型</h2>
<p>既然一切皆对象，类型本身作为对象又是谁的实例呢？答：<code>type</code>类。上结论：</p>
<ul>
<li>一切类的类都是<code>type</code>，即一切类（包括<code>type</code>自身）都是<code>type</code>类的实例</li>
<li><code>object</code>是最顶层基类，一切类（除了<code>object</code>自身）追本溯源都继承自<code>object</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="built_in">type</span>(<span class="built_in">object</span>)) <span class="comment">#&lt;class &#x27;type&#x27;&gt; #基类object作为对象，它的类型是type</span></span><br><span class="line">print(<span class="built_in">type</span>(<span class="built_in">type</span>)) <span class="comment">#&lt;class &#x27;type&#x27;&gt; #type的类型是其自身</span></span><br><span class="line">print(<span class="built_in">object</span>.__base__) <span class="comment">#None #object无父类</span></span><br><span class="line">print(<span class="built_in">type</span>.__base__) <span class="comment">#&lt;class &#x27;object&#x27;&gt; #type作为类，直接继承自object</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">list</span>.__base__) <span class="comment">#&lt;class &#x27;object&#x27;&gt; #list、tuple、dict等以及自定义类都继承自object，类型为type</span></span><br><span class="line">print(<span class="built_in">type</span>(<span class="built_in">list</span>)) <span class="comment">#&lt;class &#x27;type&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.staticaly.com/gh/celestezj/ImageHosting/master/img/20210425185857.png" alt="图1.&nbsp;object类和type类：图中虚线是实例关系、实线是继承关系[3]"/></div></div>
<div class="hide-toggle" ><div class="hide-button toggle-title " style=""><i class="fas fa-caret-right fa-fw"></i><span><code>isinstance()</code>类型判断</span></div>
    <div class="hide-content"><p>早先在书上偶然看到一行代码<code>isinstance(A,object) #返回True</code>，其中<code>A</code>是一个自定义类，突然很不理解，没回过味来，还在<a target="_blank" rel="noopener external nofollow noreferrer" href="https://segmentfault.com/q/1010000019754936">SegmentFault</a>上提问，好蠢/(ㄒoㄒ)/~~</p>
<p>根据帮助文档（<code>help(isinstance)</code>）可知：<code>isinstance(obj, class_or_tuple)</code>判断对象<code>obj</code>是否是<code>class_or_tuple</code>中某个类的实例或者其子类的实例。假设<code>A</code>继承自<code>B</code>，<code>a=A()</code>，那么显然<code>isinstance(a,A)</code>返回<code>True</code>，由于<code>B</code>是<code>A</code>的父类，所以<code>B</code>是<code>a</code>所属的更大的类的范畴，所以<code>isinstance(a,B)</code>也返回<code>True</code>，即<code>a</code>是<code>B</code>的实例。根据上面<code>object</code>类和<code>type</code>类之间的关系很容易推知：一切类（包括<code>object</code>和<code>type</code>）都是<code>object</code>的实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(A(),<span class="built_in">object</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(A,<span class="built_in">object</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="built_in">object</span>,<span class="built_in">object</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="built_in">type</span>,<span class="built_in">object</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>官方建议当我们需要判断一个对象类型的时候应当使用<code>isinstance()</code>，虽然可以使用<code>type()</code>做“简单”类型判断，“简单”的原因在于，它无法判断一个对象是否属于其基类这一更大的范畴，譬如无法判断一只鹦鹉个体是否属于鸟类（谬论一），而只能判断它是鹦鹉类别</p>
<p>鹦鹉不是鸟：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span> <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Parrot</span>(<span class="params">Bird</span>):</span> <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=Parrot()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a) <span class="keyword">is</span> Parrot</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a) <span class="keyword">is</span> Bird</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(a,Bird)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>另外在旧式类（完全没必要了解）中<code>type()</code>还具有一个缺陷，譬如两个完全不同的类实例竟然能得出“类型相同”的结果（谬论二），狗和猫是同类？示例如下（python2环境）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span> <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=Dog()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=Cat()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(d) <span class="keyword">is</span> <span class="built_in">type</span>(c)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(d)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;instance&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(d,Cat)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Shiba</span>(<span class="params">Dog</span>):</span> <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(Shiba())</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;instance&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>对于新式类来说，实例化后的对象类型就是该类，这不容置疑，但是旧式类中没有基类<code>object</code>，实例化后的对象类型都是<code>instance</code><br>
<a target="_blank" rel="noopener external nofollow noreferrer" href="https://segmentfault.com/q/1010000000127305">补充</a>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        ...</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        ...</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(A(), Iterator)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>由此可见，python是根据“鸭子类型”的思想来进行类型判断的，即当看到一只鸟走起来像鸭子、游泳起来像鸭子、声音叫起来也像鸭子，那么这只鸟就可以被认为是鸭子，上述示例尽管<code>A</code>直接继承自<code>object</code>，但由于它实现了<code>__iter__()</code>和<code>__next__()</code>，因而<code>A()</code>被认为是一个迭代器对象</p>
</div></div>
<h2 id="对象的引用与复制">对象的引用与复制</h2>
<p>在程序进行像<code>a=b</code>这样的赋值时，就会创建一个对<code>b</code>的新引用，对于像数字和字符串这样的不可变对象，这种赋值实际上创建了<code>b</code>的一个副本，修改<code>b</code>并不影响<code>a</code>，然而，对于可变对象（如列表和字典），行为则完全不同，譬如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a <span class="comment">#b和a指向内存中同一位置的对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a <span class="comment">#id(a)==id(b)</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">2</span>] = -<span class="number">100</span> <span class="comment">#修改容器b中一个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="comment">#此时a仍指向b所指向的对象，所以a的内容也相应改变</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, -<span class="number">100</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = d = <span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>也就是说当两个变量引用指向同一个可变对象时，修改其中任意一个变量都会影响到另一个，为了避免这种情况，必须创建对象的副本而不是新引用。事实上对于像列表和字典这样的容器对象，存在两种复制操作：浅复制和深复制。浅复制虽然创建了一个新对象（体现在id变化），但它包含的还是对原始对象中所包含的元素（假设这个元素是可变对象的话）的引用，譬如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>]] <span class="comment">#a中第三个元素是可变对象（所谓可变对象就是对象的值变了，但其在内存中的地址仍保持不变，而改变不可变对象的值，将会在内存中新开辟一块内存存放修改后的对象）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="built_in">list</span>(a) <span class="comment">#list工厂函数属于浅复制，还有切片操作也是浅复制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]=<span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">30</span> <span class="comment">#b中第三个元素其实是对a中第三个元素的引用，当a中第三个元素的值发生变化，b中第三个元素也将相应改变</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>].append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>]=[<span class="number">11</span>,<span class="number">12</span>] <span class="comment">#该赋值使得a中第三个元素指向了内存中另一个区域的（一个列表）对象，从而对列表[30,4,5]的引用计数减1，还剩下b中第三个元素对它的唯一引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">4</span>, <span class="number">5</span>]]</span><br></pre></td></tr></table></figure>
<p>深复制也将创建一个新对象，且会递归地遍历它所包含的所有对象并创建其副本，需借助标准库中的<code>copy.deepcopy()</code>函数完成此操作</p>
<h2 id="基础数据类型">基础数据类型</h2>
<div class="tabs" id="dytab1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#dytab1-1">None</button></li><li class="tab"><button type="button" data-href="#dytab1-2">数字</button></li><li class="tab"><button type="button" data-href="#dytab1-3">序列</button></li><li class="tab"><button type="button" data-href="#dytab1-4">映射</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="dytab1-1"><p><code>None</code>类型表示一个空对象，如果一个函数没有显式地返回值，则返回该对象。<code>None</code>经常用作可选参数的默认值，以便让函数检测调用者是否为该参数实际传递了值。<code>None</code>没有任何属性，在布尔表达式中求值时为<code>False</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dytab1-2"><p>Python内置了5种数字类型（都是不可变对象）：布尔型（<code>bool</code>）、整型（<code>int</code>）、长整型（<code>long</code>，目前好像没有<code>long</code>这一类型了，并入<code>int</code>）、浮点型（<code>float</code>）以及复数型（<code>complex</code>）。布尔值包括<code>True</code>和<code>False</code>两个值（参与数值运算时分别映射为数值1和0）。整数表示范围在-2147483648和2147483647（对应<span class="hide-inline"><button type="button" class="hide-button button--animated" style="">32位二进制数<br>
</button><span class="hide-content">0111,1111,1111,1111,1111,1111,1111,1111</span></span>，其最高位为符号位）之间的所有整数。浮点型是用机器上浮点数的本机双精度（64bit）表示的，提供大约17位数的精度和范围从-308到308的指数。复数使用一对浮点数表示（<code>complex(1,2)</code>），复数的实部和虚部分别使用<code>.real</code>和<code>.imag</code>访问，<code>.conjugate()</code>用于计算复共轭（a+bj的共轭是a-bj）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="literal">True</span>] = <span class="string">&quot;JavaScript&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">1</span>] = <span class="string">&quot;Ruby&quot;</span> <span class="comment">#根据字典的原理，首先计算键1的哈希，于是找到了键True的存储位置，又发现True==1，于是认为这两个键是同一对象，于是直接将新值&#x27;Ruby&#x27;替换旧值&#x27;JavaScript&#x27;完事儿，于是现在字典中的数据变成了&#123;True:&#x27;Ruby&#x27;&#125;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">1.0</span>] = <span class="string">&quot;Python&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.keys()</span><br><span class="line">dict_keys([<span class="literal">True</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="literal">True</span>]</span><br><span class="line"><span class="string">&#x27;Python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">1.0</span>]</span><br><span class="line"><span class="string">&#x27;Python&#x27;</span></span><br></pre></td></tr></table></figure>
<div class="note info simple"><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/leisurelicht/wtfpython-cn#-whats-wrong-with-booleans%E5%B8%83%E5%B0%94%E4%BD%A0%E5%92%8B%E4%BA%86">布尔类型</a>是<code>int</code>类型的子类（如<code>isinstance(True,int)</code>为<code>True</code>），其满足<code>True == 1 == 1.0 and False == 0 == 0.0</code>为<code>True</code>的条件，换句话说，<code>True</code>、<code>1</code>、<code>1.0</code>这三个对象具有相同的哈希（同样<code>False</code>、<code>0</code>、<code>0.0</code>也是如此），在将其用作字典的键时，将映射到同一个值</p>
</div>
<div class="hide-toggle" ><div class="hide-button toggle-title " style=""><i class="fas fa-caret-right fa-fw"></i><span>进制转换</span></div>
    <div class="hide-content"><p>先说一下<code>int(x, base)</code>方法，其根据给定的进制<code>base</code>（取值为0、2~36，为什么最高是36？因为26个英文字母加上10个数字总计36，譬如有一个16进制数：<code>e1</code>，其十进制结果为225）将数字字符串<code>x</code>转换为十进制整数，也可用于将一个浮点数转换为整型（非字符串时不能传递<code>base</code>参数）。特别的，<code>base</code>取值为0时，将按照字符串的字面意思进行解释，譬如给定的字符串为<code>0o16</code>，此时不必明确告知<code>base=8</code>，因为<code>0o</code>打头的就表示这是一个八进制数。默认的<code>base</code>值为10，即默认将一个十进制数字字符串转换为十进制整型（<code>int('1314')=1314</code>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#2、8、16进制转为10进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;10010&#x27;</span>,<span class="number">2</span>) <span class="comment">#int(&#x27;0b10010&#x27;,0)</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;32&#x27;</span>,<span class="number">8</span>) <span class="comment">#int(&#x27;0o32&#x27;,0)</span></span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;e1&#x27;</span>,<span class="number">16</span>) <span class="comment">#int(&#x27;0xe1&#x27;,0)</span></span><br><span class="line"><span class="number">225</span></span><br></pre></td></tr></table></figure>
<p>总而言之，<code>int()</code>只能用于将2~36进制的数（且为字符串类型）转换为10进制，如果你要将一个10进制数转换为2进制、8进制转为2进制、2进制转为8进制等等那它就无能为力了，下面介绍<code>bin()</code>、<code>oct()</code>以及<code>hex()</code>，分别用于将一个整数（这个整数可以是10进制的，也可以是2进制、8进制和16进制的）转换为2进制、8进制以及16进制：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#10进制转2进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="number">18</span>)</span><br><span class="line"><span class="string">&#x27;0b10010&#x27;</span></span><br><span class="line"><span class="comment">#8进制转2进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="number">0o22</span>)</span><br><span class="line"><span class="string">&#x27;0b10010&#x27;</span></span><br><span class="line"><span class="comment">#16进制转2进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="number">0x12</span>)</span><br><span class="line"><span class="string">&#x27;0b10010&#x27;</span></span><br><span class="line"><span class="comment">#10进制转8进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">oct</span>(<span class="number">26</span>)</span><br><span class="line"><span class="string">&#x27;0o32&#x27;</span></span><br><span class="line"><span class="comment">#2进制转8进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">oct</span>(<span class="number">0b11010</span>)</span><br><span class="line"><span class="string">&#x27;0o32&#x27;</span></span><br><span class="line"><span class="comment">#16进制转8进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">oct</span>(<span class="number">0x1a</span>)</span><br><span class="line"><span class="string">&#x27;0o32&#x27;</span></span><br><span class="line"><span class="comment">#10进制转16进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="number">225</span>)</span><br><span class="line"><span class="string">&#x27;0xe1&#x27;</span></span><br><span class="line"><span class="comment">#2进制转16进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="number">0b11100001</span>)</span><br><span class="line"><span class="string">&#x27;0xe1&#x27;</span></span><br><span class="line"><span class="comment">#8进制转16进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="number">0o341</span>)</span><br><span class="line"><span class="string">&#x27;0xe1&#x27;</span></span><br></pre></td></tr></table></figure>
<p>以上描述了2、8、10、16进制数之间的相互转换，那么任意进制（2~36）之间如何相互转换呢，可以借助10进制数作为中间状态，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transform</span>(<span class="params">x,base=<span class="literal">None</span>,to=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;将base进制整数x转换为to进制数y，函数返回y</span></span><br><span class="line"><span class="string">        合法的进制范围为2~36，</span></span><br><span class="line"><span class="string">        x是一个字符串，是为了通用性考虑，因为整</span></span><br><span class="line"><span class="string">        数类型只涵盖了2、8、10、16进制，譬如16：</span></span><br><span class="line"><span class="string">        0b10000、0o20、16、0x10，但是其36进制为</span></span><br><span class="line"><span class="string">        g，只能以字符串形式表示，特别的，输入允</span></span><br><span class="line"><span class="string">        许以&#x27;0b&#x27;、&#x27;0o&#x27;、&#x27;0x&#x27;打头(此时base可以不</span></span><br><span class="line"><span class="string">        给或任意)，也可以不是，但</span></span><br><span class="line"><span class="string">        是作为输出的2、8、16进制数字字符串一律不</span></span><br><span class="line"><span class="string">        会以&#x27;0b&#x27;、&#x27;0o&#x27;、&#x27;0x&#x27;打头。</span></span><br><span class="line"><span class="string">        转换原理是，将base进制先转换为10进制，再</span></span><br><span class="line"><span class="string">        将这个10进制转换为to进制</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    x=x.lower()</span><br><span class="line">    x_10=<span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> x[:<span class="number">2</span>] <span class="keyword">in</span> [<span class="string">&#x27;0b&#x27;</span>,<span class="string">&#x27;0o&#x27;</span>,<span class="string">&#x27;0x&#x27;</span>]:</span><br><span class="line">        x_10=<span class="built_in">int</span>(x,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i,e <span class="keyword">in</span> <span class="built_in">enumerate</span>(x[::-<span class="number">1</span>]):</span><br><span class="line">            x_10+=(<span class="built_in">pow</span>(base,i)*(<span class="built_in">ord</span>(e)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)+<span class="number">10</span> <span class="keyword">if</span> <span class="string">&#x27;a&#x27;</span>&lt;=e&lt;=<span class="string">&#x27;z&#x27;</span> <span class="keyword">else</span> <span class="built_in">int</span>(e)))</span><br><span class="line">    y=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> x_10&gt;<span class="number">0</span>:</span><br><span class="line">        t=x_10%to</span><br><span class="line">        y+=(<span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)+t-<span class="number">10</span>) <span class="keyword">if</span> t&gt;<span class="number">9</span> <span class="keyword">else</span> <span class="built_in">str</span>(t))</span><br><span class="line">        x_10//=to</span><br><span class="line">    <span class="keyword">return</span> y[::-<span class="number">1</span>] <span class="keyword">if</span> y!=<span class="string">&#x27;&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    </span><br><span class="line">transform(<span class="string">&#x27;16&#x27;</span>,base=<span class="number">10</span>,to=<span class="number">36</span>) <span class="comment">#g</span></span><br><span class="line">f2t16=partial(transform,base=<span class="number">2</span>,to=<span class="number">16</span>) <span class="comment">#from 2 to 16</span></span><br><span class="line">f2t16(<span class="string">&#x27;11100001&#x27;</span>) <span class="comment">#e1</span></span><br></pre></td></tr></table></figure>
<p>上述代码中十进制转任意进制部分，有人给出了<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/answer/1878284306">递归</a>写法（我用的循环）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transform_10_to_any</span>(<span class="params">n,base</span>):</span></span><br><span class="line">    string=<span class="string">&#x27;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span> <span class="comment">#&#x27;&#x27;.join([*[str(i) for i in range(10)],*[chr(ord(&#x27;A&#x27;)+i) for i in range(26)]])</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;base:</span><br><span class="line">        <span class="keyword">return</span> string[n]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> transform_10_to_any(n//base,base)+string[n%base]</span><br><span class="line">        </span><br><span class="line">print(transform_10_to_any(<span class="number">28</span>,<span class="number">16</span>)) <span class="comment">#1C</span></span><br><span class="line">print(transform_10_to_any(<span class="number">28</span>**<span class="number">690</span>,<span class="number">10</span>)) <span class="comment">#RecursionError: maximum recursion depth exceeded in comparison</span></span><br></pre></td></tr></table></figure>
<p>由于存在递归深度限制，我将其改造成了尾递归版本，并使用<code>@tail_call_optimized</code>（见后，序列三大操作函数之<code>reduce()</code>案例3）进行修饰：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@tail_call_optimized</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transform_10_to_any</span>(<span class="params">n,base,temp=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    string=<span class="string">&#x27;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;base:</span><br><span class="line">        <span class="keyword">return</span> string[n]+temp</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> transform_10_to_any(n//base,base,string[n%base]+temp)</span><br><span class="line">        </span><br><span class="line">print(transform_10_to_any(<span class="number">28</span>**<span class="number">690</span>,<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>注，任意进制转10进制的办法：<emp>按权相加</emp>，例如，将8进制数字 53627 转换成10进制：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>o</mi><mn>53627</mn><mo>=</mo><mn>5</mn><mo>×</mo><msup><mn>8</mn><mn>4</mn></msup><mo>+</mo><mn>3</mn><mo>×</mo><msup><mn>8</mn><mn>3</mn></msup><mo>+</mo><mn>6</mn><mo>×</mo><msup><mn>8</mn><mn>2</mn></msup><mo>+</mo><mn>2</mn><mo>×</mo><msup><mn>8</mn><mn>1</mn></msup><mo>+</mo><mn>7</mn><mo>×</mo><msup><mn>8</mn><mn>0</mn></msup><mo>=</mo><mn>22423</mn></mrow><annotation encoding="application/x-tex">0o53627 = 5×8^4 + 3×8^3 + 6×8^2 + 2×8^1 + 7×8^0 = 22423</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">o</span><span class="mord">5</span><span class="mord">3</span><span class="mord">6</span><span class="mord">2</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord">4</span><span class="mord">2</span><span class="mord">3</span></span></span></span> (十进制)。所谓“权”（即位权），对于一个8进制数，从左往右看，第1位的位权为 8<sup>0</sup>=1，第2位的位权为 8<sup>1</sup>=8，第3位的位权为 8<sup>2</sup>=64，第4位的位权为 8<sup>3</sup>=512，第5位的位权为 8<sup>4</sup>=4096 …… 第n位的位权就为 8<sup>n-1</sup>，将各个位的数字乘以位权，然后再相加，就得到了十进制数值</p>
<p>将十进制转为任意N进制的办法，<emp>除N取余，逆序排列</emp>，例如将一个10进制数转换为8进制（36926 → 110076）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">36926&#x2F;8 &#x3D; 4615(除数) ··· 6(余数)</span><br><span class="line">4615  &#x2F;8 &#x3D; 576              ··· 7</span><br><span class="line">576    &#x2F;8 &#x3D; 72                ··· 0</span><br><span class="line">72      &#x2F;8 &#x3D; 9                  ··· 0</span><br><span class="line">9        &#x2F;8 &#x3D; 1                  ··· 1</span><br><span class="line">1        &#x2F;8 &#x3D; 0                  ··· 1(除数为0时停止)</span><br></pre></td></tr></table></figure>
<p>以上说的都是整数，那么如何对小数部分进行进制转换呢？例如将一个浮点数从8进制转换为10进制（还是<emp>按权相加</emp>）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>423.5176</mn></mrow><annotation encoding="application/x-tex">423.5176</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">2</span><span class="mord">3</span><span class="mord">.</span><span class="mord">5</span><span class="mord">1</span><span class="mord">7</span><span class="mord">6</span></span></span></span> (八进制) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mn>4</mn><mo>×</mo><msup><mn>8</mn><mn>2</mn></msup><mo>+</mo><mn>2</mn><mo>×</mo><msup><mn>8</mn><mn>1</mn></msup><mo>+</mo><mn>3</mn><mo>×</mo><msup><mn>8</mn><mn>0</mn></msup><mo>+</mo><mn>5</mn><mo>×</mo><msup><mn>8</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>8</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup><mo>+</mo><mn>7</mn><mo>×</mo><msup><mn>8</mn><mrow><mo>−</mo><mn>3</mn></mrow></msup><mo>+</mo><mn>6</mn><mo>×</mo><msup><mn>8</mn><mrow><mo>−</mo><mn>4</mn></mrow></msup><mo>=</mo><mn>275.65576171875</mn></mrow><annotation encoding="application/x-tex">= 4×8^2 + 2×8^1 + 3×8^0 + 5×8^{-1} + 1×8^{-2} + 7×8^{-3} + 6×8^{-4} = 275.65576171875</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mord">5</span><span class="mord">.</span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">7</span><span class="mord">6</span><span class="mord">1</span><span class="mord">7</span><span class="mord">1</span><span class="mord">8</span><span class="mord">7</span><span class="mord">5</span></span></span></span> (十进制)。即小数部分和整数部分情况相反，要从左往右看，第1（小数）位的位权为 8<sup>-1</sup>=1/8，第2位的位权为 8<sup>-2</sup>=1/64，第3位的位权为 8<sup>-3</sup>=1/512，第4位的位权为 8<sup>-4</sup>=1/4096 …… 第m位的位权就为 8<sup>-m</sup></p>
<p>另外如何将一个浮点数从10进制转换为8进制呢？规则为：<emp>乘N取整，顺序排列</emp>，示例如下（0.930908203125 → 7345）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0.930908203125×8 &#x3D; 7.447265625 → 7(取整)</span><br><span class="line">0.447265625      ×8 &#x3D; 3.578125       → 3</span><br><span class="line">0.578125            ×8 &#x3D; 4.625             → 4</span><br><span class="line">0.625                  ×8 &#x3D; 5.0                 → 5(乘数结果小数部分为0时停止)</span><br></pre></td></tr></table></figure>
<div class="note warning flat"><p>由于浮点计算的不精确性，无法在程序中判断小数点后是否为0，小数进制转换代码就不写了，可能需要借助<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.sympy.org/latest/index.html">Sympy</a>符号运算库？</p>
</div></div></div>
<div class="note info flat"><p>日常生活中逗号常见于大整数的表示中，如<code>10,000,000</code>，从python3.6开始支持整数中使用<code>_</code>标记，作用同逗号：<code>a=10_000_000</code>，也适用于十六进制或二进制等：<code>b=0b1_010_101</code></p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dytab1-3"><p>Python内置序列对象包括字符串、列表和元组，字符串是字符的序列，而列表和元组是任意对象的序列。字符串和元组均属于不可变对象，而列表支持插入、删除、替换元素操作。所有序列都支持迭代（见可迭代对象）</p>
<div class="tabs" id="dytab1-1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#dytab1-1-1">字符串</button></li><li class="tab"><button type="button" data-href="#dytab1-1-2">列表</button></li><li class="tab"><button type="button" data-href="#dytab1-1-3">元组</button></li><li class="tab"><button type="button" data-href="#dytab1-1-4">⭐可迭代对象</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="dytab1-1-1"><p>字符串的方法太多，请参阅文献[1]-p34</p>
<div class="hide-toggle" ><div class="hide-button toggle-title " style=""><i class="fas fa-caret-right fa-fw"></i><span>格式化字符串</span></div>
    <div class="hide-content"><p>有两种格式化方式：占位符(<code>%</code>)和<code>format()</code>方法</p>
<ol>
<li>占位符(<code>%</code>)<br>
<div class="tabs" id="dy_test_str1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#dy_test_str1-1">说明</button></li><li class="tab"><button type="button" data-href="#dy_test_str1-2">示例</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="dy_test_str1-1"><p>取模运算符（<code>s % d</code>）也被用于生成格式化的字符串，其中<code>s</code>是一个格式字符串，而<code>d</code>是一个元组或映射对象（字典），格式字符串包含两种类型：普通字符和转换字符（总是以<code>%</code>打头），格式化程序会根据转换字符将相关元组或映射中的元素转换为对应的输出格式并替换原始的转换字符。如果<code>d</code>是一个元组，转换字符的个数必须与<code>d</code>中对象的个数保持一致，如果<code>d</code>是一个映射，每个转换字符都必须与映射中的一个有效键名相关联</p>
<div class="hide-toggle" ><div class="hide-button toggle-title " style=""><i class="fas fa-caret-right fa-fw"></i><span>转换字符</span></div>
    <div class="hide-content"><div class="dytable">
<table>
<thead>
<tr>
<th style="text-align:center">转换字符</th>
<th style="text-align:center">输出格式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%c</td>
<td style="text-align:center">单个字符</td>
</tr>
<tr>
<td style="text-align:center">%s</td>
<td style="text-align:center">字符串,格式化对象时用str()生成字符串</td>
</tr>
<tr>
<td style="text-align:center">%r</td>
<td style="text-align:center">字符串,格式化对象时用repr()生成字符串</td>
</tr>
<tr>
<td style="text-align:center">%d,%i</td>
<td style="text-align:center">(长)整数(十进制)</td>
</tr>
<tr>
<td style="text-align:center">%u</td>
<td style="text-align:center">无符号(长)整数(十进制)</td>
</tr>
<tr>
<td style="text-align:center">%o</td>
<td style="text-align:center">(长)整数(八进制)</td>
</tr>
<tr>
<td style="text-align:center">%x</td>
<td style="text-align:center">(长)整数(十六进制)</td>
</tr>
<tr>
<td style="text-align:center">%X</td>
<td style="text-align:center">(长)整数(十六进制,大写字母)</td>
</tr>
<tr>
<td style="text-align:center">%e</td>
<td style="text-align:center">浮点数(科学计数法,如[-]m.dddddde±xx)</td>
</tr>
<tr>
<td style="text-align:center">%E</td>
<td style="text-align:center">浮点数(科学计数法,如[-]m.ddddddE±xx)</td>
</tr>
<tr>
<td style="text-align:center">%f</td>
<td style="text-align:center">浮点数(如[-]m.dddddd)</td>
</tr>
<tr>
<td style="text-align:center">%g,%G</td>
<td style="text-align:center">指数小于-4或更高精度时使用%e或%E,否则使用%f</td>
</tr>
<tr>
<td style="text-align:center">%p</td>
<td style="text-align:center">指针(用十六进制表示对象的内存地址)</td>
</tr>
<tr>
<td style="text-align:center">%%</td>
<td style="text-align:center">字面量百分号</td>
</tr>
</tbody>
</table>
</div></div></div>
<p>在<code>%</code>和转换字符之间可以出现以下修饰符，并且只能按照下述顺序出现：</p>
<ol>
<li>位于括号中的一个键名，用于从映射对象中选出一个具体项，如果不存在此键，则引发<code>KeyError</code>异常</li>
<li>下面所列的一个或多个
<ul>
<li><code>-</code>，左对齐标志，默认为右对齐</li>
<li><code>+</code>，表示应该包含数字符号（即使为正值也是如此）</li>
<li><code>0</code>，表示零填充（仅用于数字类型，如<code>%d</code>、<code>%f</code>）</li>
</ul>
</li>
<li>一个指定最小宽度的数字，转换后的值将被打印在至少为这个宽度的字段中，并且在左边填充至满字段宽（如果指定了<code>-</code>标志，则填充在右边）</li>
<li>一个小数点，用于按照精度分割字段宽度</li>
<li>一个数字，指定要打印字符串中的最大字符个数，或者浮点数中小数点之后的位数，或者整数的最小位数</li>
</ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dy_test_str1-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;my name is %s%c%c, my age is %d&#x27;</span> % (<span class="string">&#x27;muggle&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">121</span>,<span class="number">23</span>) <span class="comment">#%c还可以接受整数（具体参见ASCII码表，或通过ord()、chr()转换）并转换为对应字符</span></span><br><span class="line"><span class="string">&#x27;my name is muggledy, my age is 23&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=&#123;<span class="string">&#x27;x&#x27;</span>:<span class="number">13</span>, <span class="string">&#x27;y&#x27;</span>:<span class="number">1.54321</span>, <span class="string">&#x27;z&#x27;</span>:<span class="string">&#x27;hello world&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%.5s&#x27;</span> % d[<span class="string">&#x27;z&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%(x)05d, %(y).2f&#x27;</span> % d</span><br><span class="line"><span class="string">&#x27;00013, 1.54&#x27;</span></span><br></pre></td></tr></table></figure>
<div class="hide-toggle" ><div class="hide-button toggle-title " style=""><i class="fas fa-caret-right fa-fw"></i><span><code>ord()</code>和<code>chr()</code></span></div>
    <div class="hide-content"><p>有些论坛不允许新人帖包含url链接，最简单的办法之一是将链接的每个字符转换成ASCII码，其他人再将ASCII转为字符。具体使用<code>ord()</code>函数返回单个字符的ASCII（0-255）以及<code>chr()</code>函数返回一个整数（0-255）对应的字符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;http://www.paperpass.com/&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="built_in">ord</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> s] <span class="comment">#编码</span></span><br><span class="line">[<span class="number">104</span>, <span class="number">116</span>, <span class="number">116</span>, <span class="number">112</span>, <span class="number">58</span>, <span class="number">47</span>, <span class="number">47</span>, <span class="number">119</span>, <span class="number">119</span>, <span class="number">119</span>, <span class="number">46</span>, <span class="number">112</span>, <span class="number">97</span>, <span class="number">112</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">112</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">46</span>, <span class="number">99</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">47</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">eval</span>(<span class="string">&#x27;[104,116,116,112,58,47,47,119,119,119,46,112,97,112,101,114,112,97,115,115,46,99,111,109,47]&#x27;</span>)]) <span class="comment">#解码</span></span><br><span class="line"><span class="string">&#x27;http://www.paperpass.com/&#x27;</span></span><br></pre></td></tr></table></figure></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
</li>
<li><code>format()</code>方法<br>
<p>高级字符串格式化，调用字符串<code>s</code>的<code>format()</code>方法：<code>s.format(*args,**kwargs)</code>，其接受位置参数和关键字参数的任意组合，并使用它们的值来替换<code>s</code>中嵌入的占位符，形式为<code>&#123;n&#125;</code>的占位符（<code>n</code>为数字，某些情况下可以省略）将被<code>format()</code>方法的第<code>n</code>个位置参数替换，而形式为<code>&#123;name&#125;</code>的占位符将被名为<code>name</code>的关键字参数值替换，如果要输出一个<code>&#123;</code>或<code>&#125;</code>，必须使用<code>&#123;&#123;</code>或<code>&#125;&#125;</code>的形式</p>
<p>使用占位符还可以对位置参数或关键字参数进行数值或键索引，如<code>&#123;name[n]&#125;</code>（<code>n</code>为索引数字，对应<code>name</code>是列表）、<code>&#123;name[key]&#125;</code>（<code>key</code>为非数字字符串，对应<code>name</code>是字典），譬如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;my name is &#123;1&#125;, &#123;0[0]&#125;+&#123;0[1]&#125;=&#123;0[2]&#125;, &#123;2[x]&#125;&#123;2[y]&#125;&#123;2[z]&#125;, &#123;d&#125;, &#123;e[0]&#125;, &#123;e[1]&#125;&#x27;</span>.<span class="built_in">format</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="string">&#x27;dy&#x27;</span>,&#123;<span class="string">&#x27;x&#x27;</span>:<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;y&#x27;</span>:<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;z&#x27;</span>:<span class="string">&#x27;c&#x27;</span>&#125;,d=<span class="number">4</span>,e=[<span class="number">5</span>,<span class="string">&#x27;msy&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;my name is dy, 1+2=3, abc, 4, 5, msy&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;d&#125;, &#123;&#125;,&#123;&#125;, &#123;e&#125;, &#123;&#125;&#x27;</span>.<span class="built_in">format</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="string">&#x27;dy&#x27;</span>,&#123;<span class="string">&#x27;x&#x27;</span>:<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;y&#x27;</span>:<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;z&#x27;</span>:<span class="string">&#x27;c&#x27;</span>&#125;,d=<span class="number">4</span>,e=[<span class="number">5</span>,<span class="string">&#x27;msy&#x27;</span>]) <span class="comment">#使用缺省的&#123;&#125;占位符，将和位置参数从左至右一一对应</span></span><br><span class="line"><span class="string">&quot;4, [1, 2, 3],dy, [5, &#x27;msy&#x27;], &#123;&#x27;x&#x27;: &#x27;a&#x27;, &#x27;y&#x27;: &#x27;b&#x27;, &#x27;z&#x27;: &#x27;c&#x27;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>使用占位符还可以对位置参数或关键字参数进行属性查找，如<code>&#123;name.attr&#125;</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0.real&#125; &#123;0.imag&#125;&#x27;</span>.<span class="built_in">format</span>(x)</span><br><span class="line"><span class="string">&#x27;1.0 2.0&#x27;</span></span><br></pre></td></tr></table></figure>
<p>另外，还可以指定格式说明符，对输出进行更加精确的控制，具体是用一个冒号（<code>:</code>）给每个占位符添加可选的格式说明符，形如<code>&#123;place:format_spec&#125;</code>，使用这种说明符可以指定列宽、小数位和对齐方式，一般格式是<code>[[fill]align][sign][0][width][.precision][type]</code>（<code>[]</code>中的每个部分都是可选的，特别地，当给定<code>fill</code>时，也必须同时给定<code>align</code>），<code>width</code>说明符指定要使用的最小字段宽度，<code>align</code>说明符的可取值为<code>&lt;</code>、<code>&gt;</code>或<code>^</code>（分别代表左对齐、右对齐和居中对齐），<code>fill</code>是一个可选的填充字符，默认用空格填充，<code>type</code>说明符表示数据的类型，可以不提供，默认值分别是<code>s</code>（字符串）、<code>d</code>（整数）、<code>e</code>（浮点数，科学计数），<code>sign</code>说明符可取值为<code>+</code>、<code>-</code>或空格，用于在数值类型前加上符号，<code>precision</code>说明符指定十进制数的精度位数，另外如果在<code>width</code>前面加上一个<code>0</code>，就会使用<code>0</code>来填充数字前面的空白，看个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;|&#123;:#^10&#125;|&#123;age:^+10.2f&#125;|&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;dy&#x27;</span>,age=<span class="number">25.54321</span>,)</span><br><span class="line"><span class="string">&#x27;|####dy####|  +25.54  |&#x27;</span></span><br></pre></td></tr></table></figure>
<div class="hide-toggle" ><div class="hide-button toggle-title " style=""><i class="fas fa-caret-right fa-fw"></i><span>Formatted string literals(f-string)</span></div>
    <div class="hide-content"><div class="note info simple"><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://realpython.com/python-f-strings/">F-string</a>是python3.6引入的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals">新特性</a>，使用方式形如：<code>f’字符串’</code>或<code>F’字符串’</code>，字符串中使用大括号作为占位符标识要替换的字段，本质上f-string并非常量字符串，它将在运行时对其中的字段求值，f-string在设计上用于替代<code>%</code>和<code>format()</code>这两种传统格式化方法，性能优于二者且形式更加简便</p>
</div>
<ul>
<li>简单使用：<br>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&quot;Eric&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age = <span class="number">74</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>. You are <span class="subst">&#123;age&#125;</span>.&quot;</span></span><br><span class="line"><span class="string">&#x27;Hello, Eric. You are 74.&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>表达式求值和函数调用：<br>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&quot;<span class="subst">&#123;<span class="number">2</span> * <span class="number">37</span>&#125;</span>&quot;</span> <span class="comment">#表达式求值</span></span><br><span class="line"><span class="string">&#x27;74&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">to_lowercase</span>(<span class="params"><span class="built_in">input</span></span>):</span></span><br><span class="line">. . .         <span class="keyword">return</span> <span class="built_in">input</span>.lower()</span><br><span class="line">. . .</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&quot;Eric Idle&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&quot;<span class="subst">&#123;to_lowercase(name)&#125;</span> is funny.&quot;</span> <span class="comment">#函数调用</span></span><br><span class="line"><span class="string">&#x27;eric idle is funny.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&quot;<span class="subst">&#123;name.lower()&#125;</span> is funny.&quot;</span> <span class="comment">#调用对象方法</span></span><br><span class="line"><span class="string">&#x27;eric idle is funny.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;The answer is <span class="subst">&#123;math.log(math.pi)&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">&#x27;The answer is 1.1447298858494002&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>comedian = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Eric Idle&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">74</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&quot;The comedian is <span class="subst">&#123;comedian[<span class="string">&#x27;name&#x27;</span>]&#125;</span>, aged <span class="subst">&#123;comedian[<span class="string">&#x27;age&#x27;</span>]&#125;</span>.&quot;</span></span><br><span class="line">The comedian <span class="keyword">is</span> Eric Idle, aged <span class="number">74.</span></span><br></pre></td></tr></table></figure>
<p>注：如果占位符<code>&#123;...&#125;</code>中的对象非字符串，那么将调用对象的<code>__str__()</code>方法（和<code>__repr__()</code>方法相比，前者面向人类，后者面向计算机，一般来说，你甚至可以通过执行（调用<code>eval()</code>函数）<code>repr()</code>返回的字符串重新生成对象，如果只实现<code>__repr__()</code>，那么<code>str()</code>还是会调用对象的<code>__repr__()</code>方法），并以返回的字符串替换占位符（如果同时也定义了<code>__repr__()</code>方法，且希望格式化时使用该方法返回的字符串，则写成<code>&#123;...!r&#125;</code>），看个例子：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comedian</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, first_name, last_name, age</span>):</span></span><br><span class="line">        self.first_name = first_name</span><br><span class="line">        self.last_name = last_name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.first_name&#125;</span> <span class="subst">&#123;self.last_name&#125;</span> is <span class="subst">&#123;self.age&#125;</span>.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.first_name&#125;</span> <span class="subst">&#123;self.last_name&#125;</span> is <span class="subst">&#123;self.age&#125;</span>. Surprise!&quot;</span></span><br><span class="line"></span><br><span class="line">new_comedian = Comedian(<span class="string">&quot;Eric&quot;</span>, <span class="string">&quot;Idle&quot;</span>, <span class="string">&quot;74&quot;</span>)</span><br><span class="line">print(<span class="string">f&#x27;<span class="subst">&#123;new_comedian&#125;</span>&#x27;</span>) <span class="comment">#Eric Idle is 74.</span></span><br><span class="line">print(<span class="string">f&#x27;<span class="subst">&#123;Comedian(<span class="string">&quot;Yang&quot;</span>,<span class="string">&quot;Dai&quot;</span>,<span class="number">25</span>)&#125;</span>&#x27;</span>) <span class="comment">#Yang Dai is 25.</span></span><br><span class="line">print(&gt;&gt;&gt; <span class="string">f&quot;<span class="subst">&#123;new_comedian!r&#125;</span>&quot;</span>) <span class="comment">#&#x27;Eric Idle is 74. Surprise!&#x27;</span></span><br></pre></td></tr></table></figure>
注1：字符串内的引号不能和字符串外的引号定界符冲突，可根据情况灵活切换<code>'</code>和<code>"</code>（单引号和双引号），必要的时候，还可以使用三引号<code>'''</code>或者<code>"""</code>，再不行，还可以使用斜杠<code>\</code>对特殊字符进行转义，譬如<code>'i\'m dy.'</code>，但是f-string大括号内部不能使用斜杠<code>\</code>转义甚至说根本就不能出现任何斜杠
</p>
<p>注2，支持多重大括号写法，譬如双重大括号，<code>f'&#123;&#123;5&#125;&#125;'</code>将打印出字符串<code>'&#123;5&#125;'</code>，此时双重大括号中的内容是被当作普通字符串，再譬如：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;temp_a&#125;</span>&#x27;</span> <span class="comment">#temp_a从未定义，没有这个变量</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">&#x27;temp_a&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;&#123;&#123;temp_a&#125;&#125;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#123;temp_a&#125;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;&#123;&#123;70 + 4&#125;&#125;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#123;70 + 4&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>要当作变量或表达式或函数调用，则再加一层大括号，即三重大括号：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;&#123;&#123;<span class="subst">&#123;<span class="number">70</span> + <span class="number">4</span>&#125;</span>&#125;&#125;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#123;74&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果是四重大括号（规律也很明显了）：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;&#123;&#123;&#123;&#123;70 + 4&#125;&#125;&#125;&#125;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#123;&#123;70 + 4&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</p>
</li>
<li>多行f-strings：<br>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Eric&quot;</span></span><br><span class="line">profession = <span class="string">&quot;comedian&quot;</span></span><br><span class="line">affiliation = <span class="string">&quot;Monty Python&quot;</span></span><br><span class="line">message = (</span><br><span class="line">    <span class="string">f&quot;Hi <span class="subst">&#123;name&#125;</span>. &quot;</span></span><br><span class="line">    <span class="string">f&quot;You are a <span class="subst">&#123;profession&#125;</span>. &quot;</span></span><br><span class="line">    <span class="string">f&quot;You were in <span class="subst">&#123;affiliation&#125;</span>.&quot;</span></span><br><span class="line">)</span><br><span class="line">print(message) <span class="comment">#Hi Eric. You are a comedian. You were in Monty Python.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#上述写法需要在每一行首部添加标识f或F，如果不像这样可以使用三引号实现多行字符串（但注意下面会输出三行）：</span></span><br><span class="line">message = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Hi <span class="subst">&#123;name&#125;</span>. </span></span><br><span class="line"><span class="string">    You are a <span class="subst">&#123;profession&#125;</span>. </span></span><br><span class="line"><span class="string">    You were in <span class="subst">&#123;affiliation&#125;</span>.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>注，多个（位于同一行的）独立字符串之间不需要使用任何连接符（如果不在同一行，需要在行末加上斜杠表示换行（任意语句如果太长，你都可以在一行结尾处使用斜杠，然后就可以在下一行继续书写上一条语句剩余的内容，且不受python正常的缩进规则限制），如果不想写斜杠，也可以在所有独立字符串的左右两端裹上小括号），它们同样会被自动拼接：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">&quot;Hello&quot;</span> <span class="string">&quot; world!&quot;</span></span><br><span class="line">print(s) <span class="comment">#Hello world!</span></span><br><span class="line"></span><br><span class="line">s=<span class="string">&quot;dy &quot;</span> <span class="string">&quot;is &quot;</span> \</span><br><span class="line"><span class="string">&#x27;a&#x27;</span>   <span class="string">&#x27; &#x27;</span> \</span><br><span class="line"><span class="string">&#x27;muggle&#x27;</span></span><br><span class="line">print(s) <span class="comment">#dy is a muggle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#等同于：</span></span><br><span class="line">s=(<span class="string">&quot;dy &quot;</span> <span class="string">&quot;is &quot;</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span>   <span class="string">&#x27; &#x27;</span></span><br><span class="line"><span class="string">&#x27;muggle&#x27;</span>)</span><br><span class="line">print(s) <span class="comment">#dy is a muggle</span></span><br></pre></td></tr></table></figure>
<p>且多个独立字符串作为函数参数时，不论是否在同一行，都无需斜杠作为换行符：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line"></span><br><span class="line">f(<span class="string">&quot;muggle&quot;</span></span><br><span class="line"><span class="string">&quot;dy&quot;</span>,<span class="string">&quot;dai&quot;</span> \</span><br><span class="line"><span class="string">&quot;xiao&quot;</span><span class="string">&quot;dong&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">muggledy</span></span><br><span class="line"><span class="string">daixiaodong</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>格式精确控制（对齐、宽度、符号、补零、精度、进制等）：<br>
类似<code>format()</code>，f-string使用形如<code>&#123;content:format_spec&#125;</code>进行格式的精确控制，其中<code>content</code>可以是变量、表达式或函数等，<code>format_spec</code>是格式描述符，采用默认格式时，则省略<code>:format_spec</code>，格式描述的使用顺序要注意，具体请参阅文章[2]相关部分
</li>
</ul>
<div class="hide-toggle" ><div class="hide-button toggle-title " style=""><i class="fas fa-caret-right fa-fw"></i><span><code>print()</code>函数</span></div>
    <div class="hide-content"><p>当使用<code>print()</code>打印对象的时候，实际上是调用了标准输出并向其中写入字符串：<code>sys.stdout.write(str(obj)+'\n')</code>，<code>sys.stdout</code>就是标准输出对象，默认是写入到控制台设备并追加一个换行符（可以通过指定<code>print()</code>函数的<code>end</code>参数修改所追加的字符或字符串），当然你也可以修改<code>sys.stdout</code>的值，以实现输出重定向，譬如将输出重定向至某个文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>__console__ = sys.stdout <span class="comment">#将控制台对象引用保存下来以便于恢复</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file = <span class="built_in">open</span>(<span class="string">&#x27;redir_print.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout = file</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&#x27;Hello,World!&#x27;</span>) <span class="comment">#此时等同于：file.write(...)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file.flush() <span class="comment">#打印的内容首先存在于缓冲区flush中，直到下一次打印时上次的打印（内容）才被写到文件中，使用flush()强制刷新缓冲区将其写进文件</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout = __console__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file.close()</span><br></pre></td></tr></table></figure>
<p>在python3中不需要像上面这样繁琐，指定<code>print()</code>函数的<code>file</code>参数和<code>flush</code>参数即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&#x27;Hello,World!&#x27;</span>, file = file, flush = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>实际上你可以往<code>print()</code>中传递任意数量的任意对象且是以位置参数的形式，因为<code>__str__()</code>具有默认实现，其返回一个尖括号包裹的字符串，包含类名和内存地址信息，不同对象的输出字符串会自动连接且以单个空格作为间隔符：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&#x27;muggledy&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,...,<span class="string">&#x27;zj&#x27;</span>,A())</span><br><span class="line">muggledy + <span class="literal">Ellipsis</span> zj &lt;__main__.A <span class="built_in">object</span> at <span class="number">0x000001B0358AB7B8</span>&gt;</span><br></pre></td></tr></table></figure></div></div></div></div>
</li>
</ol></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dytab1-1-2"><ol><li> 增加<br>
   <ul><li> <code>s.append(x)</code></li>
   <li><code>s.extend(t)</code><br>
     注：不同于<code>append</code>追加元素，<code>extend</code>将一个新的序列扩展到原始序列中，等同于<code>[*s,*t]</code>（解包）
     <div class="hide-toggle" ><div class="hide-button toggle-title " style=""><i class="fas fa-caret-right fa-fw"></i><span>解包与装包</span></div>
    <div class="hide-content"><p>主要有三种用途：变量赋值，函数传参和简化容器添加</p>
<ol><li>变量赋值<br>
<ul>
<li>将多个值或者说对象（其以逗号间隔）赋值给一个变量时，python会自动将这些值封装成元组，这种特性即称为“装包”：<br>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>特别地，当函数返回多个数值时，也会进行装包：<br>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a,b,c</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a*<span class="number">1</span>,b*<span class="number">2</span>,c*<span class="number">3</span></span><br><span class="line">    </span><br><span class="line">ret=f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(ret,<span class="built_in">type</span>(ret)) <span class="comment">#(1, 4, 9) &lt;class &#x27;tuple&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>将一个（可迭代）对象拆分成多个对象并依次赋值给多个变量，这种特性即称为“解包”，另外还可以用星号<code>*</code>修饰变量，使其接收多个拆解对象的组合（装包为列表类型）：<br>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x,y,z=a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x,*y,z=<span class="built_in">range</span>(<span class="number">10</span>) <span class="comment">#非*修饰变量（x,z）只能接收一个拆解对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
</li>
<li>可以解包的对象类型包括元组、列表、字典、生成器以及其它可迭代对象：<br>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125; <span class="comment">#字典也是可迭代对象，等同于迭代其键序列，但是要注意键序列其实是“无序”的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x,y,z=d</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x,y,z</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x,y,z=d.items() <span class="comment">#如果要同时得到字典的键值的话</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x,y,z</span><br><span class="line">((<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)) <span class="comment">#生成器也是可迭代对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x,y,z=a</span><br></pre></td></tr></table></figure>
<p>装包和解包常用于“对称性赋值”操作和<code>for</code>循环中的变量拆解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x,y=<span class="number">6</span>,<span class="number">8</span></span><br><span class="line">x,y=y,x</span><br><span class="line">print(x,y) <span class="comment">#将变量x和y的值对调，不需要像C语言那样借助临时变量实现。等号右边会先进行封装，变成元组(y,x)，然后元组被解包并依次赋值给x和y</span></span><br><span class="line"></span><br><span class="line">d=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> d.items():</span><br><span class="line">   print(<span class="string">&#x27;键:&#123;&#125;, 值:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(k,v))</span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">键:a, 值:1</span></span><br><span class="line"><span class="string">键:b, 值:2</span></span><br><span class="line"><span class="string">键:c, 值:3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>可以在变量赋值操作中对等号右边的可迭代对象直接使用星号<code>*</code>进行拆解或者说解包：<br>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="string">&#x27;dy&#x27;</span>,<span class="number">88</span>,<span class="literal">True</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v=<span class="number">1</span>,<span class="number">2</span>,*a,<span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;dy&#x27;</span>, <span class="number">88</span>, <span class="literal">True</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>如果不想对右边的对象进行显式拆解，还可以在左边对将要接收的变量裹上一层或多层<code>()</code>或<code>[]</code>，以实现“多级嵌套解包”：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="string">&#x27;dy&#x27;</span>,<span class="number">88</span>,<span class="literal">True</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>*_,(x,y,z),_=<span class="number">1</span>,<span class="number">2</span>,a,<span class="number">3</span> <span class="comment">#写成*_,(x,y,z),*_=1,2,a,3是错误的，在同一级不能出现两个及以上的星号，什么意思？譬如写成*_,(x,*y),_=1,2,a,3则是正确的，这两个*不在同一级</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x,y,z</span><br><span class="line">(<span class="string">&#x27;dy&#x27;</span>, <span class="number">88</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_,(a,(b,c),d),_=<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>],<span class="number">5</span>],<span class="number">6</span> <span class="comment">#总之两边结构保持一致即可</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b,c</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>简单来说，星号出现在赋值号左边表示装包，出现在赋值号右边表示解包，不管是哪种，星号修饰符都必须位于一个序列中，可能不太好理解，看个例子即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>*x=a <span class="comment">#报错</span></span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">SyntaxError: starred assignment target must be <span class="keyword">in</span> a <span class="built_in">list</span> <span class="keyword">or</span> <span class="built_in">tuple</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>*x,=a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(*x,)=a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[*x]=a <span class="comment">#这三种改法都是正确的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x=*a <span class="comment">#报错</span></span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">SyntaxError: can<span class="string">&#x27;t use starred expression here</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; x=*a,</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; x=(*a,)</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; x=[*a] #这三种改法都是正确的</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>函数传参<br>
<ul>
<li>装包传递（分两种，一是位置参数将被装包为一个元组，二是关键字参数将被装包为一个字典）：<br>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">*t</span>):</span></span><br><span class="line">    print(t)</span><br><span class="line"></span><br><span class="line">f1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment">#(1, 2, 3, 4, 5)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">**d</span>):</span></span><br><span class="line">    print(d)</span><br><span class="line">    </span><br><span class="line">f2(X=<span class="string">&#x27;a&#x27;</span>,Y=<span class="string">&#x27;b&#x27;</span>,Z=<span class="string">&#x27;c&#x27;</span>) <span class="comment">#&#123;&#x27;X&#x27;: &#x27;a&#x27;, &#x27;Y&#x27;: &#x27;b&#x27;, &#x27;Z&#x27;: &#x27;c&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>解包传递（也分为两种情况，一是元组解包传递给位置参数，二是字典解包传递给关键字参数）：<br>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span>(<span class="params">x,y,z</span>):</span></span><br><span class="line">    print(x,y,z)</span><br><span class="line"></span><br><span class="line">t=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">f3(*t) <span class="comment">#等同于执行：f3(1,2,3)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f4</span>(<span class="params">a,b=<span class="number">22</span>,c=<span class="number">33</span></span>):</span></span><br><span class="line">    print(a,b,c)</span><br><span class="line"></span><br><span class="line">d=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line">f4(**d) <span class="comment">#等同于执行：f4(a=1,c=3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#特别地，如果调用f1(*t)或者f2(**d)，将同时完成解包和装包传递</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>简化容器添加<br>
<ul>
<li>当容器为<code>list</code>、<code>tuple</code>（虽然元组是不可变类型，但是没关系，能解包就行，这也并不涉及元组值的改变）、<code>set</code>类型时，同变量赋值操作中等号右边可迭代对象的拆解，使用单星号进行解包：<br>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(*a,<span class="number">4</span>,<span class="number">5</span>) <span class="comment">#创建一个全新的元组</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;*a,<span class="number">4</span>,<span class="number">5</span>&#125; <span class="comment">#集合</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>当容器对字典时，使用的是双星号<code>**</code>进行解包：<br>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=&#123;<span class="string">&#x27;1&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;2&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;3&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;**d,<span class="string">&#x27;4&#x27;</span>:<span class="number">4</span>,<span class="string">&#x27;5&#x27;</span>:<span class="number">5</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<p>但是需要注意的是，这虽然比通过<code>dict.update()</code>扩充字典的形式要简单一点，但须知，<code>dict.update(another_dict)</code>可以明确更新项目，而<code>**</code>字典解包则无法确保，譬如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;**d,<span class="string">&#x27;c&#x27;</span>:<span class="number">33</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">33</span>&#125; <span class="comment">#&#x27;c&#x27;键值更新了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;c&#x27;</span>:<span class="number">33</span>,**d&#125;</span><br><span class="line">&#123;<span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125; <span class="comment">#&#x27;c&#x27;键值没有更新</span></span><br></pre></td></tr></table></figure>
<p>另外就是效率问题，用<code>*</code>和<code>**</code>简化容器的添加操作，其性能和容器对象的<code>update()</code>,<code>append()</code>或<code>add()</code>方法相比，谁更优？根据下面的测试，解包比<code>append()</code>方法慢了3倍：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line">t1=timeit.Timer(<span class="string">&#x27;a.append(100)&#x27;</span>,<span class="string">&#x27;a=list(range(100))&#x27;</span>)</span><br><span class="line">print(t1.repeat()) <span class="comment">#[0.0850489117379404, 0.09039714449200119, 0.08290944329400407]</span></span><br><span class="line"></span><br><span class="line">t2=timeit.Timer(<span class="string">&#x27;b=[*a,100]&#x27;</span>,<span class="string">&#x27;a=list(range(100))&#x27;</span>)</span><br><span class="line">print(t2.repeat()) <span class="comment">#[0.2924700997522413, 0.2945020249114667, 0.2961987540175306]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol></div></div>
   </li>
   <li><code>s.insert(i,x)</code><br></li>
   </ul>
  </li>
<li> 删除<br>
   <ul><li> <code>s.pop([i])</code><br>
     注：函数定义或签名中的<code>[]</code>表示可选参数
   </li>
   <li> <code>s.remove(x)</code></li>
   <li> <code>del s[i]</code>、<code>del s[i:j]</code>、<code>del s[i:j:stride]</code><br>
     注：这是可变序列的通用操作
   </li></ul>
  </li>
<li> 查找<br>
   <ul><li> <code>s.index(x,[,start[,stop]])</code><br>
     注：返回满足<code>s[start:stop][i]==x</code>的最小<code>i</code>值，如果找不到，会抛出异常</li>
   <li> <code>s[i]</code>、<code>s[i:j]</code>、<code>s[i:j:stride]</code><br>
     注：这是序列的通用操作。<code>i:j</code>其实是一个特殊的切片对象<code>slice(i,j,None)</code>，且<code>i</code>、<code>j</code>、<code>stride</code>都是任意可省的，如<code>s[::]</code>
   </li></ul>
</li>
<li> 修改<br>
   <ul>
   <li><code>s.reverse()</code><br>
     注：这是原址操作，可以通过切片实现<code>s[::-1]</code>（返回一个新对象，上面说过，属于浅复制）
   </li>
   <li><code>s.sort([key[,reverse]])</code><br>
     <div class="hide-toggle" ><div class="hide-button toggle-title " style=""><i class="fas fa-caret-right fa-fw"></i><span><code>sort()</code>方法</span></div>
    <div class="hide-content"><div class="note blue icon disabled"><i class="note-icon fas fa-lightbulb"></i><p>
基本形式：<code>sorted(iterable[,cmp[,key[,reverse]]])</code>（副本排序）、<code>
              iterable.sort(cmp[,key[,reverse]])</code>（原址排序）
<p>参数：<code>iterable</code>为可迭代对象，<code>cmp</code>指定排序时进行比较的函数，<code>key</code>也是函数，指定待排序元素将要参与排序的特征，<code>reverse</code>实现降序，默认<code>False</code>为升序<br>
注：python3去掉了<code>cmp</code>参数</p>
</p></div>
<p>简单示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.原址排序（对原始的序列对象进行内部排序而不是返回一个新的已排的序列对象）</span></span><br><span class="line">n=[<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">n.sort()</span><br><span class="line">print(n) <span class="comment">#[1, 2, 3, 4, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.副本排序</span></span><br><span class="line"><span class="comment">#两种：创建原始对象的一个副本，然后对副本做原址排序，或者使用sorted方法，其将返回一个类型为列表的副本</span></span><br><span class="line">x=[<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">y=x[:] <span class="comment">#对于列表对象来说，创建副本的方式有很多：切片、工厂函数、copy.copy（前三种是浅拷贝）、copy.deepcopy</span></span><br><span class="line">y.sort()</span><br><span class="line">print(x,y) <span class="comment">#x未排序，y已排序</span></span><br><span class="line"></span><br><span class="line">m=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">print(<span class="built_in">sorted</span>(m))</span><br><span class="line">print(m) <span class="comment">#sorted()不改变原始对象</span></span><br></pre></td></tr></table></figure>
<p>高级用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.自定义比较函数cmp(x,y)</span></span><br><span class="line"><span class="comment">#既然python3不支持，就不说了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.自定义待排序元素特征keys（接受一个参数，表示待排序的元素对象）</span></span><br><span class="line"><span class="comment">#之所以在key后面加上s，是因为特征可以有多个，首先按照第一个特征对元素排序，然后在此基础之上，再用第二个特征排序，第一个特征优先级最高。此即为多级排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keys</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(x)</span><br><span class="line"></span><br><span class="line">array=[<span class="string">&#x27;daiyang&#x27;</span>,<span class="string">&#x27;sb&#x27;</span>,<span class="string">&#x27;miaosiyu&#x27;</span>,<span class="string">&#x27;jianglicheng&#x27;</span>,<span class="string">&#x27;liuhan&#x27;</span>] <span class="comment">#按照字符串的长度进行排序（降）</span></span><br><span class="line">print(<span class="built_in">sorted</span>(array,key=keys,reverse=<span class="literal">True</span>)) <span class="comment">#由于取消了cmp比较函数，因此只能通过reverse设定升降顺序</span></span><br><span class="line">array.sort(key=<span class="keyword">lambda</span> x:<span class="built_in">len</span>(x),reverse=<span class="literal">True</span>)</span><br><span class="line">print(array) <span class="comment">#[&#x27;jianglicheng&#x27;, &#x27;miaosiyu&#x27;, &#x27;daiyang&#x27;, &#x27;liuhan&#x27;, &#x27;sb&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.多级排序</span></span><br><span class="line">arrays_1=[(<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>),(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>),(<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>),(<span class="number">2</span>,<span class="number">4</span>,<span class="number">10</span>)]</span><br><span class="line">arrays_2=[(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;10&#x27;</span>),(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>),(<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>),(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;10&#x27;</span>),(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;10&#x27;</span>)]</span><br><span class="line">arrays_1.sort(key=<span class="keyword">lambda</span> x:(x[<span class="number">2</span>],x[<span class="number">1</span>])) <span class="comment">#例1 #[(1, 2, 3), (5, 6, 7), (2, 3, 10), (2, 4, 10), (2, 5, 10)]</span></span><br><span class="line">print(arrays_1)</span><br><span class="line">print(<span class="built_in">sorted</span>(arrays_2,key=<span class="keyword">lambda</span> x:<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,(x[<span class="number">2</span>],x[<span class="number">1</span>]))))) <span class="comment">#例2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将operator.itemgetter函数用在多级排序中</span></span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="comment">#itemgetter函数用于选择对象的指定维数的数据，注意itemgetter返回的是一个函数对象</span></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">gets=itemgetter(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">#获取“对象[1]”和“对象[2]”，这个对象是广义化的，由你任意指定，如下：</span></span><br><span class="line">ret=gets(a) <span class="comment">#返回一个元组：(a[1],a[2])</span></span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果同例2:</span></span><br><span class="line">print(<span class="built_in">sorted</span>(arrays_2,key=<span class="keyword">lambda</span> x:<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,itemgetter(<span class="number">2</span>,<span class="number">1</span>)(x)))))</span><br><span class="line"><span class="comment">#结果同例1:</span></span><br><span class="line">print(<span class="built_in">sorted</span>(arrays_1,key=itemgetter(<span class="number">2</span>,<span class="number">1</span>)))</span><br></pre></td></tr></table></figure>
<p>注，获取排序后的索引序列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">argsort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [i <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">sorted</span>(<span class="built_in">enumerate</span>(arr),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])]</span><br><span class="line">    </span><br><span class="line">a=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">inds=argsort(a)</span><br><span class="line">print(<span class="string">f&#x27;sorted-index:<span class="subst">&#123;inds&#125;</span>&#x27;</span>) <span class="comment">#sorted-index:[6, 0, 2, 5, 1, 4, 3]</span></span><br><span class="line">print(<span class="string">f&#x27;sorted-value:<span class="subst">&#123;[a[ind] <span class="keyword">for</span> ind <span class="keyword">in</span> inds]&#125;</span>&#x27;</span>) <span class="comment">#sorted-value:[0, 1, 2, 2, 3, 4, 9]</span></span><br></pre></td></tr></table></figure>
</div></div>
   </li>
   </ul>
</li>
</ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dytab1-1-3"><p>类似于列表，只不过元组一旦创建不能修改，比列表要省内存</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dytab1-1-4"><p>首先新建一个链表类（目前就是一个普通的容器，可以存储数据，但是尚未实现<code>__iter__</code>方法，因此还不是可迭代对象），实现了链表的基本操作，索引、追加、插入、删除：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">__all__=[<span class="string">&#x27;Link&#x27;</span>,]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,val</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;节点对象，有数据域和指针域（指向下一元素）&#x27;&#x27;&#x27;</span></span><br><span class="line">        self.data=val</span><br><span class="line">        self.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;初始化链表，初始化一个头节点，其数据域默认为空，可以添加链表长度等信息&#x27;&#x27;&#x27;</span></span><br><span class="line">        head=Node(<span class="number">0</span>)</span><br><span class="line">        self.pointer=head <span class="comment">#语义：链表指针，指向头节点</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self,val</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;在链表尾部追加新元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        node=Node(val)</span><br><span class="line">        p=self.pointer    <span class="comment">#语义：工作指针</span></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:     <span class="comment">#获取指向最后一个元素的指针</span></span><br><span class="line">            p=p.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span>=node       <span class="comment">#看起来next“指针域”指向了node，因为next中保存的是对node的引用，而不是node的拷贝，这和C中的指针效果是一样的</span></span><br><span class="line">        self.pointer.data+=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printf</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;打印链表中元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        print(<span class="string">&#x27;[链表] &#x27;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        p=self.pointer</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            print(p.<span class="built_in">next</span>.data,end=<span class="string">&#x27;, &#x27;</span>)</span><br><span class="line">            p=p.<span class="built_in">next</span></span><br><span class="line">        print()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self,index,get=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;删除链表中第index个元素，get参数用于get()函数代码复用，这个参数应该隐藏（譬如作为类属性）而不该放在函数定义中&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> index&lt;<span class="number">1</span> <span class="keyword">or</span> index&gt;self.<span class="built_in">len</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;下标溢出&#x27;</span>)</span><br><span class="line">        p=self.pointer</span><br><span class="line">        i=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> i==index:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> get:</span><br><span class="line">                    p.<span class="built_in">next</span>=p.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="comment">#断开的节点无需手动free，因为python有垃圾回收机制</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> p.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            p=p.<span class="built_in">next</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        self.pointer.data-=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteall</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;删除全部元素，即头节点指针域指空&#x27;&#x27;&#x27;</span></span><br><span class="line">        p=self.pointer</span><br><span class="line">        p.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line">        self.pointer.data=<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,index</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;获取第index个节点元素，index取值1~len(Link)&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self.delete(index,<span class="literal">True</span>).data</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">len</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;链表长度，之前我们说头节点有空闲的数据域，我们可以存储链表长度信息，通过实时更新其值，可以避免硬计算&#x27;&#x27;&#x27;</span></span><br><span class="line">        p=self.pointer</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            p=p.<span class="built_in">next</span></span><br><span class="line">            i+=<span class="number">1</span> <span class="comment"># 硬计算</span></span><br><span class="line">        <span class="keyword">if</span> self.pointer.data!=i: <span class="comment">#为了避免错误，暂时我仍使用硬计算，并对头节点的数据域中的长度值进行检测</span></span><br><span class="line">            print(<span class="string">&#x27;头节点错误&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self,index,val</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;插入元素，index合法取值1到len(Link)+1，特别地，当index取值len(Link)+1时，为在尾部追加（特殊插入）&#x27;&#x27;&#x27;</span></span><br><span class="line">        node=Node(val)</span><br><span class="line">        <span class="keyword">if</span> index&lt;<span class="number">1</span> <span class="keyword">or</span> index&gt;self.<span class="built_in">len</span>+<span class="number">1</span>:</span><br><span class="line">            print(<span class="string">&#x27;下标溢出&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> index==self.<span class="built_in">len</span>+<span class="number">1</span>:</span><br><span class="line">            self.append(node)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        p=self.pointer</span><br><span class="line">        i=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> i==index:</span><br><span class="line">                t=p.<span class="built_in">next</span></span><br><span class="line">                p.<span class="built_in">next</span>=node</span><br><span class="line">                node.<span class="built_in">next</span>=t</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            p=p.<span class="built_in">next</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        self.pointer.data+=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    L=Link() <span class="comment">#空链表</span></span><br><span class="line">    L.append(<span class="number">1</span>)</span><br><span class="line">    L.append(<span class="number">2</span>)</span><br><span class="line">    L.append(<span class="number">3</span>)</span><br><span class="line">    L.insert(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">    L.printf()</span><br><span class="line">    L.delete(<span class="number">1</span>)</span><br><span class="line">    L.printf()</span><br><span class="line">    L.deleteall()</span><br><span class="line">    L.append(<span class="string">&#x27;muggle&#x27;</span>)</span><br><span class="line">    L.append(<span class="string">&#x27;daiyang&#x27;</span>)</span><br><span class="line">    L.printf()</span><br><span class="line">    print(L.get(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>凡是可迭代对象都可以用<code>for</code>语句逐一遍历全部元素，这是检查一个对象是否可迭代的标准，要创建一个可迭代对象，必须实现<code>__iter__()</code>方法，其返回一个迭代器，迭代器内部持有一个状态，用于记录当前迭代所在的位置，迭代器必须实现<code>__next__()</code>用于迭代获取下一个元素并更新迭代状态，而迭代器也属于可迭代对象的范畴，因此也必须实现<code>__iter__()</code>方法，具体实现时返回自身即可</p>
<p>下面我们试着将上述不可迭代的链表对象（Link）转变为可迭代的列表对象（List），并在链表的基础上构建一个迭代器对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span>(<span class="params">Link</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span> <span class="comment">#实现了__iter__方法之后，链表变成可迭代对象</span></span><br><span class="line">        <span class="keyword">return</span> ListIteration(self)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListIteration</span>:</span> <span class="comment">#简单来说，迭代器就相当于“普通容器+迭代状态”</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,container</span>):</span></span><br><span class="line">        self.data=container <span class="comment">#迭代器由容器数据和状态构成</span></span><br><span class="line">        self.iterstate=<span class="number">1</span> <span class="comment">#迭代器当前的迭代状态</span></span><br><span class="line">        self.stopstate=self.data.<span class="built_in">len</span> <span class="comment">#终止</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span> <span class="comment">#对一个迭代器获取其迭代器，就是其本身</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span> <span class="comment">#根据当前迭代状态迭代下一个元素，并更新状态</span></span><br><span class="line">        <span class="keyword">while</span> self.iterstate&lt;=self.stopstate:</span><br><span class="line">            self.iterstate+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> self.data.get(self.iterstate-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">raise</span> StopIteration <span class="comment">#对超出范围的元素迭代需要返回StopIteration，在for语句中该异常将被捕捉</span></span><br><span class="line">        </span><br><span class="line">a=List() <span class="comment">#创建一个列表（可迭代对象）</span></span><br><span class="line">a.append(<span class="number">10</span>)</span><br><span class="line">a.append(<span class="number">12</span>)</span><br><span class="line">a.append(<span class="number">14</span>)</span><br><span class="line">a.append(<span class="number">16</span>)</span><br><span class="line">b=<span class="built_in">iter</span>(a) <span class="comment">#将自动调用a.__iter__()</span></span><br><span class="line">print(b.__next__()) <span class="comment">#10 #或者写next(b)</span></span><br><span class="line">c=<span class="built_in">iter</span>(b) <span class="comment">#对迭代器调用iter()，返回自身，因此下面的c都可以替换为b</span></span><br><span class="line">print(c.__next__()) <span class="comment">#12</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">    print(i) <span class="comment">#14 16</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i) <span class="comment">#10 12 14 16</span></span><br></pre></td></tr></table></figure>
<div class="hide-toggle" ><div class="hide-button toggle-title " style=""><i class="fas fa-caret-right fa-fw"></i><span><code>for</code>循环原理</span></div>
    <div class="hide-content"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.首先通过iter()获取迭代器对象</span></span><br><span class="line">iterator=<span class="built_in">iter</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment">#2.在循环中不断调用next方法获取迭代器对象的下一个值直至捕捉到StopIteration异常退出循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x=<span class="built_in">next</span>(iterator)</span><br><span class="line">        print(x)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></div></div>
<p><code>itertools</code>模块提供了诸多具有特殊用途的迭代器，譬如<code>count()</code>返回一个无限循环的迭代器（既然无限循环为什么不直接使用<code>while</code>？因为<code>count()</code>可以很方便地记录当前迭代次序），再如<code>cycle()</code>从有限序列生成无限序列，用于循环遍历序列，等等，下面是<code>cycle</code>的实现（我随便写的，非官方实现）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cycle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,container,start=<span class="number">0</span></span>):</span> <span class="comment">#start指定从序列的哪一个元素开始循环迭代</span></span><br><span class="line">        self.data=container</span><br><span class="line">        self.iterstate=start</span><br><span class="line">        self.<span class="built_in">len</span>=<span class="built_in">len</span>(container)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.iterstate+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.data[(self.iterstate-<span class="number">1</span>)%self.<span class="built_in">len</span>]</span><br><span class="line">        </span><br><span class="line">a=cycle([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],) <span class="comment">#不同于上面自定义的列表是一个可迭代对象（但非迭代器对象），此处cycle(...)直接就是迭代器对象，当然也就是可迭代对象。再如python几种内置类型list、tuple、dict、set、str等，也都是可迭代对象，但非迭代器对象（为何这样设计？道理很简单，迭代器对象都是用完即扔的，这实在是太浪费资源了，于是你需要不停在内存中创建和回收对象，但重复将可迭代对象转换为迭代器就很便宜了），譬如a=[1,2,3];next(a)将报错：TypeError: &#x27;list&#x27; object is not an iterator</span></span><br><span class="line">print(<span class="built_in">next</span>(a),<span class="built_in">next</span>(a),<span class="built_in">next</span>(a),<span class="built_in">next</span>(a),<span class="built_in">next</span>(a),<span class="built_in">next</span>(a),<span class="built_in">next</span>(a)) <span class="comment">#1 2 3 1 2 3 1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i) <span class="comment">#无限循环，因为for循环只会在next(迭代器)抛出StopIteration（停止迭代异常）的时候终止</span></span><br></pre></td></tr></table></figure>
<p>判断是否可迭代以及是否是迭代器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> collections</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([],collections.Iterable) <span class="comment">#list是可迭代对象吗？</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([],collections.Iterator) <span class="comment">#list是迭代器对象吗？</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<img src="https://cdn.staticaly.com/gh/celestezj/ImageHosting/master/img/20210429214739.png" alt="图2. 可迭代对象、迭代器、生成器关系[4]" style="width:540px">
<p>再说说生成器，实际上生成器本质就是迭代器（因此生成器也是用完即弃），只要迭代的下一个元素是即时计算（惰性计算）的，那就是生成器，普通迭代器迭代下一个元素，是从某个容器中取出来，所有元素事先已经计算得出，其始终占用着一片内存区域（因此只有生成器才能实现“无限序列”）。在python2中<code>range()</code>就是一个普通迭代器（譬如<code>range(10000)</code>内存中真的就存在10000个数字），<code>xrange()</code>则是生成器（此时内存中就没有10000个数据占用），下面我们自行设计一个生成器版本的<code>range</code>（Range）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Range</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,*args</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(args)==<span class="number">1</span>:</span><br><span class="line">            self.start,self.stop,self.step=<span class="number">0</span>,args[<span class="number">0</span>],<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(args)==<span class="number">2</span>:</span><br><span class="line">            self.start,self.stop,self.step=*args,<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(args)==<span class="number">3</span>:</span><br><span class="line">            self.start,self.stop,self.step=args</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;[参数错误] Range(start[,stop[,step]])&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> self.start&lt;self.stop:</span><br><span class="line">            self.start+=self.step</span><br><span class="line">            <span class="keyword">return</span> self.start-self.step</span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Range(<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>):</span><br><span class="line">    print(i) <span class="comment">#3, 5, 7</span></span><br><span class="line">print(<span class="built_in">list</span>(Range(<span class="number">5</span>))) <span class="comment">#[0, 1, 2, 3, 4]，工厂函数list自动计算生成器各个元素的值并以列表返回</span></span><br></pre></td></tr></table></figure>
<p>通常采用<code>yield</code>关键字构造生成器，在函数中使用<code>yield</code>关键字代替<code>return</code>关键字（称为生成器函数），函数调用将返回一个生成器对象，此时函数内部代码不会立即执行，除非对其调用<code>next()</code>方法，函数执行流将在<code>yield</code>位置中止，并返回<code>yield</code>语句中的表达式值，继续调用<code>next()</code>方法，函数执行流将从<code>yield</code>中止处继起并在下一次遇到<code>yield</code>时中止…，<code>yield</code>使得生成器的语法变得相当优雅（我们几乎从不使用上面Range示例的方式编写生成器，python本身也不认为那是一个生成器对象，如<code>isinstance(Range(5),types.GeneratorType)</code>会返回<code>False</code>），简单来说生成器函数就是在一个循环中不断计算并产生新值的过程且只在需要时计算（“惰性计算”，不调用<code>next()</code>方法则不计算），它定义了数据生产的流程，当我们需要将生产和消耗分离的时候，使用生成器可以方便地解耦，任意函数稍作修改便可转换为生成器函数，只需要将<code>return</code>关键字改成<code>yield</code>关键字，现在我们用<code>yield</code>方式重写Range：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Range</span>(<span class="params">*args</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args)==<span class="number">1</span>:</span><br><span class="line">        start,stop,step=<span class="number">0</span>,args[<span class="number">0</span>],<span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(args)==<span class="number">2</span>:</span><br><span class="line">        start,stop,step=*args,<span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(args)==<span class="number">3</span>:</span><br><span class="line">        start,stop,step=args</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;[参数错误] Range(start[,stop[,step]])&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> start&lt;stop:</span><br><span class="line">        start+=step</span><br><span class="line">        <span class="keyword">yield</span> start-step</span><br><span class="line">    <span class="keyword">raise</span> StopIteration <span class="comment">#生成器其实没必要在结束位置处显式抛出该异常，因为会自动抛，但是（非生成器的）迭代器必须手动抛出</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Range(<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>):</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line">print(<span class="built_in">list</span>(Range(<span class="number">5</span>))) <span class="comment">#[0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<div class="hide-toggle" ><div class="hide-button toggle-title " style=""><i class="fas fa-caret-right fa-fw"></i><span>惰性计算</span></div>
    <div class="hide-content"><p>为了深入了解“惰性计算”，看个<a target="_blank" rel="noopener external nofollow noreferrer" href="https://segmentfault.com/q/1010000016013187">示例</a>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g=(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">10</span>]:</span><br><span class="line">    g=(i+j <span class="keyword">for</span> j <span class="keyword">in</span> g)</span><br><span class="line">print(<span class="built_in">list</span>(g))</span><br></pre></td></tr></table></figure>
<p>不少人（包括我）认为结果会是<code>[11,12,13,14]</code>，但是解释器运行结果却是<code>[20, 21, 22, 23]</code>，why？</p>
<p>对于一个生成器表达式<code>(expression1 for variables in expression2)</code>，<code>expression1</code>只有在调用生成器对象的<code>__next__()</code>方法时才会执行，而<code>for</code>子句则是即时计算的，即<code>expression2</code>是即时计算的（根据<code>for</code>原理<code>expression2</code>应返回一个可迭代对象），另注意，<code>for</code>子句可能是多层<code>for</code>循环嵌套的，只有最左边的<code>for</code>子句才会即时计算，譬如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">range</span>(n)</span><br><span class="line"></span><br><span class="line">g1=(i <span class="keyword">for</span> i <span class="keyword">in</span> bar()) <span class="comment">#for子句表达式是即时计算的，此处等同于：g1=(i for i in range(2))</span></span><br><span class="line">n=<span class="number">3</span></span><br><span class="line">g2=((i,j) <span class="keyword">for</span> i <span class="keyword">in</span> bar() <span class="keyword">for</span> j <span class="keyword">in</span> bar()) <span class="comment">#只有最左侧的for子句表达式才即时计算，此处等同于：g2=((i,j) for i in range(3) for j in bar())</span></span><br><span class="line">n=<span class="number">4</span></span><br><span class="line">print(<span class="built_in">list</span>(g1))</span><br><span class="line">print(<span class="built_in">list</span>(g2)) <span class="comment">#list遍历生成器元素，由于最后修改的n值为4，于是此处等同于：g2=((i,j) for i in range(3) for j in range(4))</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">[0, 1]</span></span><br><span class="line"><span class="string">[(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3)]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果expression2是一个变量引用，将变量引用指向其他对象不会改变生成器数值，如果变量引用指向一个可变对象，修改该可变对象则会改变生成器数值：</span></span><br><span class="line">a=<span class="built_in">range</span>(<span class="number">2</span>)</span><br><span class="line">g=(i <span class="keyword">for</span> i <span class="keyword">in</span> a)</span><br><span class="line">a=<span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line">print(<span class="built_in">list</span>(g)) <span class="comment">#[0, 1]</span></span><br><span class="line"></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">g=(i <span class="keyword">for</span> i <span class="keyword">in</span> a)</span><br><span class="line">a.append(<span class="number">5</span>)</span><br><span class="line">print(<span class="built_in">list</span>(g)) <span class="comment">#[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>回到最初的问题，第一次循环，生成器<code>g</code>中的值其实就是<code>[i+0,i+1,i+2,i+3]</code>（尚未计算），第二次循环，<code>g</code>变成<code>[i+(i+0),i+(i+1),i+(i+2),i+(i+3)]</code>（尚未计算），最后通过<code>list(g)</code>遍历时，<code>i=10</code>，于是输出<code>[20,21,22,23]</code>。将其用生成器函数改写一下同时展开<code>for</code>循环，其执行过程相当于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen1</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen2</span>():</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> gen1():</span><br><span class="line">        <span class="keyword">yield</span> i+j</span><br><span class="line"></span><br><span class="line">i=<span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen3</span>():</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> gen2():</span><br><span class="line">        <span class="keyword">yield</span> i+j</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">list</span>(gen3())) <span class="comment">#[20, 21, 22, 23]</span></span><br></pre></td></tr></table></figure>
<p>这就很明了了，或者再改写一下得到：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">i=<span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen3</span>():</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">yield</span> i+i+k</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">list</span>(gen3())) <span class="comment">#[20, 21, 22, 23]</span></span><br></pre></td></tr></table></figure>
<p>另外如果不是通过<code>list(g)</code>输出生成器序列元素，而是用<code>for</code>循环替换之：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> g:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">20</span></span><br><span class="line"><span class="string">41</span></span><br><span class="line"><span class="string">84</span></span><br><span class="line"><span class="string">171</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#破解之法就是替换for循环变量</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> g:</span><br><span class="line">    print(k)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">20</span></span><br><span class="line"><span class="string">21</span></span><br><span class="line"><span class="string">22</span></span><br><span class="line"><span class="string">23</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>要注意迭代变量的使用，如果使用<code>i</code>作为迭代变量，结果将会发生变化，这仍是惰性计算导致的，结合<code>for</code>循环原理原因就很清楚了（每次循环都会执行<code>i=next(g)</code>，而<code>i</code>将影响生成器序列的数值计算）</p>
</div></div>
<p><code>GeneratorExit</code>异常标志着生成器迭代过程的非正常终止，相反，正常终止不会引发该异常：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">n</span>):</span> <span class="comment">#不断生产数据</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> n</span><br><span class="line">            n-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span> GeneratorExit:</span><br><span class="line">        print(<span class="string">&#x27;exiting...&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">g=f(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> g: <span class="comment">#每产生一个数据就消耗一个数据，如果使用while循环是无法分离生产和消耗两个部分的，它们势必混合在一起</span></span><br><span class="line">    print(i) <span class="comment">#3 2 1</span></span><br></pre></td></tr></table></figure>
<p>如果生成器仅被部分使用，将在<code>yield</code>处引发<code>GeneratorExit</code>异常（但一般不用人为捕获），并自动调用<code>close()</code>方法关闭生成器，如果再次调用<code>next()</code>方法将引发<code>StopIteration</code>异常，它已不能继续产生新值了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g=f(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> g:</span><br><span class="line">    <span class="keyword">if</span> i&gt;<span class="number">1</span>:</span><br><span class="line">        print(i) <span class="comment">#3 2 exiting...</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">g.__next__() <span class="comment">#出现StopIteration异常，不要再期望输出1</span></span><br></pre></td></tr></table></figure>
<p>注：<code>for</code>语句能判断生成器函数是否全部完成，如果你是通过<code>while</code>和<code>next</code>进行迭代是无法判断的（只有在整个程序终止时才会引发该异常），这个时候就需要显式关闭（但这不是必须的），鉴于你通常会忘记，一般我们只使用<code>for</code>循环来迭代生成器</p>
<p>手动执行<code>close()</code>方法亦将在<code>yield</code>处引发<code>GeneratorExit</code>异常（假设生成器已被使用过的话）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g=f(<span class="number">3</span>)</span><br><span class="line">print(g.__next__()) <span class="comment">#3</span></span><br><span class="line">g.close() <span class="comment">#exiting...</span></span><br></pre></td></tr></table></figure>
<p>删除生成器对象也会引发该异常：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g=f(<span class="number">3</span>)</span><br><span class="line">print(g.__next__()) <span class="comment">#3</span></span><br><span class="line"><span class="keyword">del</span> g <span class="comment">#exiting...</span></span><br></pre></td></tr></table></figure>
<p>小结一下：</p>
<ol>
<li>生成器在<code>close()</code>方法后就无法再进行迭代，再调用<code>next()</code>方法就会抛出<code>StopIteration</code>异常</li>
<li>生成器调用<code>close()</code>方法会在<code>yield</code>处抛出<code>GeneratorExit</code>异常，但前提是至少调用一次生成器的<code>next()</code>方法才会产生<code>GeneratorExit</code>异常，如果生成器没有启动则不会抛出异常</li>
<li>生成器内捕捉<code>GeneratorExit</code>异常后，可以继续执行剩余的代码，但剩余的代码中不能再包含<code>yield</code>语句，否则抛出<code>RuntimeError</code>异常</li>
<li><code>GeneratorExit</code>异常不能通过<code>Exception</code>捕捉，因为其直接继承自所有异常的基类<code>BaseException</code></li>
</ol>
<p>上面我们说了为什么内置的类型如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>都被设计为可迭代对象而非迭代器（迭代器是“一次性”的），原因不止一条，譬如<code>in</code>关键字就不能用于迭代器对象，<code>x in y</code>语句的工作原理是，首先调用对象<code>y</code>上的<code>iter()</code>方法，然后不断执行<code>next()</code>方法获取下一个元素，直至<code>x==next(y)</code>，返回<code>True</code>，否则返回<code>False</code>，表示容器<code>y</code>中不存在<code>x</code>，看一个错误范例就明了了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y=(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line">x=<span class="number">1</span></span><br><span class="line">print(x <span class="keyword">in</span> y) <span class="comment">#True</span></span><br><span class="line">print(x <span class="keyword">in</span> y) <span class="comment">#False</span></span><br></pre></td></tr></table></figure>
<p>第一次执行<code>x in y</code>时候，<code>iter(y)</code>返回<code>y</code>自身，执行两次<code>next(y)</code>，生成器<code>y</code>中的前两个元素0和1被消耗（发现<code>x</code>存在于<code>y</code>中），结果返回<code>True</code>，第二次执行<code>x in y</code>的时候，<code>iter(y)</code>仍旧返回被部分消耗的<code>y</code>自身，继续调用<code>next()</code>方法，显然后面的元素2、3、4中不存在1，因此返回<code>False</code>。这种情况下如果要进行存在性判断，可以先将生成器转换为列表（<code>list(y)</code>），一个可迭代对象（而<code>iter(可迭代对象)</code>总是返回一个全新的迭代器对象）</p>
<div class="hide-toggle" ><div class="hide-button toggle-title " style=""><i class="fas fa-caret-right fa-fw"></i><span><code>yield</code>与递归混用</span></div>
    <div class="hide-content"><p>将<code>yield</code>与递归混用时要小心，很容易出错，先来看一个示例，遍历一个嵌套的列表（展平操作）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">lists</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lists:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(i,<span class="built_in">list</span>):</span><br><span class="line">            flatten(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(i)</span><br><span class="line"></span><br><span class="line">a=[<span class="number">0</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]],[<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]]</span><br><span class="line">flatten(a) <span class="comment">#0 1 2 3 4 5 6 7 8 9 10</span></span><br></pre></td></tr></table></figure>
<p>改写为生成器（这个改写是错误的）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">lists</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lists:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(i,<span class="built_in">list</span>):</span><br><span class="line">            flatten(i) <span class="comment">#位置2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> i <span class="comment">#位置1</span></span><br><span class="line">            </span><br><span class="line">a=[<span class="number">0</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]],[<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flatten(a):</span><br><span class="line">    print(i) <span class="comment">#仅仅打印出0</span></span><br></pre></td></tr></table></figure>
<p>这个结果似乎出人意料，分析一下，设<code>g=flatten(a)</code>，<code>for</code>语句第一次调用<code>g</code>的<code>next()</code>方法，由于列表<code>a</code>的第一个元素是数字，因此函数执行流将到达位置1处中止并返回<code>yield</code>表达式值，即0，第二次调用<code>next()</code>方法，执行流从中止处继续，由于列表<code>a</code>的第二个元素是列表，因此到达位置2处，关键即在于此，位置2处的<code>flatten(i)</code>将返回一个生成器，然而生成器是惰性的，在没有调用<code>next()</code>方法的情况下生成器根本不会执行（修正的办法就是手动去迭代这个生成器），更何况返回的生成器对象还没有被赋值，没有外部引用的它随即会被当作垃圾回收，因此完全可以忽略它的存在，即可以将位置2处的语句替换成<code>pass</code>，于是执行流继续向后执行，而列表<code>a</code>中的后面的两个元素仍都是列表对象，因此执行流不会再到达位置1，生成器也不会再生产值，执行流结束将抛出<code>StopIteration</code>异常，分析结束，可知<code>g</code>这个迭代器的长度仅为1。修正：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">lists</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lists:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(i,<span class="built_in">list</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> flatten(i):</span><br><span class="line">                <span class="keyword">yield</span> j</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<p>序列操作三大函数：</p>
<ul>
<li>
<p><code>map(func,seq1[,seq2,...])</code><br>
批量映射函数，<code>map</code>将序列中的元素映射或转换成其他元素，<code>func</code>充当转换器</p>
<ol>
<li>当只有一个序列参数时，<code>map(func,seq)</code>等同于<code>[func(e) for e in seq]</code></li>
<li>当有多个序列参数时，<code>map(func,seq1,seq2,...)</code>等同于<code>[func(*t) for t in [*zip(seq1,seq2,...)]]</code>（这些序列的长度的长度可以不一致，按最短的来，在python2中，当<code>func</code>取<code>None</code>时，<code>map</code>就等同于<code>zip</code>，但python3已不再允许<code>func</code>参数为<code>None</code>）<br>
打个比方，如果将<code>seq1</code>、<code>seq2</code>、… 各自比作飞机的不同的零件提供商，那么<code>map</code>函数就是批量制造飞机的工厂，<code>func</code>就是制造飞机的原理图纸</li>
</ol>
 <div class="hide-toggle" ><div class="hide-button toggle-title " style=""><i class="fas fa-caret-right fa-fw"></i><span><code>zip</code>函数</span></div>
    <div class="hide-content"><p>简单应用：</p>
<ul>
<li>
<p>快速构建字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(<span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">5</span>),<span class="built_in">range</span>(<span class="number">5</span>,<span class="number">10</span>))) <span class="comment">#通过dict类初始化函数或者说工厂函数</span></span><br><span class="line">&#123;<span class="number">0</span>: <span class="number">5</span>, <span class="number">1</span>: <span class="number">6</span>, <span class="number">2</span>: <span class="number">7</span>, <span class="number">3</span>: <span class="number">8</span>, <span class="number">4</span>: <span class="number">9</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">5</span>),<span class="built_in">range</span>(<span class="number">5</span>,<span class="number">10</span>))&#125; <span class="comment">#通过字典生成式</span></span><br><span class="line">&#123;<span class="number">0</span>: <span class="number">5</span>, <span class="number">1</span>: <span class="number">6</span>, <span class="number">2</span>: <span class="number">7</span>, <span class="number">3</span>: <span class="number">8</span>, <span class="number">4</span>: <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>利用<code>zip</code>完成二维矩阵转置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>], [<span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>], [<span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>], [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>]] <span class="comment">#按行描述的矩阵，现将该矩阵按列描述，即为转置的结果</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a: <span class="comment">#原矩阵</span></span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment">#利用列表生成式进行转置</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [[row[col] <span class="keyword">for</span> row <span class="keyword">in</span> a] <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a[<span class="number">0</span>]))]:</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment">#这个生成式正是zip压缩的过程，因此直接用zip很简便：</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(*a): <span class="comment">#*为解包裹函数参数传递</span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将序列按连续k个值分组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#假设是将序列a按连续两个值分组</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#大佬写法1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(*[<span class="built_in">iter</span>(a)]*<span class="number">2</span>): <span class="comment">#操作符优先级为：zip(*([iter(a)]*2))，这里的*是函数参数的解包裹传递方式，就是将一个序列解包为诸多的位置参数传给函数</span></span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#普通写法2</span></span><br><span class="line">b=<span class="built_in">iter</span>(a)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(b,b): <span class="comment">#另注意不能构成长度为2的分组的部分元素（残值）将被丢弃</span></span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">(1, 2)</span></span><br><span class="line"><span class="string">(3, 4)</span></span><br><span class="line"><span class="string">(5, 6)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#正常人写法3</span></span><br><span class="line">myslice=<span class="keyword">lambda</span> a,k:[a[i:i+k] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(a),k)] <span class="comment">#缺点在于假设传入的a万一是一个迭代器（无法计算长度，无len()方法），那就需要转为列表或其它可计算长度的对象类型，相比之下，zip调用next()更鲁棒。这种写法不丢弃“残值”</span></span><br><span class="line">print(myslice(a,<span class="number">2</span>)) <span class="comment">#[[1, 2], [3, 4], [5, 6], [7]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#正常人写法4</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(a[::<span class="number">2</span>],a[<span class="number">1</span>::<span class="number">2</span>]): <span class="comment">#相邻2个元素</span></span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(a[::<span class="number">3</span>],a[<span class="number">1</span>::<span class="number">3</span>],a[<span class="number">2</span>::<span class="number">3</span>]): <span class="comment">#相邻3个元素</span></span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment"># 假设要相邻k个元素，就要进行k次切片，显然很麻烦，改写一下：</span></span><br><span class="line">myzip=<span class="keyword">lambda</span> k:<span class="built_in">zip</span>(*[a[i::k] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> myzip(<span class="number">4</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p>解释：先说一下<code>zip</code>函数的工作原理，函数接收任意数量的可迭代对象参数，第一步利用<code>iter()</code>将参数全部转换为迭代器对象，第二步在一个<code>while</code>循环中，每一轮，依次获取每个迭代器的下一项，然后组装成一个元组，并追加到返回值序列中，当最短的迭代器对象抛出<code>StopIteration</code>异常时，退出<code>while</code>循环。<code>zip</code>原理（看看就好）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myzip</span>(<span class="params">*args</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;the principle of function zip&#x27;&#x27;&#x27;</span></span><br><span class="line">    m=<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">iter</span>,args))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ret=[] <span class="comment">#返回值序列</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            li=[]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(m)):</span><br><span class="line">                li.append(m[i].__next__())</span><br><span class="line">            ret.append(<span class="built_in">tuple</span>(li))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">ret=myzip([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],[<span class="number">13</span>,<span class="number">14</span>])</span><br><span class="line">print(ret) <span class="comment">#[(1, 4, 8, 13), (2, 5, 9, 14)]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;或者：</span></span><br><span class="line"><span class="string">def myzip(*args): #直接根据最短的列表长度确定轮回次数nloop</span></span><br><span class="line"><span class="string">    m=list(map(iter,args))</span></span><br><span class="line"><span class="string">    nloop=min([len(args[i]) for i in range(len(m))])</span></span><br><span class="line"><span class="string">    #ret=[tuple([m[i].__next__() for i in range(len(m))]) for j in range(len(list(m[0])))] #和下面修改的区别在于：list(one iteration)会导致对迭代器（参数）的一遍迭代，结果想再调用next就会立即抛出异常，由此我们可以大概知道工厂函数list的原理：list(iterable obj)，首先将可迭代参数对象转为迭代器，然后迭代(next)整个迭代器得到新的列表对象，其中的元素都是对参数对象中元素的引用</span></span><br><span class="line"><span class="string">    ret=[tuple([m[i].__next__() for i in range(len(m))]) for j in range(nloop)]</span></span><br><span class="line"><span class="string">    return ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>现在回头看写法2就非常明了了，写法1就是换个写法而已，前提是你要知道<code>[obj]*i</code>将返回一个长度为<code>i</code>的序列<code>[obj,obj,...]</code>，其中每一项都是对原始的<code>obj</code>对象的引用（或者说浅复制），如果是按连续k个值分组，那就将<code>zip(*[iter(a)]*2)</code>中的2换成k即可<br>
注：实际上<code>zip()</code>的返回值是一个类似生成器的对象，即用即弃</p>
</li>
<li>
<p>滑动窗口</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slicing</span>(<span class="params">obj,n</span>):</span></span><br><span class="line">    <span class="comment">#obj为可迭代序列，n为窗口大小，每次滑动（步长为1）我们看见的序列内容都不一样，函数返回全部窗口滑动状态下的序列的内容视图</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">zip</span>(*[islice(obj,i,<span class="literal">None</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]) <span class="comment">#注意obj只能是可迭代对象，不能是迭代器，因为islice会消耗迭代器。最简单的还是用obj[i:]替代islice(obj,i,None)，其实我也想不到islice有什么用处，参考：https://stackoverflow.com/questions/41079001/python-3-5-slice-vs-islice-vs-alternatives-efficiency-comparison</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> slicing([<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">1</span>],<span class="number">3</span>):</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">(2, 3, 8)</span></span><br><span class="line"><span class="string">(3, 8, 5)</span></span><br><span class="line"><span class="string">(8, 5, 1)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>反转字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125; <span class="comment">#字典value必须都是不可变对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(<span class="built_in">zip</span>(*<span class="built_in">list</span>(<span class="built_in">zip</span>(*m.items()))[::-<span class="number">1</span>]))</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;c&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</div></div>
</li>
<li>
<p><code>filter(func,seq)</code><br>
序列过滤器，过滤掉不符合条件的元素，返回那些符合条件的元素所组成的新（子）序列，<code>func</code>充当筛选器（应返回<code>True</code>或<code>False</code>）。等同于<code>[e for e in seq if func(e)]</code></p>
</li>
<li>
<p><code>reduce(func,seq[,initial])</code><br>
该函数工作流程是：在迭代<code>seq</code>的过程中，首先将前两个元素传给<code>func</code>函数（可以通过<code>initial</code>参数额外指定首个元素值，相当于序列<code>seq</code>增加了一个元素，新序列为<code>[initial,*seq]</code>），函数加工后将返回值和<code>seq</code>序列的第三个元素重新传入<code>func</code>函数，再将返回值和<code>seq</code>的第四个元素一起传入<code>func</code>函数，以此类推，直至遍历到<code>seq</code>的最后一个元素，最后一次执行的<code>func</code>函数输出将作为<code>reduce</code>函数的返回值<br>
注：python3从全局空间移除了该函数，需要从标准库<code>functools</code>中引入<br>
<code>reduce</code>最大的特点在于，过程中每一次迭代都携带着上一次的迭代结果，这种对历史的可见性有时候很有用。记忆力是个好东西<br>
案例1（计算阶乘）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y:x*y,<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>)) <span class="comment"># 也可以写成：import operator;reduce(operator.mul,range(1,6) #计算5!</span></span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure>
<p>案例2（将整数列表拼成整数）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y:x*<span class="number">10</span>+y,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<div class="hide-toggle" ><div class="hide-button toggle-title " style=""><i class="fas fa-caret-right fa-fw"></i><span>案例3（计算斐波那契）</span></div>
    <div class="hide-content">  <div class="note green icon disabled"><i class="note-icon fas fa-question"></i><p>已知斐波那契数列：1、1、2、3、5、8、13、21、34、……<br>
要求：输出数列第n项的值</p>
</div>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据数列规律：当前项的值等于前两项的和，即在迭代过程中只要保留最近的历史（前两项元素值）即可，因此基调确定，即reduce中的func参数应该返回一个二元组，而参数seq其实对计算没用，仅用于迭代。且实际假设斐波那契序列为（增加首项0）：0,1,1,2,3,5,8,...，然后将前两项(0,1)作为reduce的initial参数，于是reduce首次迭代可以计算出第三项数值（前两项和）为1，并使func返回第二项和第三项的值(1,1)，然后第二次迭代可以计算出第四项数值为2，并使func返回第三项和第四项的值(1,2)，以此类推</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">fib=<span class="keyword">lambda</span> n:<span class="number">1</span> <span class="keyword">if</span> n==<span class="number">1</span> <span class="keyword">else</span> reduce(<span class="keyword">lambda</span> x,y:(x[<span class="number">1</span>],x[<span class="number">0</span>]+x[<span class="number">1</span>]),<span class="built_in">range</span>(n-<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>))[<span class="number">1</span>]</span><br><span class="line">print(fib(<span class="number">10</span>)) <span class="comment">#55</span></span><br></pre></td></tr></table></figure>
  <div class="hide-toggle" ><div class="hide-button toggle-title " style=""><i class="fas fa-caret-right fa-fw"></i><span>其他实现</span></div>
    <div class="hide-content"><p>普通递归：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span>(<span class="params">n=<span class="number">6</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span> <span class="keyword">or</span> n==<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n-<span class="number">2</span>)+Fibonacci(n-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">ret=Fibonacci(<span class="number">10</span>) <span class="comment">#由于递归层数限制，如果n取值过大，会爆栈，所以严格来说，这种写法是错误的，另一个关键问题是递归计算实在是太耗时了，其具有指数级的时间复杂度！试试求取第35数值，已经明显迟钝，如果把上述递归树画出来，其实有大量结点是重复计算，关于速度的改进参见第二章节·装饰器</span></span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>
<p>看看大佬们是怎么写的：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib1</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> n&lt;=<span class="number">2</span> <span class="keyword">and</span> <span class="number">1</span> <span class="keyword">or</span> fib1(n-<span class="number">1</span>)+fib1(n-<span class="number">2</span>) <span class="comment">#秀我一脸</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#等价于：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib2</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n&lt;=<span class="number">2</span> <span class="keyword">else</span> fib2(n-<span class="number">1</span>)+fib2(n-<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#形式再简化：</span></span><br><span class="line">fib3=<span class="keyword">lambda</span> n:<span class="number">1</span> <span class="keyword">if</span> n&lt;=<span class="number">2</span> <span class="keyword">else</span> fib3(n-<span class="number">1</span>)+fib3(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
  <div class="hide-toggle" ><div class="hide-button toggle-title " style=""><i class="fas fa-caret-right fa-fw"></i><span><code>and</code>与<code>or</code></span></div>
    <div class="hide-content"><p><code>and</code>和<code>or</code>执行布尔逻辑运算，但是在python中返回值并非<code>True</code>或<code>False</code>，其返回的是两端的比较值之一</p>
<p>运算规则：</p>
   <ul><li> <code>and</code>运算规则<br>
       <ol><li> 当<code>and</code>左端表达式为真时，继续对右端表达式进行计算并返回该(右端)表达式的值</li>
       <li>当<code>and</code>左端表达式为假时，立即返回该(左端)表达式的值</li></ol>
     </li>
     <li> <code>or</code>运算规则<br>
       <ol><li> 当<code>or</code>左端表达式为假时，继续对右端表达式进行计算并返回该(右端)表达式的值</li>
       <li> 当<code>or</code>左端表达式为真时，立即返回该(左端)表达式的值</li>
       </ol>
     </li>
  </ul>
<p>两规则的第二条体现了<code>and</code>和<code>or</code>的截断作用（其右端表达式可能并没有被计算），因此<code>and</code>和<code>or</code>又被称为“短路运算符”（再次注意只有在<code>and</code>左边为假或者<code>or</code>左边为真才会表现出该特性）</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">0</span> <span class="keyword">and</span> (<span class="number">3</span>-<span class="number">2</span>)) <span class="comment">#0</span></span><br><span class="line">print(<span class="number">1</span> <span class="keyword">or</span> <span class="number">0</span>) <span class="comment">#1</span></span><br></pre></td></tr></table></figure>
<p>简单使用：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#（一）and和or单独使用（多个and或者多个or）</span></span><br><span class="line"><span class="comment">#and：从左到右扫描，返回第一个为假的表达式值，无假值则返回最后一个表达式值。简单说就是：and返回真，除非遇见一个假，则返回假</span></span><br><span class="line">print(-<span class="number">1</span> <span class="keyword">and</span> <span class="string">&#x27;dy&#x27;</span> <span class="keyword">and</span> ...) <span class="comment">#注意负数、字符串都是逻辑为真，而...其实是一个Ellipse对象（该对象没有任何属性，python也没有任何内置类型使用该对象），其逻辑为真</span></span><br><span class="line">print(<span class="literal">True</span> <span class="keyword">if</span> -<span class="number">1</span> <span class="keyword">and</span> <span class="string">&#x27;dy&#x27;</span> <span class="keyword">and</span> ... <span class="keyword">else</span> <span class="literal">False</span>) <span class="comment">#建议使用all([-1,&#x27;dy&#x27;,...])替代</span></span><br><span class="line"><span class="comment">#or：从左到右扫描，返回第一个为真的表达式值，无真值则返回最后一个表达式值。简单说就是：or返回假，除非遇见一个真，则返回真</span></span><br><span class="line">print(<span class="number">0</span> <span class="keyword">or</span> <span class="number">0</span> <span class="keyword">or</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">2</span> <span class="keyword">or</span> <span class="number">0</span>) <span class="comment">#1</span></span><br><span class="line">print(<span class="literal">True</span> <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">or</span> <span class="number">0</span> <span class="keyword">or</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">2</span> <span class="keyword">or</span> <span class="number">0</span> <span class="keyword">else</span> <span class="literal">False</span>) <span class="comment">#建议使用any([0,0,1,2,0])替代</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#（二）and-or搭配使用</span></span><br><span class="line"><span class="comment">#and优先级大于or，结合性从左到右</span></span><br><span class="line"><span class="comment">#经典案例之逻辑表达式(condition and a or b)：</span></span><br><span class="line">a,b=<span class="string">&quot;JAVA&quot;</span>,<span class="string">&quot;PYTHON&quot;</span></span><br><span class="line">print(<span class="number">1</span> <span class="keyword">and</span> a <span class="keyword">or</span> b) <span class="comment">#JAVA</span></span><br><span class="line">print(<span class="number">0</span> <span class="keyword">and</span> a <span class="keyword">or</span> b) <span class="comment">#PYTHON</span></span><br><span class="line"><span class="comment">#我们可以通过控制condition的真假，控制输出a还是输出b。语义即为：“若 真 则返回 a，否则返回 b”，等同于C++中的条件运算符(bool? a:b)，但是必须注意：a和b都必须是逻辑真的</span></span><br><span class="line"></span><br><span class="line">print(<span class="number">1</span> <span class="keyword">and</span> <span class="number">0</span> <span class="keyword">or</span> a <span class="keyword">and</span> b <span class="keyword">and</span> <span class="number">0</span> <span class="keyword">and</span> a <span class="keyword">or</span> b) <span class="comment">#b</span></span><br><span class="line"><span class="comment">#对于一个比较复杂的and-or混合运算，将and视为乘、or视为加：((1 and 0) or (((a and b) and 0) and a)) or b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#由于(condition and a or b)中a和b都要满足逻辑真，这如何确保？先看个反例：</span></span><br><span class="line">a,b=[],<span class="number">1</span> <span class="comment">#a是逻辑假的，此时and-or实现的条件运算将失效</span></span><br><span class="line">print(<span class="literal">True</span> <span class="keyword">and</span> a <span class="keyword">or</span> b) <span class="comment">#1</span></span><br><span class="line">print(<span class="literal">False</span> <span class="keyword">and</span> a <span class="keyword">or</span> b) <span class="comment">#1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#还是有安全的解法的，如下（套个[]强制变成逻辑真，新的逻辑表达式变为(condition and [a] or [b])[0]）：</span></span><br><span class="line">a=<span class="string">&#x27;&#x27;</span></span><br><span class="line">b=<span class="string">&quot;MSY&quot;</span></span><br><span class="line">print((<span class="number">0</span> <span class="keyword">and</span> [a] <span class="keyword">or</span> [b])[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#通常情况下，还是建议if-else实现条件运算符的功能，以增强程序的可读性，装B除外</span></span><br><span class="line">print(<span class="string">&#x27;daiyang&#x27;</span> <span class="keyword">if</span> <span class="literal">False</span> <span class="keyword">else</span> <span class="string">&#x27;daixiaodong&#x27;</span>) <span class="comment">#daixiaodong</span></span><br></pre></td></tr></table></figure>
  <!--对于a and b or c and d，假设a, b, c, d = True, True, False, True，and优先级大于or的情况下，应当返回True，若优先级相同，则应返回False-->
<p><i class="fas fa-hand-point-right"></i>上述小结（可跳过代码）：</p>
  <p class='div-border green'>and-or实现条件运算：<code>(condition and [a] or [b])[0]</code>等同于<code>condition ? a : b</code></p>
  <p class='div-border yellow'><code>all([condition1,condition2,...])</code>等同于<code>True if condition1 and condition2 and ... else False</code></p>
  <p class='div-border blue'>
  <code>any([condition1,condition2,...])</code>等同于<code>True if condition1 or condition2 or ... else False</code></p>
  <br>
  <div class="hide-toggle" ><div class="hide-button toggle-title " style=""><i class="fas fa-caret-right fa-fw"></i><span>全部逻辑运算</span></div>
    <div class="hide-content">  <div class="dytable">
<table>
<thead>
<tr>
<th style="text-align:center">运算</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">逻辑函数表示</th>
<th style="text-align:center">短释</th>
<th style="text-align:center">实现</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A <strong>AND</strong> B</td>
<td style="text-align:center"><small>与门</small></td>
<td style="text-align:center">A·B</td>
<td style="text-align:center"><small>所有输入为高时，才有高的输出，一低出低</small></td>
<td style="text-align:center"><small>A and B</small></td>
</tr>
<tr>
<td style="text-align:center">A <strong>OR</strong> B</td>
<td style="text-align:center"><small>或门</small></td>
<td style="text-align:center">A+B</td>
<td style="text-align:center"><small>所有输入为低时，才有低的输出，一高出高</small></td>
<td style="text-align:center"><small>A or B</small></td>
</tr>
<tr>
<td style="text-align:center"><strong>NOT</strong> A</td>
<td style="text-align:center"><small>非门</small></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8201099999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8201099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.11110999999999999em;"><span class="mord">ˉ</span></span></span></span></span></span></span></span></span></span></td>
<td style="text-align:center"><small>根据输入的高低逆转后输出</small></td>
<td style="text-align:center"><small>not A</small></td>
</tr>
<tr>
<td style="text-align:center">A <strong>NAND</strong> B</td>
<td style="text-align:center"><small>与非门</small></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>A</mi><mo separator="true">⋅</mo><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{A·B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></td>
<td style="text-align:center"><small>所有输入为高时，才有低的输出，一低出高</small></td>
<td style="text-align:center"><small>not (A and B)</small></td>
</tr>
<tr>
<td style="text-align:center">A <strong>NOR</strong> B</td>
<td style="text-align:center"><small>或非门</small></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>A</mi><mo>+</mo><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline {A+B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9666600000000001em;vertical-align:-0.08333em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.08333em;"><span></span></span></span></span></span></span></span></span></td>
<td style="text-align:center"><small>所有输入为低时，才有高的输出，一高出低</small></td>
<td style="text-align:center"><small>not (A or B)</small></td>
</tr>
<tr>
<td style="text-align:center">A <strong>XOR</strong> B</td>
<td style="text-align:center"><small>异或门</small></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊕</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\oplus B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></td>
<td style="text-align:center"><small>输入为一高一低时，才有高的输出，否则出低</small></td>
<td style="text-align:center"><small>(A and not B) or (not A and B)</small></td>
</tr>
<tr>
<td style="text-align:center">A <strong>XNOR</strong> B</td>
<td style="text-align:center"><small>同或门</small></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>A</mi><mo>⊕</mo><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline {A\oplus B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9666600000000001em;vertical-align:-0.08333em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.08333em;"><span></span></span></span></span></span></span></span></span></td>
<td style="text-align:center"><small>输入为一高一低时，才有低的输出，否则出高</small></td>
<td style="text-align:center"><small>(A and B) or (not A and not B)</small></td>
</tr>
<tr>
<td style="text-align:center"><strong>BUF</strong> A</td>
<td style="text-align:center"><small>是门</small></td>
<td style="text-align:center">A</td>
<td style="text-align:center"><small>输出与输入相同的高低状态</small></td>
<td style="text-align:center"><small>A</small></td>
</tr>
<tr>
<td style="text-align:center">A <strong>IMPLY</strong> B</td>
<td style="text-align:center"><small>蕴含门</small></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\rightarrow B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></td>
<td style="text-align:center"><small>第一输入为低时输出高，否则输出同第二输入</small></td>
<td style="text-align:center"><small>(not A) or B</small></td>
</tr>
<tr>
<td style="text-align:center">A <strong>NIMPLY</strong> B</td>
<td style="text-align:center"><small>蕴含非门</small></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline {A\rightarrow B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></td>
<td style="text-align:center"><small>第一输入为低时输出低，否则输出与第二输入相反</small></td>
<td style="text-align:center"><small>A and (not B)</small></td>
</tr>
</tbody>
</table>
  </div>
<p>注1，表中的A、B均为二值型数据，要么是0，要么是1。最后一列是python代码实现，但不仅适用于二值0和1或布尔值<code>True</code>or<code>False</code>，且适用于其他任何自定义对象，只要实现<code>__bool__()</code>方法即可</p>
<p>注2，上表中除了前三个门是基础外，其他门都可以用这三个门实现，譬如：“异或门”<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊕</mo><mi>B</mi><mo>=</mo><mi>A</mi><mo separator="true">⋅</mo><mover accent="true"><mi>B</mi><mo stretchy="true">‾</mo></mover><mo>+</mo><mover accent="true"><mi>A</mi><mo stretchy="true">‾</mo></mover><mo separator="true">⋅</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\oplus B=A·\overline B+\overline A·B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9666600000000001em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>、“同或门”<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>A</mi><mo>⊕</mo><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mi>A</mi><mo separator="true">⋅</mo><mi>B</mi><mo>+</mo><mover accent="true"><mi>A</mi><mo stretchy="true">‾</mo></mover><mo separator="true">⋅</mo><mover accent="true"><mi>B</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline {A\oplus B}=A·B+\overline A·\overline B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9666600000000001em;vertical-align:-0.08333em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.08333em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>、“蕴含门”<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mo>=</mo><mover accent="true"><mi>A</mi><mo stretchy="true">‾</mo></mover><mo>+</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\rightarrow B=\overline A+B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9666600000000001em;vertical-align:-0.08333em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>、“蕴含非门”<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mi>A</mi><mo separator="true">⋅</mo><mover accent="true"><mi>B</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline {A\rightarrow B}=A·\overline B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>。记忆：“与非门”是对“与门”输出取反，“或非门”是对“或门”输出取反，“同或门”是对“异或门”输出取反，“蕴含非门”是对“蕴含门”输出取反</p>
</div></div></div></div>
<p>在某些语言如C中可以使用尾递归解决递归爆栈问题，虽然python本身不支持尾递归，但是存在一些解决方案可以间接实现尾递归，下面我先给出尾递归形式的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib5</span>(<span class="params">n</span>):</span> <span class="comment">#计算原理同下面循环版本的fib4</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib_iter</span>(<span class="params">n,n1,n2</span>):</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>: <span class="keyword">return</span> n2</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> fib_iter(n-<span class="number">1</span>,n2,n1+n2)</span><br><span class="line">    <span class="keyword">return</span> fib_iter(n,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#lambda形式的尾递归</span></span><br><span class="line">fib6=<span class="keyword">lambda</span> n,n1=<span class="number">1</span>,n2=<span class="number">0</span>:n2 <span class="keyword">if</span> n==<span class="number">0</span> <span class="keyword">else</span> fib6(n-<span class="number">1</span>,n2,n1+n2) <span class="comment">#同fib5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#and-or形式的尾递归</span></span><br><span class="line">fib7=<span class="keyword">lambda</span> n,n1=<span class="number">1</span>,n2=<span class="number">0</span>:n==<span class="number">0</span> <span class="keyword">and</span> n2 <span class="keyword">or</span> fib7(n-<span class="number">1</span>,n2,n1+n2) <span class="comment">#同fib6</span></span><br></pre></td></tr></table></figure>
<div class="hide-toggle" ><div class="hide-button toggle-title " style=""><i class="fas fa-caret-right fa-fw"></i><span>python实现尾递归</span></div>
    <div class="hide-content"><p>在计算机中，函数调用是通过“栈”这种数据结构实现的，每调用一个函数，就会往栈中压入一个栈帧对象，其中保存着函数所对应的可执行代码（即代码对象，通常由<code>compile()</code>函数返回，可通过栈帧对象<code>frame</code>的<code>f_code</code>属性访问）、变量命名空间（包含<code>frame.f_locals</code>局部变量、<code>frame.f_globals</code>全局变量和<code>frame.f_builtins</code>内置名称）以及其他一些属性（如<code>frame.f_back</code>，表示对当前调用者而言的上一个栈帧对象），当函数执行结束，就会从栈中删除当前栈帧，如果函数没有结束就又发生了其他函数调用，栈中的帧数就会线性增加，由于栈的大小不是无限的，对于递归函数，如果递归过深，很容易导致栈溢出错误</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrecursionlimit <span class="comment">#python允许的最大递归深度</span></span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>那么旧的栈帧能不能删除呢？一般来说递归调用的返回结果是要为上层函数所使用的，即递归的回溯过程通常不可避免，所以不能删除。尽管如此，由于尾递归的特殊性（尾调用由于是函数执行流的最后一步，调用结果不需要反馈给调用者，因此在这种情况下旧的栈帧可以直接销毁，此即为“尾调用优化”），决定了这种递归形式在执行过程中是不需要回溯的，于是可以把原本需要线性复杂度栈内存空间的执行过程用常数复杂度的空间完成，实现该优化的解释器或编译器可以使得递归本身无论调用多少次，都只占用一个栈帧。本质上尾递归和循环没什么区别，要效率，还是建议循环</p>
<p>大佬实现的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://code.activestate.com/recipes/474088-tail-call-optimization-decorator/"><span class="inline-tag yellow">TCO(Tail-Call Optimization)</span></a>装饰器（原理简单来说就是当发现尾递归调用的函数在栈帧中重复出现时，手动抛出异常并携带着最新调用的函数参数返回上层，从而使之后重复调用的函数栈帧被销毁）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TailRecurseException</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, args, kwargs</span>):</span></span><br><span class="line">        self.args = args</span><br><span class="line">        self.kwargs = kwargs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tail_call_optimized</span>(<span class="params">g</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This function decorates a function with tail call</span></span><br><span class="line"><span class="string">    optimization. It does this by throwing an exception</span></span><br><span class="line"><span class="string">    if it is it&#x27;s own grandparent, and catching such</span></span><br><span class="line"><span class="string">    exceptions to fake the tail call optimization.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This function fails if the decorated</span></span><br><span class="line"><span class="string">    function recurses in a non-tail context.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        f = sys._getframe()</span><br><span class="line">        <span class="keyword">if</span> f.f_back <span class="keyword">and</span> f.f_back.f_back \</span><br><span class="line">            <span class="keyword">and</span> f.f_back.f_back.f_code == f.f_code: <span class="comment">#位置1</span></span><br><span class="line">            <span class="keyword">raise</span> TailRecurseException(args, kwargs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">return</span> g(*args, **kwargs) <span class="comment">#位置2</span></span><br><span class="line">                <span class="keyword">except</span> TailRecurseException <span class="keyword">as</span> e:</span><br><span class="line">                    args = e.args</span><br><span class="line">                    kwargs = e.kwargs</span><br><span class="line">    func.__doc__ = g.__doc__</span><br><span class="line">    <span class="keyword">return</span> func</span><br></pre></td></tr></table></figure>
<p>使用案例（尾递归实现的阶乘计算）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@tail_call_optimized</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n, acc=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="string">&quot;calculate a factorial&quot;</span> <span class="comment">#函数__doc__文档</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> acc</span><br><span class="line">    <span class="keyword">return</span> factorial(n-<span class="number">1</span>, n*acc) <span class="comment">#位置3</span></span><br><span class="line">    </span><br><span class="line">print(factorial(<span class="number">1000</span>))</span><br></pre></td></tr></table></figure>
<p>解读：首先得知道装饰器的基本原理，于是有<code>factorial=tail_call_optimized(factorial)</code>，即变量名<code>factorial</code>实际指向闭包函数<code>func</code>，而<code>func</code>闭包内部的变量<code>g</code>实际指向函数<code>factorial</code>。在执行<code>factorial(1000)</code>时，由函数<code>func</code>构成的栈帧将首次被压入函数调用栈中，程序执行到位置1，不符合<code>if</code>条件，于是执行到位置2，再一次发生函数调用，此时由函数<code>factorial</code>构成的栈帧将被压入栈中，程序继而执行到位置3并函数调用，于是由函数<code>func</code>构成的栈帧将再次被压入栈中，然后执行到位置1发现满足条件（当前栈帧的前两个栈帧存在且上上个栈帧的代码对象和当前栈帧的代码对象相同，即发生重复调用），于是向上层抛出异常（具体返回到哪一层就看哪一层捕捉到了该异常），同时携带着最新的调用参数，显然程序将返回到第一个栈帧（即第一个函数调用）的位置2处（此时栈内就只有这一个帧了），此处异常被捕捉，由于处在一个<code>while</code>循环中，于是又来到位置2并发生函数调用，函数<code>factorial</code>构成的栈帧将被压入栈中，来到位置3并发生函数调用，函数<code>func</code>构成的栈帧将被压入栈中，判断<code>if</code>条件，再次满足条件，抛出异常…，依此类推</p>
<p>之前的斐波那契问题，使用TCO修饰：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib5</span>(<span class="params">n</span>):</span></span><br><span class="line"><span class="meta">    @tail_call_optimized</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib_iter</span>(<span class="params">n,n1,n2</span>):</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>: <span class="keyword">return</span> n2</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> fib_iter(n-<span class="number">1</span>,n2,n1+n2)</span><br><span class="line">    <span class="keyword">return</span> fib_iter(n,<span class="number">1</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>注意，TCO只能用于尾递归，否则出错，示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@tail_call_optimized</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">n=<span class="number">6</span></span>):</span> <span class="comment">#此递归函数功能：每深入调用一次递归函数，计数器增1，即函数返回递归的深度</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+f(n-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">print(f()) <span class="comment">#0 #去掉TCO时返回6</span></span><br></pre></td></tr></table></figure></div></div>
<p>最正确且效率最高的当属循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#能用循环解决的问题，尽量不要使用递归，有时候递归可以极大简化问题，那也应当在合理的递归深度范围内，否则意味着错误必将发生</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib4</span>(<span class="params">n</span>):</span></span><br><span class="line">    n1,n2=<span class="number">1</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        n1,n2,n=n2,n1+n2,n-<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n2</span><br><span class="line">  </span><br><span class="line">print(fib4(<span class="number">10000</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#顺便给出打印完整数列的方法，稍微改造上述fib函数即可</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_fib</span>(<span class="params">n</span>):</span></span><br><span class="line">    n1,n2=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> count():</span><br><span class="line">        <span class="keyword">if</span> i==n:<span class="keyword">break</span></span><br><span class="line">        print(n2,end=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        n1,n2=n2,n1+n2</span><br><span class="line"></span><br><span class="line">all_fib(<span class="number">6</span>) <span class="comment">#1,1,2,3,5,8,13,21,34,55</span></span><br></pre></td></tr></table></figure></div></div></div></div>
<p>案例4（增量求平均）：<br>
记<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{x_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78056em;vertical-align:-0.15em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span>为序列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{x_1, ..., x_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>的均值，由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="true">‾</mo></mover><mo>−</mo><mover accent="true"><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true">‾</mo></mover><mo>=</mo><mfrac><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><mi>n</mi></mfrac><mo>−</mo><mover accent="true"><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true">‾</mo></mover><mo>=</mo><mfrac><mrow><mover accent="true"><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true">‾</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><mi>n</mi></mfrac><mo>−</mo><mover accent="true"><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true">‾</mo></mover><mo>=</mo><mfrac><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>−</mo><mover accent="true"><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true">‾</mo></mover></mrow><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\overline{x_n}-\overline{x_{n-1}} = \frac{x_1+...+x_n}{n} - \overline{x_{n-1}} = \frac{\overline{x_{n-1}}(n-1)+x_n}{n} - \overline{x_{n-1}} = \frac{x_n - \overline{x_{n-1}}}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78056em;vertical-align:-0.15em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.838891em;vertical-align:-0.208331em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1634309999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8184309999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.838891em;vertical-align:-0.208331em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord overline mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6755600000000002em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173142857142857em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.20252142857142857em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.57756em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line mtight" style="border-bottom-width:0.049em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.20252142857142857em;"><span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.838891em;vertical-align:-0.208331em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.269657em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9246570000000001em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.451765em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord overline mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6755600000000002em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173142857142857em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.20252142857142857em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.57756em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line mtight" style="border-bottom-width:0.049em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.20252142857142857em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true">‾</mo></mover><mo>+</mo><mfrac><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>−</mo><mover accent="true"><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true">‾</mo></mover></mrow><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\overline{x_n}=\overline{x_{n-1}} + \frac{x_n - \overline{x_{n-1}}}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78056em;vertical-align:-0.15em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.838891em;vertical-align:-0.208331em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.269657em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9246570000000001em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.451765em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord overline mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6755600000000002em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173142857142857em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.20252142857142857em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.57756em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line mtight" style="border-bottom-width:0.049em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.20252142857142857em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，于是有：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = <span class="keyword">lambda</span> arr : reduce(<span class="keyword">lambda</span> avg_num, xn : (avg_num[<span class="number">0</span>] + (xn - avg_num[<span class="number">0</span>])/(avg_num[<span class="number">1</span>] + <span class="number">1</span>), avg_num[<span class="number">1</span>] + <span class="number">1</span>), arr, (<span class="number">0</span>,<span class="number">0</span>))[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="number">2.5</span></span><br></pre></td></tr></table></figure>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dytab1-4"><div class="tabs" id="dytab1-2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#dytab1-2-1">字典</button></li><li class="tab"><button type="button" data-href="#dytab1-2-2">集合</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="dytab1-2-1"><p>字典又名哈希表、散列表，实现一个哈希表需要讨论两大基本问题：地址映射和冲突处理</p>
<ol>
<li>
<p>地址映射<br>
一个好的<code>hash</code>方法是在对象不相同的情况下能产生不相等的哈希值，这是最理想的情况，退而求次，<code>hash</code>方法应尽力将数据集合中不相同的对象均匀分布到所有可能的地址上面，即通过哈希函数应能得到一个“尽可能随机的地址”</p>
</li>
<li>
<p>冲突处理<br>
如果两个不同对象映射到了相同的地址，将产生冲突，无论怎样精心构造<code>hash</code>函数，这种冲突都不可避免，但是可以解决，如开放定址（探测再散列）、再哈希、链式、公共溢出区，其中链表法是比较常见的冲突处理办法，python采用开放定址办法</p>
</li>
</ol>
<p>因此当我们对字典成员对象进行操作时，需要能够计算对象的哈希并比较对象之间的异同，特别是用户自定义类型，需要用户自己实现。先说说几个特殊方法（也叫“魔法方法”，以双下划线开头且以双下划线结尾，这些方法会在进行特定操作时被自动调用，譬如运算符重载方法，如上面提到过的对象比较<code>==</code>相当于调用对象的<code>__eq__()</code>方法、加法<code>+</code>相当于调用对象的<code>__add__()</code>方法等）：</p>
<ul><li> <code>object.__hash__(self)</code><br>
  <p>注：这是<code>object</code>基类所定义的哈希方法签名，下同</p>
  <p><code>__hash__()</code>会在以下情况被调用：1）由内置方法<code>hash()</code>调用（<code>hash(obj)</code>即等同于<code>obj.__hash__()</code>），2）对散列集合成员进行操作时被调用，散列集合类型包括<code>dict</code>、<code>set</code>和<code>frozenset</code>。注意<code>__hash__()</code>应当返回一个整数，对于用户自定义类型，我们建议将对象的不同组件打包进元组，然后计算元组的哈希值，譬如：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>((self.name, self.sex, self.age))</span><br></pre></td></tr></table></figure>
  </li>
<li> <code>object.__getattribute__(self, name)</code><br>
  <p>实例属性访问时始终会调用<code>__getattribute__()</code>方法（类属性访问则不会调用之，很明显一个道理，<code>__getattribute__()</code>是实例方法嘛，怎么可能会调用它，当类属性不存在时也将触发<code>AttributeError</code>异常，而这就更不太可能触发调用<code>__getattr__()</code>了），如果还定义了<code>__getattr__()</code>，则除非<code>__getattribute__()</code>显式调用它或者其中引发了<code>AttributeError</code>异常（属性不存在的默认行为），否则不会调用后者。为了防止在此方法中陷入无穷递归，其实现应始终调用具有相同名称的基类方法来访问其所需的任何属性，如<code>object.__getattribute__(self, name)</code>（之所以要传入当前实例<code>self</code>，是因为在类上访问实例方法返回的是“非绑定方法”（即原始函数对象），而在实例上访问方法返回的则是“绑定方法”，所谓绑定，即绑定实例，实例方法访问返回的其实是一个闭包对象，譬如<code>x.method</code>返回的相当于<code>partial(method,self=x)</code>），不过一般还是使用<code>super().method(arg)</code>实现基类方法调用。下面的错误示例将导致无限递归（但受最大递归层数限制）：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self,item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__dict__[item] <span class="comment">#__dict__中存放着对象上绑定着的实例属性，若你想从中取值，self.__dict__又将调用self.__getattribute__()方法，从而陷入无穷递归</span></span><br><span class="line">      </span><br><span class="line">print(A(<span class="string">&#x27;a&#x27;</span>).name) <span class="comment">#RecursionError: maximum recursion depth exceeded while calling a Python object</span></span><br></pre></td></tr></table></figure>
  修改：
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self,item</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>(A,self).__getattribute__(item) <span class="comment">#在python3中也可以简写为super()，完全等同于super(A,self)</span></span><br></pre></td></tr></table></figure>
  <div class="hide-toggle" ><div class="hide-button toggle-title " style=""><i class="fas fa-caret-right fa-fw"></i><span>遇到的问题</span></div>
    <div class="hide-content"><p>我写了下面的代码，但是对输出感到困惑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self,item</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;属性访问:&#x27;</span>,item)</span><br><span class="line">        print(<span class="string">&#x27;object的__getattr__方法:&#x27;</span>,<span class="built_in">super</span>(A,self).__getattr__) <span class="comment">#？</span></span><br><span class="line">        print(<span class="built_in">super</span>(A,self).__getattr__(item)) <span class="comment">#super到底发生了什么？</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(A,self).__getattribute__(item)</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self,item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;daiyang&#x27;</span></span><br><span class="line">      </span><br><span class="line">print(A(<span class="string">&#x27;a&#x27;</span>).name)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">属性访问: name</span></span><br><span class="line"><span class="string">daiyang</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>首先我们来看一下<code>super(…)</code>的原理（仅用于理解，因为<code>super</code>本身是一个类）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">super</span>(<span class="params">cls, inst</span>):</span></span><br><span class="line">    mro = inst.__class__.mro()</span><br><span class="line">    <span class="keyword">return</span> mro[mro.index(cls) + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>MRO（method resolution order）列表记录了类继承体系中的成员解析顺序，每个类都有这样的属性，可以用来解决python中<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/czaiz/p/7772194.html">钻石继承</a>的难题，核心就在于它将非线性的父类继承顺序通过C3算法转换成线性顺序。因此以后不要再单纯地认为<code>super()</code>返回的就是当前类的父类了，这不一定（单继承不用怀疑，肯定是父类啦，指的是多继承的情况下不一定），也可能是兄弟类（当然了，不管是“父类”还是“兄弟类”都是不严谨的说法，因为返回的是<code>super</code>类实例），看个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">      print(<span class="string">&quot;enter Base&quot;</span>)</span><br><span class="line">      print(<span class="string">&quot;leave Base&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;enter A&quot;</span>)</span><br><span class="line">        <span class="comment">#print(self.__class__.mro()) #[&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.Base&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span></span><br><span class="line">        <span class="built_in">super</span>(A,self).__init__() <span class="comment">#根据MRO列表可知，super(A,self)返回的是类B，注意了，这也是为什么说super()返回的不一定是父类，此处返回的是类A的兄弟B</span></span><br><span class="line">        print(<span class="string">&quot;leave A&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;enter B&quot;</span>)</span><br><span class="line">        <span class="comment">#print(self.__class__.mro()) #[&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.Base&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span></span><br><span class="line">        <span class="built_in">super</span>(B,self).__init__() <span class="comment">#根据MRO列表可知，super(B,self)返回的是类Base</span></span><br><span class="line">        print(<span class="string">&quot;leave B&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A,B</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;enter C&quot;</span>)</span><br><span class="line">        <span class="comment">#print(self.__class__.mro()) #[&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.Base&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span></span><br><span class="line">        <span class="built_in">super</span>(C,self).__init__() <span class="comment">#根据MRO列表可知，super(C,self)返回的是类A，准确来说返回的是绑定了self实例的super类对象（bound super object），可以通过__self__属性查看绑定的实例，super(C,self).__self__</span></span><br><span class="line">        print(<span class="string">&quot;leave C&quot;</span>)</span><br><span class="line"></span><br><span class="line">c=C()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">enter C</span></span><br><span class="line"><span class="string">enter A</span></span><br><span class="line"><span class="string">enter B</span></span><br><span class="line"><span class="string">enter Base</span></span><br><span class="line"><span class="string">leave Base</span></span><br><span class="line"><span class="string">leave B</span></span><br><span class="line"><span class="string">leave A</span></span><br><span class="line"><span class="string">leave C</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>事实上，<code>super(cls,inst)</code>有两种用法，一是上述所说，参数1是类，参数2是实例，且必须满足<code>isinstance(inst,cls)</code>为<code>True</code>的条件，二是参数2也可以是一个类，此时则必须满足<code>issubclass(inst,cls)</code>为<code>True</code>的条件，两者返回的都是绑定了<code>inst</code>（应该是绑在<code>__self__</code>属性中）的<code>super</code>对象，注意并不是预期的父类哦，如果绑定的<code>inst</code>是实例，那么该<code>super</code>对象可以调用父类的实例方法，如果绑定的<code>inst</code>是类，那么该<code>super</code>对象则可以调用父类的类方法，当然也可以访问父类的其他类属性（包括类中定义的静态方法、非方法属性），如果父类中找不到的话，则会到父类的基类中继续搜寻，如果一直没有找到将抛出<code>AttributeError</code></p>
<p>回到原题，<code>super(A,self).__getattr__</code>理论上应该返回基类<code>object</code>相应的绑定方法（绑定了类<code>A</code>实例<code>self</code>），问题在于<code>object</code>类并未定义<code>__getattr__()</code>方法啊（参考书[1]出来挨打O(∩_∩)O），当访问一个不存在的属性将引发<code>AttributeError</code>异常，注意这个异常是在类<code>A</code>的<code>__getattribute__()</code>内部引发的，而由于还定义了<code>__getattr__()</code>，因此程序最终输出了字符串<code>daiyang</code>。我们可以捕捉该异常：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self,item</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;属性访问:&#x27;</span>,item)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(<span class="string">&#x27;object的__getattr__方法:&#x27;</span>,<span class="built_in">super</span>(A,self).__getattr__)</span><br><span class="line">        <span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">&#x27;异常捕捉:&#x27;</span>,e)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(A,self).__getattribute__(item)</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self,item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;daiyang&#x27;</span></span><br><span class="line">      </span><br><span class="line">print(A(<span class="string">&#x27;a&#x27;</span>).name)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">属性访问: name</span></span><br><span class="line"><span class="string">异常捕捉: &#x27;super&#x27; object has no attribute &#x27;__getattr__&#x27;</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div></div>
  </li>
<li> <code>object.__getitem__(self,key)</code><br>
执行<code>self[key]</code>时被调用，对于序列类型，接受的键应该是整数和切片对象，请注意，负索引的特殊解释（如果类希望模拟序列类型）取决于<code>__getitem__()</code>方法，如果key是不合适的类型，则可能引发<code>TypeError</code>，如果是序列的索引集合之外的值，则应引发<code>IndexError</code>，对于映射类型，如果缺少键（不在容器中），则应引发<code>KeyError</code>
</li>
<li><code>object.__setitem__(self,key,value)</code><br>
执行<code>self[key]=value</code>时被调用
</li>
</ul>
<p>一般我们使用内置的标准字典或集合，甚至不需要子类化进行任何定制，即使有其它方面的需求，也有第三方库提供的数据结构供我们使用，譬如<code>defaultdict</code>、<code>OrderedDict</code>。但是自定义成员对象并通过字典等存取时，基本都得重写<code>__hash__()</code>和<code>__eq__()</code>方法，这一点很重要，现假设我们要向集合中存放自定义类对象，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">man</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,sex,age</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.sex=sex</span><br><span class="line">        self.age=age</span><br><span class="line">        </span><br><span class="line">man1=man(<span class="string">&#x27;muggle&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="number">22</span>)</span><br><span class="line">man2=man(<span class="string">&#x27;muggle&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="number">22</span>)</span><br><span class="line"><span class="built_in">hash</span>(man1)==<span class="built_in">hash</span>(man2) <span class="comment">#False</span></span><br></pre></td></tr></table></figure>
<p>如你所见，两个“相同”（只要姓名、性别、年龄都一样，我们就认为两个人是同一人啊）对象的哈希值不一样，将它们存放到字典<code>s=set([man1,man2])</code>中的后果就是，字典<code>s</code>中竟然“有两个一毛一样的人”，这实在是匪夷所思，原因即在于，执行映射类容器相关操作的时候（譬如向字典中添加一个键值对，或查询某键的值），会先后调用键（此处<code>man</code>实例对象就是“键”）对象的<code>__hash__()</code>以及<code>__eq__()</code>，现在我们两个对象<code>man1</code>和<code>man2</code>的哈希值不一样，而且默认的<code>__eq__</code>方法也判断两个对象不相同，尽管哈希值不一样的键也有可能落到同一个“桶”里面，但是现在这两对象也不<code>equal</code>啊，于是这两个对象必然不同且同时存在于集合中，解决的办法就是为<code>man</code>类重写<code>__hash__()</code>和<code>__eq__()</code>（一般修改其中任意一个方法，另一个也要相应修改），它们必须满足以下两大规则：</p>
<ol>
<li>如果两个对象相同，即<code>obj1.equal(obj2)==True</code>，则两个对象的哈希地址映射也必须相同，即<code>hash(obj1)==hash(obj2)</code>（否则对象明明存在于容器中，却找不到）</li>
<li>如果两个对象的哈希地址映射不同，即<code>hash(obj1)!=hash(obj2)</code>，则两个对象必须不相同，即<code>obj1.equal(obj2)==False</code>（否则容器中将存在同一对象的多个“副本”，浪费存储资源）</li>
</ol>
<p>修改后的<code>man</code>类已满足上述规则：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">man</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,sex,age</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.sex=sex</span><br><span class="line">        self.age=age</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span>(<span class="params">self</span>):</span> <span class="comment">#用姓名、性别和年龄判断两个人是否相同，若相同，此时他们的哈希也必然相同，但是相同的哈希也可能对应不同的人，此时就要靠equal方法来判断了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>((self.name, self.sex, self.age))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self,other</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.name==other.name <span class="keyword">and</span> self.sex==other.sex <span class="keyword">and</span> self.age==other.age:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>关于<code>__hash__()</code>和<code>__eq__()</code>，官方文档中有非常明确的指示：</p>
<ol>
<li>
<p>如果重写了<code>__eq__()</code>，必须重写<code>__hash__()</code>，因为两个“相同”对象的哈希地址映射不一定相同，为了确保这一点，必须重写<code>__hash__()</code>加以保证。反之，如果重写了<code>__hash__()</code>，也必须重写<code>__eq__()</code>，因为两个哈希地址相同的对象，如果是相同对象，<code>__eq__()</code>也必须相同，否则不同，若两个对象哈希地址不同，则<code>__eq__()</code>必须不同，否则出错</p>
</li>
<li>
<p>如果只重写了<code>__eq__()</code>，那么该类对象将不能用于映射类容器，因为此时<code>__hash__()</code>将隐式地被赋为<code>None</code>，即此时<code>__hash__</code>方法失效，该类实例将不可哈希。如果想使用父类的<code>__hash__()</code>，需要明确说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    __hash__=A.__hash__</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self,other</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果没有重写<code>__eq__()</code>，又希望使<code>__hash__()</code>失效，应明确赋值为<code>None</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>():</span></span><br><span class="line">    __hash__=<span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">s=<span class="built_in">set</span>()</span><br><span class="line">s.add(A()) <span class="comment">#TypeError: unhashable type: &#x27;A&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果可变对象的类实现了<code>__eq__()</code>，就不必再为之重写<code>__hash__()</code>了，因为即使你重写了一个看似不会抛异常的<code>__hash__()</code>，但是由于对象可变，它总是会出错（可变对象就不能作为字典或集合的“键”）。举个例子，我们子类化列表，重写<code>__eq__()</code>，规定只要新列表的第一个元素相同，那么两个新列表就相同，同时重写<code>__hash__()</code>，使它返回新列表第一个元素的哈希值，这一设定是合理的，并假设新列表的第一个元素我们总是使它是可哈希的，我们创建一个新列表的实例<code>a=['muggle']</code>，设对象<code>a</code>的哈希地址为<code>addr1</code>，将其添加到集合<code>s</code>中，于是<code>s={['muggle'],}</code>，我们修改<code>a</code>的第一个元素值为<code>'jingjing'</code>，结果就是<code>addr1</code>地址上存放的字符串从<code>muggle</code>变成了<code>jingjing</code>，现在新建一个新列表实例<code>b=['jingjing']</code>，设对象<code>b</code>的哈希地址为<code>addr2</code>，且<code>addr1!=addr2</code>，将<code>b</code>也添加到<code>s</code>中，于是<code>s={['jingjing'],['jingjing'],}</code>，可是根据我们的<code>__eq__</code>和<code>__hash__</code>方法，显然有<code>a==b</code>以及<code>hash(a)==hash(b)</code>成立啊，即这两个对象“完全相同”，而不该在集合中重复出现！代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span>(<span class="params"><span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,*args</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">            self.append(i)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self,index,value</span>):</span></span><br><span class="line">        self[index]=value</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(self[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self,other</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self[<span class="number">0</span>]==other[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">a=MyArray(<span class="string">&#x27;muggle&#x27;</span>)</span><br><span class="line">s=<span class="built_in">set</span>()</span><br><span class="line">s.add(a) <span class="comment">#s=&#123;[&#x27;muggle&#x27;]&#125;</span></span><br><span class="line">a[<span class="number">0</span>]=<span class="string">&#x27;jingjing&#x27;</span> <span class="comment">#&#123;[&#x27;jingjing&#x27;]&#125;</span></span><br><span class="line">b=MyArray(<span class="string">&#x27;jingjing&#x27;</span>)</span><br><span class="line">s.add(b) <span class="comment">#&#123;[&#x27;jingjing&#x27;], [&#x27;jingjing&#x27;]&#125;</span></span><br><span class="line"><span class="built_in">hash</span>(a)==<span class="built_in">hash</span>(b) <span class="comment">#True</span></span><br><span class="line">a==b <span class="comment">#True</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用户自定义类默认的<code>__hash__()</code>和<code>__eq__()</code>继承自基类<code>object</code>，它们都是非常严格的，判断两个实例相不相同是根据唯一身份标识<code>id</code>，哈希也是对身份标识进行哈希</p>
</li>
</ol>
<p>字典的使用和一些注意点：</p>
<ol>
<li>
<p>Python2中判断某个<code>key</code>是否存在字典中可使用<code>has_key()</code>方法，另外一种方式是使用<code>in</code>关键字（<code>key in dict</code>），推荐使用后者，因为<code>in</code>的处理速度更快，另一个原因是<code>has_key()</code>这个方法在Python3被移除了</p>
</li>
<li>
<p>获取字典中某个键的值，两种方式：<code>dict[key]</code>或<code>dict.get(key[, default])</code>，前者简便但如果键不存在会导致<code>KeyError</code>异常，为了避免异常不得不先进行键存在性的判断，或者捕捉异常，如果不想手动捕捉异常那就子类化字典并重新定义字典的<code>__missing__()</code>方法以避免异常的抛出，该特殊方法只有在使用<code>dict[key]</code>且<code>key</code>不存在时才会被调用。一般我们使用<code>dict.get()</code>方法，键不存在则返回<code>None</code>（可通过<code>default</code>参数修改该默认值），但并不会修改底层数据，这不同于<code>defaultdict</code>类或<code>dict.setdefault(key,default)</code>，示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDict</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span>(<span class="params">self,key</span>):</span></span><br><span class="line">        <span class="comment">#self[key]=0 #通常都会这么做，修改底层数据，否则就没有意义了，因为还不如直接通过dict.get(key,default)设置缺省值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">d=MyDict()</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="string">&#x27;11422134431&#x27;</span>: <span class="comment">#计数器</span></span><br><span class="line">    d[k]+=<span class="number">1</span></span><br><span class="line">print(d) <span class="comment">#&#123;&#x27;1&#x27;: 4, &#x27;4&#x27;: 3, &#x27;2&#x27;: 2, &#x27;3&#x27;: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#或者：</span></span><br><span class="line">d=<span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="string">&#x27;11422134431&#x27;</span>:</span><br><span class="line">    d[k]=d.get(k,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">print(d) <span class="comment">#&#123;&#x27;1&#x27;: 4, &#x27;4&#x27;: 3, &#x27;2&#x27;: 2, &#x27;3&#x27;: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#或者：</span></span><br><span class="line">d=&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="string">&#x27;11422134431&#x27;</span>:</span><br><span class="line">    d[k]=d.setdefault(k,<span class="number">0</span>)+<span class="number">1</span> <span class="comment">#setdefault(key,default=None)和get(key,default=None)方法用法类似，区别是，如果键不存在于字典中，将会添加键并将值设为默认值，即会直接修改底层数据。如果字典中包含有给定键，则返回键所对应的值，否则返回为键设置的default值</span></span><br><span class="line">print(d) <span class="comment">#&#123;&#x27;1&#x27;: 4, &#x27;4&#x27;: 3, &#x27;2&#x27;: 2, &#x27;3&#x27;: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#或者：</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">d=defaultdict(<span class="built_in">int</span>) <span class="comment">#defaultdict类的初始化函数接受一个工厂函数作为参数，作用是当key不存在时，返回的是工厂函数的默认值，比如list对应[]，str对应的是空字符串，set对应set()，int对应0</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="string">&#x27;11422134431&#x27;</span>:</span><br><span class="line">    d[k]+=<span class="number">1</span></span><br><span class="line">print(d) <span class="comment">#defaultdict(&lt;class &#x27;int&#x27;&gt;, &#123;&#x27;1&#x27;: 4, &#x27;4&#x27;: 3, &#x27;2&#x27;: 2, &#x27;3&#x27;: 2&#125;)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建字典的几种方式：</p>
<ul>
<li>
<p><code>dict()</code>实例化字典对象（默认无参数时创建一个空字典，也可以直接写<code>d={}</code>），可以传递任意数量的关键字参数，或者是一个二元元组列表以及任意数量的关键字参数，再或者是一个字典和任意数量的关键字参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>()</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data=[(<span class="string">&quot;animal&quot;</span>, <span class="string">&quot;bear&quot;</span>),(<span class="string">&quot;animal&quot;</span>, <span class="string">&quot;duck&quot;</span>),(<span class="string">&quot;plant&quot;</span>, <span class="string">&quot;cactus&quot;</span>),(<span class="string">&quot;vehicle&quot;</span>, <span class="string">&quot;speed boat&quot;</span>),(<span class="string">&quot;vehicle&quot;</span>, <span class="string">&quot;school bus&quot;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(data) <span class="comment">#可以传入一个二元元组列表，实际上只要是可迭代的对象且对象元素也是可迭代对象且这些元素长度一律为2的都可以</span></span><br><span class="line">&#123;<span class="string">&#x27;animal&#x27;</span>: <span class="string">&#x27;duck&#x27;</span>, <span class="string">&#x27;plant&#x27;</span>: <span class="string">&#x27;cactus&#x27;</span>, <span class="string">&#x27;vehicle&#x27;</span>: <span class="string">&#x27;school bus&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])) <span class="comment">#使用zip构造二元组序列</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(([<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>],[<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>]),c=<span class="number">3</span>) <span class="comment">#可以传入关键字参数</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(&#123;<span class="number">1</span>:<span class="number">2</span>,<span class="number">3</span>:<span class="number">4</span>&#125;,last=<span class="number">6</span>) <span class="comment">#也可以传入一个字典，实际上只要是mapping类型都可以，python标准mapping就是dict</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">4</span>, <span class="string">&#x27;last&#x27;</span>: <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>dict.fromkeys(seq[,initial])</code>根据序列<code>seq</code>构造字典，列表中的元素将作为键，需另外指定初始值<code>initial</code>，若未指定则值全部为<code>None</code>，<code>fromkeys()</code>完全可以用字典生成式实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=[<span class="string">&#x27;first&#x27;</span>,<span class="string">&#x27;second&#x27;</span>,<span class="string">&#x27;third&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>.fromkeys(d,<span class="number">8</span>)</span><br><span class="line">&#123;<span class="string">&#x27;first&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;second&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;third&#x27;</span>: <span class="number">8</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>字典生成式，现在有两个序列，分别为一一对应的键值序列，将其组装为字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="string">&#x27;first&#x27;</span>,<span class="string">&#x27;second&#x27;</span>,<span class="string">&#x27;third&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=&#123;k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">zip</span>(a,b)&#125; <span class="comment">#for子句中有一个变量解构操作</span></span><br><span class="line">&#123;<span class="string">&#x27;first&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;second&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;third&#x27;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>字典更新</p>
<ul>
<li>
<p><code>d.update(other_d)</code>，用另一个字典<code>other_d</code>更新原字典<code>d</code>，对于原字典中不存在的键值对直接增添，若存在，则更新旧值为新值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=&#123;<span class="string">&#x27;1&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;2&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;3&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.update(&#123;<span class="string">&#x27;1&#x27;</span>:<span class="number">11</span>,<span class="string">&#x27;4&#x27;</span>:<span class="number">4</span>,<span class="string">&#x27;5&#x27;</span>:<span class="number">5</span>&#125;)</span><br><span class="line">&#123;<span class="string">&#x27;1&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>d[key]=value</code>方式用于添加一个新的键值对或者更新某个键的旧值</p>
</li>
</ul>
</li>
<li>
<p>字典元素删除</p>
<ul>
<li>
<p>使用<code>d.pop(key[,default])</code>删除键值对，可以指定默认的返回值，可以避免由于键不存在而导致的<code>KeyError</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">&#x27;e&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">&#x27;e&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>popitem()</code>返回并删除字典中的最后一对键和值（这里没搞懂，最后一对键值是怎么确定的？）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.popitem()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用<code>del</code>执行删除，既可以删除整个字典，也可以删除字典的某个键值对，如果删除的键不存在，则会报错</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> d[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> d</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>字典遍历<br>
<code>d.keys()</code>、<code>d.values()</code>、<code>d.items()</code>，其中<code>items()</code>多用于<code>for</code>循环遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> d.items():</span><br><span class="line">    print(k,v)</span><br></pre></td></tr></table></figure>
<p>事实上，字典本身也是可迭代对象，且迭代字典对象等同于迭代字典的键序列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[k <span class="keyword">for</span> k <span class="keyword">in</span> d]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br></pre></td></tr></table></figure>
</li>
</ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dytab1-2-2"><p>和字典一样，集合虽然可以迭代，但它们都是无序的，不支持切片和index（数值下标）索引（虽然集合不属于“映射类型”，但由于都是基于散列表实现，所以放在一起描述）</p>
<ul><li>创建集合<br>
  <ol><li>创建一个空集合：<br>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>()</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
  <li>使用现有数据初始化一个集合，<code>set(iterable)</code>构造方法接受一个可迭代对象，如列表：<br>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
  </li>
  </ol>
</li>
<li>查询集合<br>
  集合是无序容器，不能通过下标索引元素，只能遍历：
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]):</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure>
<p>使用<code>in</code>或<code>not in</code>检查某一元素是否存在于集合中：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">in</span> <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li>添加元素<br>
  <ol><li><code>add(item)</code>向集合中添加单项元素：<br>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="built_in">set</span>()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="string">&#x27;msy&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="string">&#x27;msy&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>注：鉴于集合的原理（散列表），向集合中添加的元素既是value又是key，因此添加的元素必须是可哈希的，即集合元素必须是不可变类型</p>
  </li>
  <li><code>update(iterable)</code>使用一系列元素（可迭代序列）更新集合（<code>s1.update(s2)</code>等同于“并集”操作<code>s1|=s2</code>）：<br>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=&#123;<span class="number">12</span>,<span class="number">13</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.update([<span class="string">&#x27;muggle&#x27;</span>,<span class="number">101</span>,<span class="string">&#x27;msy&#x27;</span>])</span><br><span class="line">&#123;<span class="string">&#x27;muggle&#x27;</span>, <span class="number">101</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="string">&#x27;msy&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
  </li></ol>
</li>
<li>删除元素<br>
  <ol><li><code>remove(item)</code>从集合中删除元素<code>item</code>，无返回值，如果元素不存在则引发<code>keyError</code>：<br>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=&#123;<span class="string">&#x27;msy&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="string">&#x27;msy&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="string">&#x27;msy&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">&#x27;msy&#x27;</span></span><br></pre></td></tr></table></figure>
  </li>
  <li><code>discard(item)</code>同<code>remove(item)</code>，但是元素不存在时不会引发异常</li>
  <li><code>pop()</code>从集合中随机删除一个元素，由于集合是无序的容器，无法通过下标索引查询元素，因此<code>pop()</code>不接受任何参数（可对比列表的<code>pop()</code>方法），该方法会返回被（某种程度可以认为是“随机”）删除的元素：<br>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="built_in">set</span>()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.update(<span class="string">&#x27;1a2b3c4d&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.pop()</span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.pop()</span><br><span class="line"><span class="string">&#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>
  </li>
  <li><code>clear()</code>删除集合中的全部元素，无返回值</li>
  </ol>
</li>
<li>交并集数学运算（非原址）<br>
  <ol><li><code>s1.intersection(s2)</code>返回集合<code>s1</code>和<code>s2</code>的交集，该操作对应的运算符为<code>s1 & s2</code>：<br>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1=<span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2=<span class="built_in">set</span>([<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.intersection(s2)</span><br><span class="line">&#123;<span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2</span><br><span class="line">&#123;<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
  </li>
  <li><code>s1.union(s2)</code>返回集合<code>s1</code>和<code>s2</code>的并集，该操作对应的运算符为<code>s1 | s2</code>：<br>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1=<span class="built_in">set</span>([<span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2=<span class="built_in">set</span>([<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.union(s2)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
  </li>
  <li><code>s1.difference(s2)</code>返回集合<code>s1</code>和<code>s2</code>的差集（简单来说就是返回集合<code>s1</code>中有的而集合<code>s2</code>中所没有的那些元素），该操作对应的运算符为<code>s1 - s2</code>：<br>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1=<span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2=<span class="built_in">set</span>([<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.difference(s2)</span><br><span class="line">&#123;<span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 - s2</span><br><span class="line">&#123;<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
  </li>
  <li><code>s1.symmetric_difference(s2)</code>返回集合<code>s1</code>和<code>s2</code>的对称差集（简单说就是返回集合<code>s1</code>中有的而集合<code>s2</code>中所没有的，以及集合<code>s2</code>中有的而集合<code>s1</code>中所没有的那些元素，等同于<code>(s1-s2) | (s2-s1)</code>），该操作对应的运算符为<code>s1 ^ s2</code>：<br>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1=<span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2=<span class="built_in">set</span>([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.symmetric_difference(s2)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 ^ s2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>
  </li>
  </ol>
  注1，并集、交集、差集和对称差集的非运算符版本（non-operator，如<code>s1.union(s2)</code>）允许接受任何可迭代对象作为参数，但它们的运算符版本要求操作数必须都是集合类型：
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>([<span class="number">1</span>]).union([<span class="number">2</span>]) <span class="comment">#合法</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>([<span class="number">1</span>]) | [<span class="number">2</span>] <span class="comment">#非法</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> |: <span class="string">&#x27;set&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;list&#x27;</span></span><br></pre></td></tr></table></figure>
<p>注2，我们知道在执行<code>s1-s2</code>的时候，将触发执行<code>s1.difference(s2)</code>，但操作执行完毕后<code>s1</code>的值仍保持不变，属于非原址操作，同样<code>-=</code>运算符也适用于两个集合对象，在计算差集之后会立即更新第一个操作数（即完成两个步骤：<code>t=s1-s2; s1=t</code>），属于原址操作，而它实际上将触发执行<code>s1.difference_update(s2)</code>：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1=<span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2=<span class="built_in">set</span>([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1-s2</span><br><span class="line">&#123;<span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.difference_update(s2) <span class="comment">#s1-=s2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1</span><br><span class="line">&#123;<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<p>其它原址操作：</p>
  <ul><li><code>s1.intersection_update(s2)</code>交集更新操作，对应运算符为<code>s1 &= s2</code></li>
  <li><code>s1.update(s2)</code>并集更新操作，对应运算符为<code>s1 |= s2</code></li>
  <li><code>s1.symmetric_difference_update(s2)</code>对称差集更新操作，对应运算符为<code>s1 ^= s2</code></li>
  </ul>
</li>
<li>父集和子集判断<br>
 <ol>
 <li><code>s1.issubset(s2)</code>判断集合<code>s1</code>是否是集合<code>s2</code>的子集，对应运算符为<code>s1 <= s2</code>：<br>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1=<span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2=<span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.issubset(s2)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &lt;= s2</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
 </li>
 <li><code>s1.issuperset(s2)</code>判断集合<code>s1</code>是否是集合<code>s2</code>的父集，对应运算符为<code>s1 >= s2</code>：<br>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.issuperset(s1)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 &gt;= s1</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
 </li>
 </ol>
注，两个集合只有在这种情况下是相等（<code>s1 == s2</code>，不等关系测试则使用<code>!=</code>）的：集合中的每一个元素同时也是另一个集合中的元素（或者说二者互为子集）。一个集合比另一个集合小（<code>s1 < s2</code>，用于严格意义上的子集测试）：只有在第一个集合是第二个集合的子集，且第二个集合不是第一个的子集时成立。一个集合比另一个集合大（<code>s1 > s2</code>）：只有在第二个集合是第一个集合的子集，且第一个集合不是第二个的子集时成立
</li>
<li>“冰冻”集合<br>
Python提供一个集合的不可变版本<code>frozenset</code>，创建的方式同<code>set</code>，譬如：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fs=<span class="built_in">frozenset</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<p>两者的区别主要在于，<code>set</code>是可变对象，不可哈希，有<code>add()</code>、<code>remove()</code>等方法，<code>frozenset</code>则是不可变的，存在哈希值，因此它可以作为字典的键，也可以作为其它集合的元素，缺点是一旦创建便不能更改，没有<code>add()</code>、<code>remove()</code>等方法，但是和普通集合一样，支持<code>union()</code>、<code>difference()</code>等交并运算以及<code>issubset()</code>等关系运算</p>
<p>普通集合和冰冻集合可以混用，用于交并运算时，第一个操作数的类型还决定了返回值的类型，譬如第一个操作数是<code>frozenset</code>，第二个是<code>set</code>，那么返回值就是<code>frozenset</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">frozenset</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])-<span class="built_in">set</span>([<span class="number">1</span>])</span><br><span class="line"><span class="built_in">frozenset</span>(&#123;<span class="number">2</span>, <span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure>
<p><code>collections</code>模块提供了两个集合类型，<code>Set</code>和<code>MutableSet</code>，后者用于判断是否是可变集合</p>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<br>
<style>
#dy-coffee-donate{
    z-index: 1 !important; /*修复该部件遮挡live2d的问题，懒得改donate.css，姑且就写在这*/
}
</style>
<link rel="stylesheet" href="https://cdn.staticaly.com/gh/celestezj/ImageHosting/v3.6/data/donate/donate.css">
<div id="dy-coffee-donate" style="position:relative;width:317px;height:98px;left:calc(50% - 159px)">
    <a id="donategithub" href="https://github.com/Kaiyuan/sponsor-page" rel="external nofollow noreferrer" target="_blank" title="Github" style="position:absolute"></a>
	<div id="DonateText" class="donatetr3"><span title="请勿轻信，仅作示范使用">Sponsor</span></div>
	<ul id="donateBox" class="donatelist donate-pos-f donatetr3">
		<li id="PayPal"><a href="javascript:void(0)" rel="external nofollow noreferrer" title="暂未开通">PayPal</a></li><!-- target="_blank" -->
        <li id="BTC"></li>
		<li id="AliPay">AliPay</li>
		<li id="DonateWeChat">WeChat</li>
	</ul>
	<div id="QRBox" class="donate-pos-f donate-left-100">
	<div id="DonateMainBox"></div></div>
</div>
<script src="https://cdn.staticaly.com/gh/celestezj/ImageHosting/v3.6/data/donate/donate.js"></script>
<div class="tip fas fa-quote-left"><p>[1] <a href="https://pan.baidu.com/s/17r__wNMxIXTMWhglf3wyuw" rel="external nofollow noreferrer" title="密码：1y2r" target="_blank"><span style="color:red">Python参考手册</span> 第4版 修订版 [美] 大卫·M.比兹利（David M.Beazley）著，谢俊，杨越，高伟 译</a><br>
[2] <a href="https://blog.csdn.net/sunxb10/article/details/81036693" rel="external nofollow noreferrer" target="_blank">Formatted string literals 详解</a><br>
[3] <a href="https://www.zhihu.com/question/38791962" rel="external nofollow noreferrer" target="_blank">知乎 Python的type和object之间是什么关系？</a><br>
[4] <a href="http://python.jobbole.com/86258/" rel="external nofollow noreferrer" target="_blank">可迭代对象和迭代器</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>Python基础 - 类型和对象</h></span></div><div class="post-copyright__type"><span class="post-copyright-info" id="post-copyright-url"><a href="https://muggledy.top/posts/5311/">https://muggledy.top/posts/5311/</a></span><span>&nbsp;&nbsp;</span><span class="cursorpointer" id="post-url-copyer" onclick="copy_post_url()"><i class="fas fa-paste copy-button"></i></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Muggledy</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2021-04-24</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2021-05-01</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener external nofollow noreferrer" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener external nofollow noreferrer" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div><div class="post-copyright__note"><span class="post-copyright-info"><h>转载或借鉴请注明博客来源噢！</h></span></div></div><script>function copy_post_url(){
  event.stopPropagation();
  var post_copyright_url = document.getElementById("post-copyright-url");
  window.getSelection().selectAllChildren(post_copyright_url);
  document.execCommand("Copy");
}</script><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.staticaly.com/gh/celestezj/Mirror1ImageHosting/master/compress/zjandxiong.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-bookmark fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/22901/" title="类是创建新对象类型的机制，当解决一个问题的时候，面向对象会把事物抽象成对象的概念
，就是说这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行
自己的方法，问题得到解决..."><img class="cover" src="https://cdn.staticaly.com/gh/celestezj/Mirror1ImageHosting/master/compress/bingguo.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-01</div><div class="title">Python基础 - 面向对象编程</div></div></a></div><div><a href="/posts/176/" title="介绍python程序结构与控制流，同时为了更好地实现模块化，会将实现指定功能的程
序封装为函数..."><img class="cover" src="https://cdn.staticaly.com/gh/celestezj/Mirror1ImageHosting/master/compress/index0.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-27</div><div class="title">Python基础 - 程序结构与函数编程</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Gitalk</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://cdn.staticaly.com/gh/celestezj/Mirror1ImageHosting/master/compress/blogavatar.webp" onerror="this.onerror=null;this.src='https://cdn.staticaly.com/gh/celestezj/ImageHosting/master/img/20210328224511.gif'" alt="avatar"/><div class="author-info__name">Muggledy</div><div class="author-info__description">孤筏重洋</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/muggledy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/muggledy" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://cdn.staticaly.com/gh/celestezj/Mirror1ImageHosting/master/img/qrcode_web.archive.org.png" rel="external nofollow noreferrer" target="_blank" title="WeChat"><i class="fab fa-weixin"></i></a><a class="social-icon" href="mailto:zgjsycfndy2015@163.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=3101266674&amp;site=qq&amp;menu=yes" rel="external nofollow noreferrer" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><a href="/note/"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></a><div class="announcement_content">本人的更新是极慢的~<!--<br>建议<a href="https://vpnforchina.github.io/" rel="external nofollow noreferrer" target="_blank"><i class="fas fa-external-link-alt"></i>科学上网</a>以正常访问本站数据--><br>Vercel镜像站：<a href="https://vercel.muggledy.top" rel="external nofollow noreferrer" target="_blank">https://vercel.muggledy.top</a></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BA%AB%E4%BB%BD%E4%B8%8E%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">对象的身份与类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">类型的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E4%B8%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">对象的引用与复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">基础数据类型</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/35908/" title="Pytorch入门教程"><img src="https://cdn.staticaly.com/gh/celestezj/Mirror1ImageHosting/master/compress/demoX3.webp" onerror="this.onerror=null;this.src='https://cdn.staticaly.com/gh/celestezj/ImageHosting/master/img/20210328224519.jpg'" alt="Pytorch入门教程"/></a><div class="content"><a class="title" href="/posts/35908/" title="Pytorch入门教程">Pytorch入门教程</a><time datetime="2021-06-08T01:39:12.000Z" title="发表于 2021-06-08 09:39:12">2021-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/22901/" title="Python基础 - 面向对象编程"><img src="https://cdn.staticaly.com/gh/celestezj/Mirror1ImageHosting/master/compress/bingguo.webp" onerror="this.onerror=null;this.src='https://cdn.staticaly.com/gh/celestezj/ImageHosting/master/img/20210328224519.jpg'" alt="Python基础 - 面向对象编程"/></a><div class="content"><a class="title" href="/posts/22901/" title="Python基础 - 面向对象编程">Python基础 - 面向对象编程</a><time datetime="2021-05-01T13:05:41.000Z" title="发表于 2021-05-01 21:05:41">2021-05-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/176/" title="Python基础 - 程序结构与函数编程"><img src="https://cdn.staticaly.com/gh/celestezj/Mirror1ImageHosting/master/compress/index0.webp" onerror="this.onerror=null;this.src='https://cdn.staticaly.com/gh/celestezj/ImageHosting/master/img/20210328224519.jpg'" alt="Python基础 - 程序结构与函数编程"/></a><div class="content"><a class="title" href="/posts/176/" title="Python基础 - 程序结构与函数编程">Python基础 - 程序结构与函数编程</a><time datetime="2021-04-27T03:45:30.000Z" title="发表于 2021-04-27 11:45:30">2021-04-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5311/" title="Python基础 - 类型和对象"><img src="https://cdn.staticaly.com/gh/celestezj/Mirror1ImageHosting/master/compress/zjandxiong.webp" onerror="this.onerror=null;this.src='https://cdn.staticaly.com/gh/celestezj/ImageHosting/master/img/20210328224519.jpg'" alt="Python基础 - 类型和对象"/></a><div class="content"><a class="title" href="/posts/5311/" title="Python基础 - 类型和对象">Python基础 - 类型和对象</a><time datetime="2021-04-24T12:55:45.000Z" title="发表于 2021-04-24 20:55:45">2021-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/65257/" title="Butterfly魔改部分记录"><img src="https://cdn.staticaly.com/gh/celestezj/Mirror1ImageHosting/master/compress/20210328214628.webp" onerror="this.onerror=null;this.src='https://cdn.staticaly.com/gh/celestezj/ImageHosting/master/img/20210328224519.jpg'" alt="Butterfly魔改部分记录"/></a><div class="content"><a class="title" href="/posts/65257/" title="Butterfly魔改部分记录">Butterfly魔改部分记录</a><time datetime="2021-03-25T07:53:40.000Z" title="发表于 2021-03-25 15:53:40">2021-03-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright"><span>&copy;2021 - 2023</span><span class="onespace">&nbsp;</span><svg style="width:1.5em; height:1.5em" aria-hidden="true"><use xlink:href="#icon-butterfly1"></use></svg><span>By Muggledy</span></div><div class="footer_custom_text"><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io/zh-cn/"><img src="https://img.shields.io/badge/Frame-Hexo-blue"/></a>&nbsp;&nbsp;<a target="_blank" rel="noopener external nofollow noreferrer" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-brightgreen"/></a>&nbsp;&nbsp;<a target="_blank" rel="noopener external nofollow noreferrer" href="https://pages.github.com/"><img src="https://img.shields.io/badge/Hosted-Github-red"/></a>&nbsp;&nbsp;<a target="_blank" rel="noopener external nofollow noreferrer" href="https://statically.io/"><img src="https://img.shields.io/badge/CDN-Staticaly-blueviolet"/></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.staticaly.com/gh/muggledy/muggledy.github.io/v1.2/js/utils.js"></script><script src="https://cdn.staticaly.com/gh/muggledy/muggledy.github.io/v6.6/js/main.js"></script><script defer src="https://cdn.staticaly.com/gh/muggledy/muggledy.github.io/v1.2/js/tw_cn.js"></script><script src="https://cdn.staticaly.com/gh/instantpage/instant.page/master/instantpage.min.js" type="module" defer></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://unpkg.com/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script defer src="https://cdn.staticaly.com/gh/muggledy/muggledy.github.io/v6.1/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.2/katex.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.2/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.2/contrib/copy-tex.min.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', '', 'katex-wrap')
  })
})()</script><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://unpkg.com/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      true && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'QydYkVWb5rbaSOLBJyV7cuLA-MdYXbMMI',
      appKey: 'SQj7LQtIxpmqfQoOUT5y0yq4',
      placeholder: '快来评论吧~',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: 'https://qydykvwb.api.lncldglobal.com',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false,
      master: '5f452633ebd48518f8778c240d946335,a483c79213701a5644bec62de88f974d'.split(','),
      friends: '34c64a0cb78287b2ae889cda5d9d2a91,574fbd33aa74a09d671f4608af20fd2b,9d4dec3cf85be4ed9bf2d4d783ade681,eb9916875df884c6da5c71c020719966'.split(',')
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.staticaly.com/gh/celestezj/Valine/master/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.staticaly.com/gh/gitalk/gitalk/master/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '05956758b57064d95a57',
      clientSecret: '3c4ddd74e671e3d79aac8417e708f69ff93b3e28',
      repo: 'muggledy.github.io',
      owner: 'muggledy',
      admin: ['muggledy'],
      id: 'f957a824741ca8a9f7319cbd51d0083d',
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.staticaly.com/gh/gitalk/gitalk/master/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Valine' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const findTrueUrl = (array) => {
    let url = ''
    Promise.all(array.map(item =>
      fetch(item.url).then(resp => resp.json()).then(data => {
        if (data.user.login === 'utterances-bot') {
          url = data.body.match(/https?\:\/\/[^\" ]+/ig).slice(-1)
          return url[0]
        } else {
          url = data.body.match(/https?\:\/\/[^\" ]+/i)
          return url[0]
        }
      })
    )).then(res => {
        array = array.map((i,index)=> {
          return {
            ...i,
            url: res[index]
          }
        })

        saveToLocal.set('github-newest-comments', JSON.stringify(array), 5/(60*24))
        generateHtml(array)
    });
  }

  const getComment = () => {
    fetch('https://api.github.com/repos/muggledy/muggledy.github.io/issues/comments?sort=updated&direction=desc&per_page=6&page=1',{
      "headers": {
        Accept: 'application/vnd.github.v3.html+json'
      }
    })
      .then(response => response.json())
      .then(data => {
        const githubArray = data.map(item => {
          return {
            'avatar': item.user.avatar_url,
            'content': changeContent(item.body_html),
            'nick': item.user.login,
            'url': item.issue_url,
            'date': item.updated_at,
            'githubUrl': item.html_url
          }
        })
        findTrueUrl(githubArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确以及网络是否通畅"
      })
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('github-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script src="https://cdn.staticaly.com/gh/muggledy/muggledy.github.io/v1.2/js/t_chart.js"></script><script async src="https://cdn.staticaly.com/gh/celestezj/ImageHosting/v3.7/data/funny_title/funny-title-js.js"></script><script async src="https://cdn.staticaly.com/gh/celestezj/ImageHosting/master/data/font_animal/font_animal.js"></script><script data-pjax src="https://cdn.staticaly.com/gh/muggledy/muggledy.github.io/v1.2/js/cal_rs.js"></script><script async src="https://cdn.staticaly.com/gh/celestezj/ImageHosting/master/data/visitors_map/vis_m.js"></script><script async src="https://at.alicdn.com/t/font_2494703_el3qb7r0dxv.js"></script><script async src="https://cdn.staticaly.com/gh/muggledy/muggledy.github.io/v6.4/js/go_cs.js"></script><script async src="/js/grayscale.js"></script><script src="https://unpkg.com/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://unpkg.com/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#web_bg',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  if (typeof window.ifExe_addHighlightTool != 'undefined'){
      window.ifExe_addHighlightTool = true;
  }
  if (typeof window.ifExe_clickFnOfTagHide != 'undefined'){
      window.ifExe_clickFnOfTagHide = true;
  }
  if (typeof window.ifExe_addTableWrap != 'undefined'){
      window.ifExe_addTableWrap = true;
  }
  if (typeof window.ifExe_addPhotoFigcaption != 'undefined'){
      window.ifExe_addPhotoFigcaption = true;
  }
  if (typeof window.ifExe_jqLoadAndRun_jg != 'undefined'){
      window.ifExe_jqLoadAndRun_jg = true;
  }
  if (typeof window.ifExe_jqLoadAndRun_fb != 'undefined'){
      window.ifExe_jqLoadAndRun_fb = true;
  }
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>function dogo(){
  var urls="/posts/17177/,/posts/65257/,/posts/22901/,/posts/35908/,/posts/176/,/posts/5311/";
  urls=urls.split(",");
  var n;
  while(true){
      n = Math.floor(Math.random()*urls.length);
      if (urls[n]!=getRelativeUrl()){break;}
  }
  pjax.loadUrl(urls[n]);
};</script><!--.dyminimenu--><!--  ul--><!--    li(onclick="wll_menu(1);")--><!--      span 📝 添加mini便签--><!--    li(onclick="wll_menu(2);")--><!--      span 🆑 清空当前页面--><!-- hexo injector body_end start --><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='/'|| '/' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax  src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><!-- hexo injector body_end end --></body><script>document.addEventListener('touchmove', function (e) { e.preventDefault(); }, false)</script><script async data-pjax>if (IsPC()){
  btf.isJqueryLoad(image_preview_wrapper)
}
btf.isJqueryLoad(dybubblefn)</script></html>