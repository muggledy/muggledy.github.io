<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Python系列1 - 类型和对象 | Muggledy's Blog</title><meta name="robots" content="noindex"><meta name="author" content="Muggledy"><meta name="copyright" content="Muggledy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="📚 文档总目录 📘 系列1: 🎃 类型和对象 - 🎈 运算符与表达式 - 🎏 程序结构与控制流  对象的身份与类型 Python中一切皆对象，包括一些常见的基础数据类型，如数字、字符串、列表、字典等，还有用户所自定义的对象（对象也称为类型的“实例”）。对象具有三大特征：  身份（id），可以理解为在内存中的地址，具有唯一性，可以通过id(obj)查看 类型（type），对象都是由类实例化"><meta property="og:type" content="article"><meta property="og:title" content="Python系列1 - 类型和对象"><meta property="og:url" content="https://muggledy.github.io/posts/5311/index.html"><meta property="og:site_name" content="Muggledy&#39;s Blog"><meta property="og:description" content="📚 文档总目录 📘 系列1: 🎃 类型和对象 - 🎈 运算符与表达式 - 🎏 程序结构与控制流  对象的身份与类型 Python中一切皆对象，包括一些常见的基础数据类型，如数字、字符串、列表、字典等，还有用户所自定义的对象（对象也称为类型的“实例”）。对象具有三大特征：  身份（id），可以理解为在内存中的地址，具有唯一性，可以通过id(obj)查看 类型（type），对象都是由类实例化"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210323121638.jpg"><meta property="article:published_time" content="2021-04-24T12:55:45.000Z"><meta property="article:modified_time" content="2021-05-03T08:33:12.527Z"><meta property="article:author" content="Muggledy"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210323121638.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210207091812.png"><link rel="canonical" href="https://muggledy.github.io/posts/5311/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v1.2/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:{limitDay:500,position:"top",messagePrev:"这篇文章已经发表了",messageNext:"天了，其中某些内容可能已经过时。"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: Muggledy",link:"链接: ",source:"来源: Muggledy's Blog",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!0,isToc:!0,postUpdate:"2021-05-03 16:33:12"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,n={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(n))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=(new Date).getHours();void 0===t?o<=6||o>=18?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode();const a=saveToLocal.get("aside-status");void 0!==a&&("hide"===a?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"))})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v1.3/css/mystyle.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/data/font_awesome/font-awesome-animation.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/data/button/buttons.min.css"><script src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@v0.2/data/katong_font/katong-font.js"></script><script src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@v0.9/data/img_preview/article_img_preview.js"></script><script src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@v1.0/data/bubble/bubble.js"></script><script src="https://cdn.staticfile.org/moment.js/2.24.0/moment.js"></script><script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script><script src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/data/is_pc/is-pc.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Muggledy's Blog" type="application/atom+xml"></head><div class="dyminibox"></div><body><div class="dy-show-cbg" id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@v0.1/img/20210202152223.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210328224511.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-book"></i> <span>文章</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="fa-fw fas fa-archive faa-tada"></i> <span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="fa-fw fas fa-tags faa-tada"></i> <span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-folder-open faa-tada"></i> <span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart card-announcement-animation"></i> <span>关于</span></a></div><div class="menus_item"><a class="site-page" href="/note/"><i class="fa-fw fas fa-bullhorn"></i> <span>公示</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i> <span>更多</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener external nofollow noreferrer" href="https://zhixingo.github.io"><i class="fa-fw fas fa-tools faa-tada"></i> <span>工具</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener external nofollow noreferrer" href="https://musicforprogramming.net/"><i class="fa-fw fas fa-music faa-tada"></i> <span>音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/gallery/"><i class="fa-fw fas fa-image faa-tada"></i> <span>图册</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><i class="fa-fw fas fa-video faa-tada"></i> <span>电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210323121638.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Muggledy's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw faa-wrench animated"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-book"></i> <span>文章</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="fa-fw fas fa-archive faa-tada"></i> <span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="fa-fw fas fa-tags faa-tada"></i> <span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-folder-open faa-tada"></i> <span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart card-announcement-animation"></i> <span>关于</span></a></div><div class="menus_item"><a class="site-page" href="/note/"><i class="fa-fw fas fa-bullhorn"></i> <span>公示</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i> <span>更多</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener external nofollow noreferrer" href="https://zhixingo.github.io"><i class="fa-fw fas fa-tools faa-tada"></i> <span>工具</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener external nofollow noreferrer" href="https://musicforprogramming.net/"><i class="fa-fw fas fa-music faa-tada"></i> <span>音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/gallery/"><i class="fa-fw fas fa-image faa-tada"></i> <span>图册</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><i class="fa-fw fas fa-video faa-tada"></i> <span>电影</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Python系列1 - 类型和对象</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-24T12:55:45.000Z" title="发表于 2021-04-24 20:55:45">2021-04-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-03T08:33:12.527Z" title="更新于 2021-05-03 16:33:12">2021-05-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>76分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Python系列1 - 类型和对象"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/5311/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/posts/5311/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><div class="note green icon flat"><i class="note-icon fas fa-rocket"></i><p>📚 文档总目录<br>📘 系列1: 🎃 类型和对象 - 🎈 <a href="/posts/176/"><span style="color:#3a96dd">运算符与表达式</span></a> - 🎏 <a href="/posts/22901/"><span style="color:#3a96dd">程序结构与控制流</span></a></p></div><h2 id="对象的身份与类型">对象的身份与类型</h2><p>Python中<span class="inline-tag red">一切皆对象</span>，包括一些常见的基础数据类型，如数字、字符串、列表、字典等，还有用户所自定义的对象（对象也称为类型的“实例”）。对象具有三大特征：</p><ol><li>身份（id），可以理解为在内存中的地址，具有唯一性，可以通过<code>id(obj)</code>查看</li><li>类型（type），对象都是由类实例化产生的，对象所属类型可通过<code>type(obj)</code>或<code>obj.__class__</code>查看</li><li>值（value），不同对象具有不同值（体现在“属性”和“方法”的不同上），这也是其存在的现实意义</li></ol><div class="note simple"><p>对象被创建后，其身份和类型就不可改变，根据其值是否可变，可以区分为“可变对象”与“不可变对象”</p></div><p>从身份、类型和值三个不同的角度分别比较对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">if</span> a <span class="keyword">is</span> b:</span><br><span class="line">        <span class="keyword">pass</span> <span class="comment">#a和b是同一个对象</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(a) <span class="keyword">is</span> <span class="built_in">type</span>(b):</span><br><span class="line">        <span class="keyword">pass</span> <span class="comment">#a和b属于同一类型，或者说a和b指向同一内存地址</span></span><br><span class="line">    <span class="keyword">if</span> a == b:</span><br><span class="line">        <span class="keyword">pass</span> <span class="comment">#a和b具有相同值</span></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>当使用<code>==</code>运算符时，请务必确保<code>a==b</code>中的左值对象<code>a</code>所属类型已重载了<code>__eq__</code>方法（特别提醒用户自定义对象，python中已有的基础对象类型都已经重载了该方法），否则比较是无实际意义的，须知<code>a==b</code>等同于执行<code>a.__eq__(b)</code>，而一切对象继承自<code>object</code>类型，<code>object</code>类型的<code>__eq__</code>方法其实比较的是身份（<code>return a is b</code>）。一般来说<code>is</code>用得较少，因为在实际场景中，要比较两个对象是否相等，并不是通过内存地址来判断的，而是应该通过这两个对象的部分属性值，或者全部属性值来对比判断的<br>注：在描述时，<code>obj</code>泛指的是任意python对象，而<code>object</code>则特指万物始祖之基类</p></div><div class="note info flat"><p>Python中全部8种比较运算：<code>&gt;</code>（对应<code>__gt__()</code>）, <code>&gt;=</code>（对应<code>__ge__()</code>）, <code>&lt;</code>（对应<code>__lt__()</code>）, <code>&lt;=</code>（对应<code>__le__()</code>）, <code>==</code>, <code>!==</code>（对应<code>__ne__()</code>）, <code>is</code>, <code>is not</code>。其他就不说了，<code>is</code>用在什么地方？<br>或许你已知道<code>==None</code>是不推荐使用的，应替换为<code>is None</code>，这基于两点理由：1）<code>None</code>在python中是一个单例对象（<code>None</code>作为对象也具有自己的类型，但是你无法用这个类型创造出另一个<code>None</code>对象），其内存地址唯一，而身份比较的一个好处就是速度快，因为无需对将要比较的对象本身进行检查，<code>is</code>操作符只需对对象所在的内存地址进行比较，因此采用<code>is None</code>速度更快，2）由于<code>==</code>是可重载的，导致某些非<code>None</code>对象也可能“等于”<code>None</code>，从而致使程序出错，譬如当重载定义为<code>def __eq__(self,other): return True</code>时</p></div><h2 id="类型的类型">类型的类型</h2><p>既然一切皆对象，类型本身作为对象又是谁的实例呢？答：<code>type</code>类。上结论：</p><ul><li>一切类的类都是<code>type</code>，即一切类（包括<code>type</code>自身）都是<code>type</code>类的实例</li><li><code>object</code>是最顶层基类，一切类（除了<code>object</code>自身）追本溯源都继承自<code>object</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(object) #基类object作为对象，它的类型是type</span><br><span class="line">&lt;class &#39;type&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; type.__base__ #type作为类，直接继承自object</span><br><span class="line">&lt;class &#39;object&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; list.__base__ #list、tuple、dict等以及自定义类都继承自object，类型为type</span><br><span class="line">&lt;class &#39;object&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; type(list)</span><br><span class="line">&lt;class &#39;type&#39;&gt;</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/question/38791962"><img src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210425185857.png" alt="图1. object类和type类：图中虚线是实例关系、实线是继承关系"></a></p><div class="hide-toggle"><div class="hide-button toggle-title"><i class="fas fa-caret-right fa-fw"></i><span><code>isinstance()</code>类型判断</span></div><div class="hide-content"><p>早先在书上偶然看到一行代码<code>isinstance(A,object) #返回True</code>，其中<code>A</code>是一个自定义类，突然很不理解，没回过味来，还在<a target="_blank" rel="noopener external nofollow noreferrer" href="https://segmentfault.com/q/1010000019754936">SegmentFault</a>上提问，好蠢/(ㄒoㄒ)/~~</p><p>根据帮助文档（<code>help(isinstance)</code>）可知：<code>isinstance(obj, class_or_tuple)</code>判断对象<code>obj</code>是否是<code>class_or_tuple</code>中某个类的实例或者其子类的实例。假设<code>A</code>继承自<code>B</code>，<code>a=A()</code>，那么显然<code>isinstance(a,A)</code>返回<code>True</code>，由于<code>B</code>是<code>A</code>的父类，所以<code>B</code>是<code>a</code>所属的更大的类的范畴，所以<code>isinstance(a,B)</code>也返回<code>True</code>，即<code>a</code>是<code>B</code>的实例。根据上面<code>object</code>类和<code>type</code>类之间的关系很容易推知：一切类（包括<code>object</code>和<code>type</code>）都是<code>object</code>的实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(A(),<span class="built_in">object</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(A,<span class="built_in">object</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="built_in">object</span>,<span class="built_in">object</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="built_in">type</span>,<span class="built_in">object</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>官方建议当我们需要判断一个对象类型的时候应当使用<code>isinstance()</code>，虽然可以使用<code>type()</code>做“简单”类型判断，“简单”的原因在于，它无法判断一个对象是否属于其基类这一更大的范畴，譬如无法判断一只鹦鹉个体是否属于鸟类（谬论一），而只能判断它是鹦鹉类别</p><p>鹦鹉不是鸟：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span> <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Parrot</span>(<span class="params">Bird</span>):</span> <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=Parrot()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a) <span class="keyword">is</span> Parrot</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a) <span class="keyword">is</span> Bird</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(a,Bird)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>另外在旧式类（完全没必要了解）中<code>type()</code>还具有一个缺陷，譬如两个完全不同的类实例竟然能得出“类型相同”的结果（谬论二），狗和猫是同类？示例如下（python2环境）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span> <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=Dog()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=Cat()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(d) <span class="keyword">is</span> <span class="built_in">type</span>(c)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(d)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;instance&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(d,Cat)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Shiba</span>(<span class="params">Dog</span>):</span> <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(Shiba())</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;instance&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>对于新式类来说，实例化后的对象类型就是该类，这不容置疑，但是旧式类中没有基类<code>object</code>，实例化后的对象类型都是<code>instance</code></p></div></div><h2 id="对象的引用与复制">对象的引用与复制</h2><p>在程序进行像<code>a=b</code>这样的赋值时，就会创建一个对<code>b</code>的新引用，对于像数字和字符串这样的不可变对象，这种赋值实际上创建了<code>b</code>的一个副本，修改<code>b</code>并不影响<code>a</code>，然而，对于可变对象（如列表和字典），行为则完全不同，譬如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a <span class="comment">#b和a指向内存中同一位置的对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a <span class="comment">#id(a)==id(b)</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">2</span>] = -<span class="number">100</span> <span class="comment">#修改容器b中一个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="comment">#此时a仍指向b所指向的对象，所以a的内容也相应改变</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, -<span class="number">100</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = d = <span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p>也就是说当两个变量引用指向同一个可变对象时，修改其中任意一个变量都会影响到另一个，为了避免这种情况，必须创建对象的副本而不是新引用。事实上对于像列表和字典这样的容器对象，存在两种复制操作：浅复制和深复制。浅复制虽然创建了一个新对象（体现在id变化），但它包含的还是对原始对象中所包含的元素（假设这个元素是可变对象的话）的引用，譬如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>]] <span class="comment">#a中第三个元素是可变对象（所谓可变对象就是对象的值变了，但其在内存中的地址仍保持不变）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="built_in">list</span>(a) <span class="comment">#list工厂函数属于浅复制，还有切片操作也是浅复制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]=<span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">30</span> <span class="comment">#b中第三个元素其实是对a中第三个元素的引用，当a中第三个元素的值发生变化，b中第三个元素也将相应改变</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>].append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>]=[<span class="number">11</span>,<span class="number">12</span>] <span class="comment">#该赋值使得a中第三个元素指向了内存中另一个区域的（一个列表）对象，从而对列表[30,4,5]的引用计数减1，还剩下b中第三个元素对它的唯一引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">4</span>, <span class="number">5</span>]]</span><br></pre></td></tr></table></figure><p>深复制也将创建一个新对象，且会递归地遍历它所包含的所有对象并创建其副本，需借助标准库中的<code>copy.deepcopy()</code>函数完成此操作</p><h2 id="基础数据类型">基础数据类型</h2><div class="tabs" id="dytab1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#dytab1-1">None</button></li><li class="tab"><button type="button" data-href="#dytab1-2">数字</button></li><li class="tab"><button type="button" data-href="#dytab1-3">序列</button></li><li class="tab"><button type="button" data-href="#dytab1-4">映射</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="dytab1-1"><p><code>None</code>类型表示一个null对象（没有值的对象）。如果一个函数没有显式地返回值，则返回该对象。<code>None</code>经常用作可选参数的默认值，以便让函数检测调用者是否为该参数实际传递了值。<code>None</code>没有任何属性，在布尔表达式中求值时为<code>False</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dytab1-2"><p>Python内置了5种数字类型（都是不可变对象）：布尔型（<code>bool</code>）、整型（<code>int</code>）、长整型（<code>long</code>，目前好像没有<code>long</code>这一类型了，并入<code>int</code>）、浮点型（<code>float</code>）以及复数型（<code>complex</code>）。布尔值包括<code>True</code>和<code>False</code>两个值（参与数值运算时分别映射为数值1和0）。整数表示范围在-2147483648和2147483647（对应<span class="hide-inline"><button type="button" class="hide-button button--animated">32位二进制数<br></button><span class="hide-content">0111,1111,1111,1111,1111,1111,1111,1111</span></span>，其最高位为符号位）之间的所有整数。浮点型是用机器上浮点数的本机双精度（64bit）表示的，提供大约17位数的精度和范围从-308到308的指数。复数使用一对浮点数表示，复数的实部和虚部分别使用<code>.real</code>和<code>.imag</code>访问，<code>.conjugate()</code>用于计算复共轭（a+bj的共轭是a-bj）</p><div class="hide-toggle"><div class="hide-button toggle-title"><i class="fas fa-caret-right fa-fw"></i><span>进制转换</span></div><div class="hide-content"><p>先说一下<code>int(x, base)</code>方法，其根据给定的进制<code>base</code>（取值为0、2~36，为什么最高是36？因为26个英文字母加上10个数字总计36，譬如有一个16进制数：<code>e1</code>，其十进制结果为225）将数字字符串<code>x</code>转换为十进制整数，也可用于将一个浮点数转换为整型（非字符串时不能传递<code>base</code>参数）。特别的，<code>base</code>取值为0时，将按照字符串的字面意思进行解释，譬如给定的字符串为<code>0o16</code>，此时不必明确告知<code>base=8</code>，因为<code>0o</code>打头的就表示这是一个八进制数。默认的<code>base</code>值为10，即默认将一个十进制数字字符串转换为十进制整型（<code>int('1314')=1314</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#2、8、16进制转为10进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;10010&#x27;</span>,<span class="number">2</span>) <span class="comment">#int(&#x27;0b10010&#x27;,0)</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;32&#x27;</span>,<span class="number">8</span>) <span class="comment">#int(&#x27;0o32&#x27;,0)</span></span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;e1&#x27;</span>,<span class="number">16</span>) <span class="comment">#int(&#x27;0xe1&#x27;,0)</span></span><br><span class="line"><span class="number">225</span></span><br></pre></td></tr></table></figure><p>总而言之，<code>int()</code>只能用于将2~36进制的数（且为字符串类型）转换为10进制，如果你要将一个10进制数转换为2进制、8进制转为2进制、2进制转为8进制等等那它就无能为力了，下面介绍<code>bin()</code>、<code>oct()</code>以及<code>hex()</code>，分别用于将一个整数（这个整数可以是10进制的，也可以是2进制、8进制和16进制的）转换为2进制、8进制以及16进制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#10进制转2进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="number">18</span>)</span><br><span class="line"><span class="string">&#x27;0b10010&#x27;</span></span><br><span class="line"><span class="comment">#8进制转2进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="number">0o22</span>)</span><br><span class="line"><span class="string">&#x27;0b10010&#x27;</span></span><br><span class="line"><span class="comment">#16进制转2进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="number">0x12</span>)</span><br><span class="line"><span class="string">&#x27;0b10010&#x27;</span></span><br><span class="line"><span class="comment">#10进制转8进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">oct</span>(<span class="number">26</span>)</span><br><span class="line"><span class="string">&#x27;0o32&#x27;</span></span><br><span class="line"><span class="comment">#2进制转8进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">oct</span>(<span class="number">0b11010</span>)</span><br><span class="line"><span class="string">&#x27;0o32&#x27;</span></span><br><span class="line"><span class="comment">#16进制转8进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">oct</span>(<span class="number">0x1a</span>)</span><br><span class="line"><span class="string">&#x27;0o32&#x27;</span></span><br><span class="line"><span class="comment">#10进制转16进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="number">225</span>)</span><br><span class="line"><span class="string">&#x27;0xe1&#x27;</span></span><br><span class="line"><span class="comment">#2进制转16进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="number">0b11100001</span>)</span><br><span class="line"><span class="string">&#x27;0xe1&#x27;</span></span><br><span class="line"><span class="comment">#8进制转16进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="number">0o341</span>)</span><br><span class="line"><span class="string">&#x27;0xe1&#x27;</span></span><br></pre></td></tr></table></figure><p>以上描述了2、8、10、16进制数之间的相互转换，那么任意进制（2~36）之间如何相互转换呢，可以借助10进制数作为中间状态，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transform</span>(<span class="params">x,base=<span class="literal">None</span>,to=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;将base进制整数x转换为to进制数y，函数返回y</span></span><br><span class="line"><span class="string">        合法的进制范围为2~36，</span></span><br><span class="line"><span class="string">        x是一个字符串，是为了通用性考虑，因为整</span></span><br><span class="line"><span class="string">        数类型只涵盖了2、8、10、16进制，譬如16：</span></span><br><span class="line"><span class="string">        0b10000、0o20、16、0x10，但是其36进制为</span></span><br><span class="line"><span class="string">        g，只能以字符串形式表示，特别的，输入允</span></span><br><span class="line"><span class="string">        许以&#x27;0b&#x27;、&#x27;0o&#x27;、&#x27;0x&#x27;打头(此时base可以不</span></span><br><span class="line"><span class="string">        给或任意)，也可以不是，但</span></span><br><span class="line"><span class="string">        是作为输出的2、8、16进制数字字符串一律不</span></span><br><span class="line"><span class="string">        会以&#x27;0b&#x27;、&#x27;0o&#x27;、&#x27;0x&#x27;打头。</span></span><br><span class="line"><span class="string">        转换原理是，将base进制先转换为10进制，再</span></span><br><span class="line"><span class="string">        将这个10进制转换为to进制</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    x=x.lower()</span><br><span class="line">    x_10=<span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> x[:<span class="number">2</span>] <span class="keyword">in</span> [<span class="string">&#x27;0b&#x27;</span>,<span class="string">&#x27;0o&#x27;</span>,<span class="string">&#x27;0x&#x27;</span>]:</span><br><span class="line">        x_10=<span class="built_in">int</span>(x,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i,e <span class="keyword">in</span> <span class="built_in">enumerate</span>(x[::-<span class="number">1</span>]):</span><br><span class="line">            x_10+=(<span class="built_in">pow</span>(base,i)*(<span class="built_in">ord</span>(e)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)+<span class="number">10</span> <span class="keyword">if</span> <span class="string">&#x27;a&#x27;</span>&lt;=e&lt;=<span class="string">&#x27;z&#x27;</span> <span class="keyword">else</span> <span class="built_in">int</span>(e)))</span><br><span class="line">    y=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> x_10&gt;<span class="number">0</span>:</span><br><span class="line">        t=x_10%to</span><br><span class="line">        y+=(<span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)+t-<span class="number">10</span>) <span class="keyword">if</span> t&gt;<span class="number">9</span> <span class="keyword">else</span> <span class="built_in">str</span>(t))</span><br><span class="line">        x_10//=to</span><br><span class="line">    <span class="keyword">return</span> y[::-<span class="number">1</span>] <span class="keyword">if</span> y!=<span class="string">&#x27;&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    </span><br><span class="line">transform(<span class="string">&#x27;16&#x27;</span>,base=<span class="number">10</span>,to=<span class="number">36</span>) <span class="comment">#g</span></span><br><span class="line">f2t16=partial(transform,base=<span class="number">2</span>,to=<span class="number">16</span>) <span class="comment">#from 2 to 16</span></span><br><span class="line">f2t16(<span class="string">&#x27;11100001&#x27;</span>) <span class="comment">#e1</span></span><br></pre></td></tr></table></figure><p>注，任意进制转10进制的办法：<emp>按权相加</emp>，例如，将8进制数字 53627 转换成10进制：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>o</mi><mn>53627</mn><mo>=</mo><mn>5</mn><mo>×</mo><msup><mn>8</mn><mn>4</mn></msup><mo>+</mo><mn>3</mn><mo>×</mo><msup><mn>8</mn><mn>3</mn></msup><mo>+</mo><mn>6</mn><mo>×</mo><msup><mn>8</mn><mn>2</mn></msup><mo>+</mo><mn>2</mn><mo>×</mo><msup><mn>8</mn><mn>1</mn></msup><mo>+</mo><mn>7</mn><mo>×</mo><msup><mn>8</mn><mn>0</mn></msup><mo>=</mo><mn>22423</mn></mrow><annotation encoding="application/x-tex">0o53627 = 5×8^4 + 3×8^3 + 6×8^2 + 2×8^1 + 7×8^0 = 22423</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span><span class="mord mathnormal">o</span><span class="mord">5</span><span class="mord">3</span><span class="mord">6</span><span class="mord">2</span><span class="mord">7</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">5</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">3</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">6</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">7</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">2</span><span class="mord">4</span><span class="mord">2</span><span class="mord">3</span></span></span></span> (十进制)。所谓“权”（即位权），对于一个8进制数，从左往右看，第1位的位权为 8<sup>0</sup>=1，第2位的位权为 8<sup>1</sup>=8，第3位的位权为 8<sup>2</sup>=64，第4位的位权为 8<sup>3</sup>=512，第5位的位权为 8<sup>4</sup>=4096 …… 第n位的位权就为 8<sup>n-1</sup>，将各个位的数字乘以位权，然后再相加，就得到了十进制数值</p><p>将十进制转为任意N进制的办法，<emp>除N取余，逆序排列</emp>，例如将一个10进制数转换为8进制（36926 → 110076）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">36926&#x2F;8 &#x3D; 4615(除数) ··· 6(余数)</span><br><span class="line">4615  &#x2F;8 &#x3D; 576              ··· 7</span><br><span class="line">576    &#x2F;8 &#x3D; 72                ··· 0</span><br><span class="line">72      &#x2F;8 &#x3D; 9                  ··· 0</span><br><span class="line">9        &#x2F;8 &#x3D; 1                  ··· 1</span><br><span class="line">1        &#x2F;8 &#x3D; 0                  ··· 1(除数为0时停止)</span><br></pre></td></tr></table></figure><p>以上说的都是整数，那么如何对小数部分进行进制转换呢？例如将一个浮点数从8进制转换为10进制（还是<emp>按权相加</emp>）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>423.5176</mn></mrow><annotation encoding="application/x-tex">423.5176</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">4</span><span class="mord">2</span><span class="mord">3</span><span class="mord">.</span><span class="mord">5</span><span class="mord">1</span><span class="mord">7</span><span class="mord">6</span></span></span></span> (八进制)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mn>4</mn><mo>×</mo><msup><mn>8</mn><mn>2</mn></msup><mo>+</mo><mn>2</mn><mo>×</mo><msup><mn>8</mn><mn>1</mn></msup><mo>+</mo><mn>3</mn><mo>×</mo><msup><mn>8</mn><mn>0</mn></msup><mo>+</mo><mn>5</mn><mo>×</mo><msup><mn>8</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>8</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup><mo>+</mo><mn>7</mn><mo>×</mo><msup><mn>8</mn><mrow><mo>−</mo><mn>3</mn></mrow></msup><mo>+</mo><mn>6</mn><mo>×</mo><msup><mn>8</mn><mrow><mo>−</mo><mn>4</mn></mrow></msup><mo>=</mo><mn>275.65576171875</mn></mrow><annotation encoding="application/x-tex">= 4×8^2 + 2×8^1 + 3×8^0 + 5×8^{-1} + 1×8^{-2} + 7×8^{-3} + 6×8^{-4} = 275.65576171875</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.36687em;vertical-align:0"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">4</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">3</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">5</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">7</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">6</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">7</span><span class="mord">5</span><span class="mord">.</span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">7</span><span class="mord">6</span><span class="mord">1</span><span class="mord">7</span><span class="mord">1</span><span class="mord">8</span><span class="mord">7</span><span class="mord">5</span></span></span></span> (十进制)。即小数部分和整数部分情况相反，要从左往右看，第1（小数）位的位权为 8<sup>-1</sup>=1/8，第2位的位权为 8<sup>-2</sup>=1/64，第3位的位权为 8<sup>-3</sup>=1/512，第4位的位权为 8<sup>-4</sup>=1/4096 …… 第m位的位权就为 8<sup>-m</sup></p><p>另外如何将一个浮点数从10进制转换为8进制呢？规则为：<emp>乘N取整，顺序排列</emp>，示例如下（0.930908203125 → 7345）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0.930908203125×8 &#x3D; 7.447265625 → 7(取整)</span><br><span class="line">0.447265625      ×8 &#x3D; 3.578125       → 3</span><br><span class="line">0.578125            ×8 &#x3D; 4.625             → 4</span><br><span class="line">0.625                  ×8 &#x3D; 5.0                 → 5(乘数结果小数部分为0时停止)</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>由于浮点计算的不精确性，无法在程序中判断小数点后是否为0，小数进制转换代码就不写了，可能需要借助<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.sympy.org/latest/index.html">Sympy</a>符号运算库？</p></div></div></div><div class="note info flat"><p>日常生活中逗号常见于大整数的表示中，如<code>10,000,000</code>，从python3.6开始支持整数中使用<code>_</code>标记，作用同逗号：<code>a=10_000_000</code>，也适用于十六进制或二进制：<code>b=0b1_010_101</code></p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dytab1-3"><p>Python内置序列对象包括字符串、列表和元组，字符串是字符的序列，而列表和元组是任意对象的序列。字符串和元组均属于不可变对象，而列表支持插入、删除、替换元素操作。所有序列都支持迭代（见可迭代对象）</p><div class="tabs" id="dytab1-1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#dytab1-1-1">字符串</button></li><li class="tab"><button type="button" data-href="#dytab1-1-2">列表</button></li><li class="tab"><button type="button" data-href="#dytab1-1-3">元组</button></li><li class="tab"><button type="button" data-href="#dytab1-1-4">⭐可迭代对象</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="dytab1-1-1"><p>字符串的方法太多，请参阅文献[1]-p34</p><div class="hide-toggle"><div class="hide-button toggle-title"><i class="fas fa-caret-right fa-fw"></i><span>格式化字符串</span></div><div class="hide-content"></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dytab1-1-2"><ol><li>增加<br><ul><li><code>s.append(x)</code></li><li><code>s.extend(t)</code><br>注：不同于<code>append</code>追加元素，<code>extend</code>将一个新的序列扩展到原始序列中，等同于<code>[*s,*t]</code>（序列解包）<div class="hide-toggle"><div class="hide-button toggle-title"><i class="fas fa-caret-right fa-fw"></i><span>解构与封装</span></div><div class="hide-content"><div class="note danger flat"><p>此处的概念仅基于我自己已有的了解，可能存在描述错误，后续有时间再详细看文档修正</p></div><p>先说说python中的封装：即将多个以逗号分隔的对象组合在一起，从而得到一个元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">print(a,<span class="built_in">type</span>(a)) <span class="comment">#(1, 2, 3) &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a,b,c</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a*<span class="number">1</span>,b*<span class="number">2</span>,c*<span class="number">3</span> <span class="comment">#返回一个元组</span></span><br><span class="line"></span><br><span class="line">print(f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)) <span class="comment">#(1, 4, 9)</span></span><br></pre></td></tr></table></figure><p>而解构就是按照（容器中）元素的顺序，把线性解构的元素，依次赋值给多个变量。譬如解构列表对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">x,y,z=L</span><br><span class="line">print(x,y,z) <span class="comment">#1 2 3</span></span><br></pre></td></tr></table></figure><p>这常见于对称性赋值，将变量<code>x</code>和<code>y</code>的值对调，在其他如C语言中，必须借用中间变量才能实现，但是python只要一条语句：<code>x,y=y,x</code>，形式上十分简单，等号右边会先进行封装，变成元组<code>(y,x)</code>，然后元组被解构并依次赋值给<code>x</code>和<code>y</code><br>可以解构的对象类型包括：元组、列表、字典以及其它可迭代对象（生成器也是可迭代的，也能解构，譬如<code>a=(i for i in range(3));x,y,z=a</code>，<code>a</code>就是一个生成器，<code>import types;isinstance(a,types.GeneratorType)==True</code>），但是字典的解构就需要注意了，只能解构键序列，值序列不参与，譬如：<code>d={'a':1,'b':2,'c':3};x,y,z=d</code>，得到：<code>x='a'</code>、<code>y='b'</code>、<code>z='c'</code></p><p>使用&quot;装包&quot;与&quot;解包&quot;使得容器解构更加灵活多样：</p><ul><li>出现在赋值号左边的以<code>*</code>标识的变量赋值操作被称为"装包"<br><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">L=<span class="built_in">range</span>(<span class="number">100</span>)</span><br><span class="line">x,*y,z=L <span class="comment">#以&quot;*&quot;标识的y可以接收任意多个元素(这里是100-2个)，并以列表返回（即打包进列表）</span></span><br><span class="line">print(x) <span class="comment">#0</span></span><br><span class="line">print(y) <span class="comment">#1-98</span></span><br><span class="line">print(z) <span class="comment">#99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意：首个且唯一的赋值变量不能以*标识，否则出错，譬如：*x=L #SyntaxError: starred assignment target must be in a list or tuple，带星号的赋值变量必须位于一个序列中</span></span><br><span class="line">*x,=L <span class="comment">#这样就可以了</span></span><br><span class="line">*x,y=L</span><br></pre></td></tr></table></figure><p></p>支持“多级解构”：<p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">L=<span class="built_in">range</span>(<span class="number">100</span>)</span><br><span class="line">x,*y,z,w=<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,L,<span class="number">14</span> <span class="comment">#等同于：x,*y,z,w=[11,12,13,L,14]</span></span><br><span class="line">print(z) <span class="comment">#range(0, 100) #我们要求对L继续解构，将其首个元素和最后一个元素分别赋值给z1和z3，中间所有元素全部打包赋值给z2，如下</span></span><br><span class="line">x,*y,(z1,*z2,z3),z=<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,L,<span class="number">14</span> <span class="comment">#多级解构</span></span><br><span class="line">print(x) <span class="comment">#11</span></span><br><span class="line">print(y) <span class="comment">#[12, 13]</span></span><br><span class="line">print(z) <span class="comment">#14</span></span><br><span class="line">print(z1) <span class="comment">#0</span></span><br><span class="line">print(z2) <span class="comment">#1-98</span></span><br><span class="line">print(z3) <span class="comment">#99</span></span><br></pre></td></tr></table></figure><p></p></li><li>出现在赋值号右边的以<code>*</code>标识的对象将被"解包"<br><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">v=<span class="string">&#x27;daixiaodong&#x27;</span>,*L,<span class="string">&#x27;jucheng&#x27;</span>,<span class="number">99</span></span><br><span class="line">print(v) <span class="comment">#(&#x27;daixiaodong&#x27;, 1, 2, 3, &#x27;jucheng&#x27;, 99)</span></span><br><span class="line">L2=[<span class="number">11</span>,<span class="number">12</span>,*L,<span class="number">13</span>] <span class="comment">#除了用于容器解构的变量赋值操作，[11,12,*L,13]也可以单独摘出来，在任意地方使用，用于简化容器类的添加操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意，右侧不能单独出现一个以星号标识的对象，譬如：a=*L，报错：SyntaxError: can&#x27;t use starred expression here</span></span><br><span class="line">a=*L, <span class="comment">#同样改成序列就行了</span></span><br><span class="line">a=[*L]</span><br><span class="line"></span><br><span class="line">d=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line">a,*b=*d, <span class="comment">#注意在容器解构的变量赋值操作中，字典只能使用*单星号对其键序列解包，但是单独摘出来进行容器添加操作时，则是使用**双星号</span></span><br><span class="line">a=[*d] <span class="comment">#a=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p></p></li></ul><p>注（简化容器添加操作）：</p><p>不同于<code>list</code>、<code>tuple</code>、<code>set</code>使用单星号解包以进行容器扩充（如<code>L=[*L,1,2,3]</code>），字典使用双星号，如：<code>z=&#123;'a':1,'b':2&#125;;z=&#123;**z,'c':3&#125;</code>，比通过<code>dict.update()</code>扩充字典的形式要简单一点，但须知，<code>dict.update(another_dict)</code>可以明确更新项目，而<code>**</code>字典解包则无法确保，譬如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line">print(&#123;**d,<span class="string">&#x27;c&#x27;</span>:<span class="number">33</span>&#125;) <span class="comment">#&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 33&#125; #&#x27;c&#x27;键值更新了</span></span><br><span class="line">&#123;<span class="string">&#x27;c&#x27;</span>:<span class="number">33</span>,**d&#125; <span class="comment">#&#123;&#x27;c&#x27;: 3, &#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125; #&#x27;c&#x27;键值没有更新</span></span><br></pre></td></tr></table></figure><p>另外就是效率问题，用<code>*</code>和<code>**</code>简化容器的合并操作，其性能和容器对象的<code>update</code>,<code>append</code>或<code>add</code>方法相比，谁更优？根据下面的测试，解包比<code>append</code>方法慢了3倍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line">t1=timeit.Timer(<span class="string">&#x27;a.append(100)&#x27;</span>,<span class="string">&#x27;a=list(range(100))&#x27;</span>)</span><br><span class="line">print(t1.repeat()) <span class="comment">#[0.0850489117379404, 0.09039714449200119, 0.08290944329400407]</span></span><br><span class="line"></span><br><span class="line">t2=timeit.Timer(<span class="string">&#x27;b=[*a,100]&#x27;</span>,<span class="string">&#x27;a=list(range(100))&#x27;</span>)</span><br><span class="line">print(t2.repeat()) <span class="comment">#[0.2924700997522413, 0.2945020249114667, 0.2961987540175306]</span></span><br></pre></td></tr></table></figure></div></div></li><li><code>s.insert(i,x)</code><br></li></ul></li><li>删除<br><ul><li><code>s.pop([i])</code><br>注：函数定义或签名中的<code>[]</code>表示可选参数</li><li><code>s.remove(x)</code></li><li><code>del s[i]</code>、<code>del s[i:j]</code>、<code>del s[i:j:stride]</code><br>注：这是可变序列的通用操作</li></ul></li><li>查找<br><ul><li><code>s.index(x,[,start[,stop]])</code><br>注：返回满足<code>s[start:stop][i]==x</code>的最小<code>i</code>值，如果找不到，会抛出异常</li><li><code>s[i]</code>、<code>s[i:j]</code>、<code>s[i:j:stride]</code><br>注：这是序列的通用操作</li></ul></li><li>修改<br><ul><li><code>s.reverse()</code><br>注：这是原址操作，可以通过切片实现<code>s[::-1]</code>（返回一个新对象，上面说过，属于浅复制）</li><li><code>s.sort([key[,reverse]])</code><br><div class="hide-toggle"><div class="hide-button toggle-title"><i class="fas fa-caret-right fa-fw"></i><span><code>sort()</code>方法</span></div><div class="hide-content"><div class="note blue icon disabled"><i class="note-icon fas fa-lightbulb"></i><p>基本形式：<code>sorted(iterable[,cmp[,key[,reverse]]])</code>（副本排序）、 <code>iterable.sort(cmp[,key[,reverse]])</code>（原址排序）</p><p>参数：<code>iterable</code>为可迭代对象，<code>cmp</code>指定排序时进行比较的函数，<code>key</code>也是函数，指定待排序元素将要参与排序的特征，<code>reverse</code>实现降序，默认<code>False</code>为升序<br>注：python3去掉了<code>cmp</code>参数</p><p></p></div><p>简单示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.原址排序（对原始的序列对象进行内部排序而不是返回一个新的已排的序列对象）</span></span><br><span class="line">n=[<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">n.sort()</span><br><span class="line">print(n) <span class="comment">#[1, 2, 3, 4, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.副本排序</span></span><br><span class="line"><span class="comment">#两种：创建原始对象的一个副本，然后对副本做原址排序，或者使用sorted方法，其将返回一个类型为列表的副本</span></span><br><span class="line">x=[<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">y=x[:] <span class="comment">#对于列表对象来说，创建副本的方式有很多：切片、工厂函数、copy.copy（前三种是浅拷贝）、copy.deepcopy</span></span><br><span class="line">y.sort()</span><br><span class="line">print(x,y) <span class="comment">#x未排序，y已排序</span></span><br><span class="line"></span><br><span class="line">m=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">print(<span class="built_in">sorted</span>(m))</span><br><span class="line">print(m) <span class="comment">#sorted()不改变原始对象</span></span><br></pre></td></tr></table></figure><p>高级用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.自定义比较函数cmp(x,y)</span></span><br><span class="line"><span class="comment">#既然python3不支持，就不说了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.自定义待排序元素特征keys（接受一个参数，表示待排序的元素对象）</span></span><br><span class="line"><span class="comment">#之所以在key后面加上s，是因为特征可以有多个，首先按照第一个特征对元素排序，然后在此基础之上，再用第二个特征排序，第一个特征优先级最高。此即为多级排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keys</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(x)</span><br><span class="line"></span><br><span class="line">array=[<span class="string">&#x27;daiyang&#x27;</span>,<span class="string">&#x27;sb&#x27;</span>,<span class="string">&#x27;miaosiyu&#x27;</span>,<span class="string">&#x27;jianglicheng&#x27;</span>,<span class="string">&#x27;liuhan&#x27;</span>] <span class="comment">#按照字符串的长度进行排序（降）</span></span><br><span class="line">print(<span class="built_in">sorted</span>(array,key=keys,reverse=<span class="literal">True</span>)) <span class="comment">#由于取消了cmp比较函数，因此只能通过reverse设定升降顺序</span></span><br><span class="line">array.sort(key=<span class="keyword">lambda</span> x:<span class="built_in">len</span>(x),reverse=<span class="literal">True</span>)</span><br><span class="line">print(array) <span class="comment">#[&#x27;jianglicheng&#x27;, &#x27;miaosiyu&#x27;, &#x27;daiyang&#x27;, &#x27;liuhan&#x27;, &#x27;sb&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.多级排序</span></span><br><span class="line">arrays_1=[(<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>),(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>),(<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>),(<span class="number">2</span>,<span class="number">4</span>,<span class="number">10</span>)]</span><br><span class="line">arrays_2=[(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;10&#x27;</span>),(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>),(<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>),(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;10&#x27;</span>),(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;10&#x27;</span>)]</span><br><span class="line">arrays_1.sort(key=<span class="keyword">lambda</span> x:(x[<span class="number">2</span>],x[<span class="number">1</span>])) <span class="comment">#例1 #[(1, 2, 3), (5, 6, 7), (2, 3, 10), (2, 4, 10), (2, 5, 10)]</span></span><br><span class="line">print(arrays_1)</span><br><span class="line">print(<span class="built_in">sorted</span>(arrays_2,key=<span class="keyword">lambda</span> x:<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,(x[<span class="number">2</span>],x[<span class="number">1</span>]))))) <span class="comment">#例2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将operator.itemgetter函数用在多级排序中</span></span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="comment">#itemgetter函数用于选择对象的指定维数的数据，注意itemgetter返回的是一个函数对象</span></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">gets=itemgetter(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">#获取“对象[1]”和“对象[2]”，这个对象是广义化的，由你任意指定，如下：</span></span><br><span class="line">ret=gets(a) <span class="comment">#返回一个元组：(a[1],a[2])</span></span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果同例2:</span></span><br><span class="line">print(<span class="built_in">sorted</span>(arrays_2,key=<span class="keyword">lambda</span> x:<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,itemgetter(<span class="number">2</span>,<span class="number">1</span>)(x)))))</span><br><span class="line"><span class="comment">#结果同例1:</span></span><br><span class="line">print(<span class="built_in">sorted</span>(arrays_1,key=itemgetter(<span class="number">2</span>,<span class="number">1</span>))) <span class="comment">#体会key的作用，真神奇啊，源码是怎么实现的啊</span></span><br></pre></td></tr></table></figure></div></div></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dytab1-1-3"><p>类似于列表，只不过元组一旦创建不能修改，比列表要省内存</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dytab1-1-4"><p>首先新建一个链表类（目前就是一个普通的容器，可以存储数据，但是尚未实现<code>__iter__</code>方法，因此还不是可迭代对象），实现了链表的基本操作，索引、追加、插入、删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">__all__=[<span class="string">&#x27;Link&#x27;</span>,]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,val</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;节点对象，有数据域和指针域（指向下一元素）&#x27;&#x27;&#x27;</span></span><br><span class="line">        self.data=val</span><br><span class="line">        self.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;初始化链表，初始化一个头节点，其数据域默认为空，可以添加链表长度等信息&#x27;&#x27;&#x27;</span></span><br><span class="line">        head=Node(<span class="number">0</span>)</span><br><span class="line">        self.pointer=head <span class="comment">#语义：链表指针，指向头节点</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self,val</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;在链表尾部追加新元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        node=Node(val)</span><br><span class="line">        p=self.pointer    <span class="comment">#语义：工作指针</span></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:     <span class="comment">#获取指向最后一个元素的指针</span></span><br><span class="line">            p=p.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span>=node       <span class="comment">#看起来next“指针域”指向了node，因为next中保存的是对node的引用，而不是node的拷贝，这和C中的指针效果是一样的</span></span><br><span class="line">        self.pointer.data+=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printf</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;打印链表中元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        print(<span class="string">&#x27;[链表] &#x27;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        p=self.pointer</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            print(p.<span class="built_in">next</span>.data,end=<span class="string">&#x27;, &#x27;</span>)</span><br><span class="line">            p=p.<span class="built_in">next</span></span><br><span class="line">        print()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self,index,get=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;删除链表中第index个元素，get参数用于get()函数代码复用，这个参数应该隐藏（譬如作为类属性）而不该放在函数定义中&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> index&lt;<span class="number">1</span> <span class="keyword">or</span> index&gt;self.<span class="built_in">len</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;下标溢出&#x27;</span>)</span><br><span class="line">        p=self.pointer</span><br><span class="line">        i=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> i==index:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> get:</span><br><span class="line">                    p.<span class="built_in">next</span>=p.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="comment">#断开的节点无需手动free，因为python有垃圾回收机制</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> p.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            p=p.<span class="built_in">next</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        self.pointer.data-=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteall</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;删除全部元素，即头节点指针域指空&#x27;&#x27;&#x27;</span></span><br><span class="line">        p=self.pointer</span><br><span class="line">        p.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line">        self.pointer.data=<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,index</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;获取第index个节点元素，index取值1~len(Link)&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self.delete(index,<span class="literal">True</span>).data</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">len</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;链表长度，之前我们说头节点有空闲的数据域，我们可以存储链表长度信息，通过实时更新其值，可以避免硬计算&#x27;&#x27;&#x27;</span></span><br><span class="line">        p=self.pointer</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            p=p.<span class="built_in">next</span></span><br><span class="line">            i+=<span class="number">1</span> <span class="comment"># 硬计算</span></span><br><span class="line">        <span class="keyword">if</span> self.pointer.data!=i: <span class="comment">#为了避免错误，暂时我仍使用硬计算，并对头节点的数据域中的长度值进行检测</span></span><br><span class="line">            print(<span class="string">&#x27;头节点错误&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self,index,val</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;插入元素，index合法取值1到len(Link)+1，特别地，当index取值len(Link)+1时，为在尾部追加（特殊插入）&#x27;&#x27;&#x27;</span></span><br><span class="line">        node=Node(val)</span><br><span class="line">        <span class="keyword">if</span> index&lt;<span class="number">1</span> <span class="keyword">or</span> index&gt;self.<span class="built_in">len</span>+<span class="number">1</span>:</span><br><span class="line">            print(<span class="string">&#x27;下标溢出&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> index==self.<span class="built_in">len</span>+<span class="number">1</span>:</span><br><span class="line">            self.append(node)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        p=self.pointer</span><br><span class="line">        i=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> i==index:</span><br><span class="line">                t=p.<span class="built_in">next</span></span><br><span class="line">                p.<span class="built_in">next</span>=node</span><br><span class="line">                node.<span class="built_in">next</span>=t</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            p=p.<span class="built_in">next</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        self.pointer.data+=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    L=Link() <span class="comment">#空链表</span></span><br><span class="line">    L.append(<span class="number">1</span>)</span><br><span class="line">    L.append(<span class="number">2</span>)</span><br><span class="line">    L.append(<span class="number">3</span>)</span><br><span class="line">    L.insert(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">    L.printf()</span><br><span class="line">    L.delete(<span class="number">1</span>)</span><br><span class="line">    L.printf()</span><br><span class="line">    L.deleteall()</span><br><span class="line">    L.append(<span class="string">&#x27;muggle&#x27;</span>)</span><br><span class="line">    L.append(<span class="string">&#x27;daiyang&#x27;</span>)</span><br><span class="line">    L.printf()</span><br><span class="line">    print(L.get(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>凡是可迭代对象都可以用<code>for</code>语句逐一遍历全部元素，这是检查一个对象是否可迭代的标准，要创建一个可迭代对象，必须实现<code>__iter__()</code>方法，其返回一个迭代器，迭代器内部持有一个状态，用于记录当前迭代所在的位置，迭代器必须实现<code>__next__()</code>用于迭代获取下一个元素并更新迭代状态，而迭代器也属于可迭代对象的范畴，因此也必须实现<code>__iter__()</code>方法，具体实现时返回自身即可</p><p>下面我们试着将上述不可迭代的链表对象（Link）转变为可迭代的列表对象（List），并在链表的基础上构建一个迭代器对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span>(<span class="params">Link</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span> <span class="comment">#实现了__iter__方法之后，链表变成可迭代对象</span></span><br><span class="line">        <span class="keyword">return</span> ListIteration(self)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListIteration</span>:</span> <span class="comment">#简单来说，迭代器就相当于“普通容器+迭代状态”</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,container</span>):</span></span><br><span class="line">        self.data=container <span class="comment">#迭代器由容器数据和状态构成</span></span><br><span class="line">        self.iterstate=<span class="number">1</span> <span class="comment">#迭代器当前的迭代状态</span></span><br><span class="line">        self.stopstate=self.data.<span class="built_in">len</span> <span class="comment">#终止</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span> <span class="comment">#对一个迭代器获取其迭代器，就是其本身</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span> <span class="comment">#根据当前迭代状态迭代下一个元素，并更新状态</span></span><br><span class="line">        <span class="keyword">while</span> self.iterstate&lt;=self.stopstate:</span><br><span class="line">            self.iterstate+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> self.data.get(self.iterstate-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">raise</span> StopIteration <span class="comment">#对超出范围的元素迭代需要返回StopIteration，在for语句中该异常将被捕捉</span></span><br><span class="line">        </span><br><span class="line">a=List() <span class="comment">#创建一个列表（可迭代对象）</span></span><br><span class="line">a.append(<span class="number">10</span>)</span><br><span class="line">a.append(<span class="number">12</span>)</span><br><span class="line">a.append(<span class="number">14</span>)</span><br><span class="line">a.append(<span class="number">16</span>)</span><br><span class="line">b=<span class="built_in">iter</span>(a) <span class="comment">#将自动调用a.__iter__()</span></span><br><span class="line">print(b.__next__()) <span class="comment">#10 #或者写next(b)</span></span><br><span class="line">c=<span class="built_in">iter</span>(b) <span class="comment">#对迭代器调用iter()，返回自身，因此下面的c都可以替换为b</span></span><br><span class="line">print(c.__next__()) <span class="comment">#12</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">    print(i) <span class="comment">#14 16</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i) <span class="comment">#10 12 14 16</span></span><br></pre></td></tr></table></figure><div class="hide-toggle"><div class="hide-button toggle-title"><i class="fas fa-caret-right fa-fw"></i><span><code>for</code>循环原理</span></div><div class="hide-content"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.首先通过iter()获取迭代器对象</span></span><br><span class="line">iterator=<span class="built_in">iter</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment">#2.在循环中不断调用next方法获取迭代器对象的下一个值直至捕捉到StopIteration异常退出循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x=<span class="built_in">next</span>(iterator)</span><br><span class="line">        print(x)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></div></div><p><code>itertools</code>模块提供了诸多具有特殊用途的迭代器，譬如<code>count()</code>返回一个无限循环的迭代器（既然无限循环为什么不直接使用<code>while</code>？因为<code>count()</code>可以很方便地记录当前迭代次序），再如<code>cycle()</code>从有限序列生成无限序列，用于循环遍历序列，等等，下面是<code>cycle</code>的实现（我随便写的，非官方实现）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cycle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,container,start=<span class="number">0</span></span>):</span> <span class="comment">#start指定从序列的哪一个元素开始循环迭代</span></span><br><span class="line">        self.data=container</span><br><span class="line">        self.iterstate=start</span><br><span class="line">        self.<span class="built_in">len</span>=<span class="built_in">len</span>(container)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.iterstate+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.data[(self.iterstate-<span class="number">1</span>)%self.<span class="built_in">len</span>]</span><br><span class="line">        </span><br><span class="line">a=cycle([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],) <span class="comment">#不同于上面自定义的列表是一个可迭代对象（但非迭代器对象），此处cycle(...)直接就是迭代器对象，当然也就是可迭代对象。再如python几种内置类型list、tuple、dict、set、str等，也都是可迭代对象，但非迭代器对象（为何这样设计？道理很简单，迭代器对象都是用完即扔的，这实在是太浪费资源了，于是你需要不停在内存中创建和回收对象，但重复将可迭代对象转换为迭代器就很便宜了，无非就是将状态位归零罢了），譬如a=[1,2,3];next(a)将报错：TypeError: &#x27;list&#x27; object is not an iterator</span></span><br><span class="line">print(<span class="built_in">next</span>(a),<span class="built_in">next</span>(a),<span class="built_in">next</span>(a),<span class="built_in">next</span>(a),<span class="built_in">next</span>(a),<span class="built_in">next</span>(a),<span class="built_in">next</span>(a)) <span class="comment">#1 2 3 1 2 3 1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i) <span class="comment">#无限循环，因为for循环只会在next(迭代器)抛出StopIteration（停止迭代异常）的时候终止</span></span><br></pre></td></tr></table></figure><p>判断是否可迭代以及是否是迭代器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="comment">#list是可迭代对象吗？</span></span><br><span class="line">print(<span class="built_in">isinstance</span>([],collections.Iterable)) <span class="comment">#True</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="comment">#list是迭代器对象吗？</span></span><br><span class="line">print(<span class="built_in">isinstance</span>([],collections.Iterator)) <span class="comment">#False</span></span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://python.jobbole.com/86258/"><img src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210429214739.png" alt="图2. 可迭代对象、迭代器、生成器关系" style="width:540px"></a></p><p>再说说生成器，实际上生成器本质就是迭代器（因此生成器也是用完即弃），只要迭代的下一个元素是即时计算（惰性计算）的，那就是生成器，普通迭代器迭代下一个元素，是从某个容器中取出来，所有元素事先已经计算得出，其始终占用着一片内存区域（因此只有生成器才能实现“无限序列”）。在python2中<code>range()</code>就是一个普通迭代器（譬如<code>range(10000)</code>内存中真的就存在10000个数字），<code>xrange()</code>则是生成器（此时内存中就没有10000个数据占用），下面我们自行设计一个生成器版本的<code>range</code>（Range）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Range</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,*args</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(args)==<span class="number">1</span>:</span><br><span class="line">            self.start,self.stop,self.step=<span class="number">0</span>,args[<span class="number">0</span>],<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(args)==<span class="number">2</span>:</span><br><span class="line">            self.start,self.stop,self.step=*args,<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(args)==<span class="number">3</span>:</span><br><span class="line">            self.start,self.stop,self.step=args</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;[参数错误] Range(start[,stop[,step]])&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> self.start&lt;self.stop:</span><br><span class="line">            self.start+=self.step</span><br><span class="line">            <span class="keyword">return</span> self.start-self.step</span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Range(<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>):</span><br><span class="line">    print(i) <span class="comment">#3, 5, 7</span></span><br><span class="line">print(<span class="built_in">list</span>(Range(<span class="number">5</span>))) <span class="comment">#[0, 1, 2, 3, 4]，工厂函数list自动计算生成器各个元素的值并以列表返回</span></span><br></pre></td></tr></table></figure><p>通常采用<code>yield</code>关键字构造生成器，在函数中使用<code>yield</code>关键字代替<code>return</code>关键字（称为生成器函数），函数调用将返回一个生成器对象，此时函数内部代码不会立即执行，除非对其调用<code>next()</code>方法，函数执行流将在<code>yield</code>位置中止，并返回<code>yield</code>表达式值，继续调用<code>next()</code>方法，函数执行流将从<code>yield</code>中止处继起并在下一次遇到<code>yield</code>时中止…，<code>yield</code>使得生成器的语法变得相当优雅（我们几乎从不使用上面Range示例的方式编写生成器，python本身也不认为那是一个生成器对象，如<code>isinstance(Range(5),types.GeneratorType)</code>会返回<code>False</code>），简单来说生成器函数就是在一个循环中不断计算并产生新值的过程且只在需要时计算（“惰性计算”，不调用<code>next()</code>方法则不计算），它定义了数据生产的流程，当我们需要将生产和消耗分离的时候，使用生成器可以方便地解耦，任意函数稍作修改便可转换为生成器函数，只需要将<code>return</code>关键字改成<code>yield</code>关键字，现在我们用<code>yield</code>方式重写Range：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Range</span>(<span class="params">*args</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args)==<span class="number">1</span>:</span><br><span class="line">        start,stop,step=<span class="number">0</span>,args[<span class="number">0</span>],<span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(args)==<span class="number">2</span>:</span><br><span class="line">        start,stop,step=*args,<span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(args)==<span class="number">3</span>:</span><br><span class="line">        start,stop,step=args</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;[参数错误] Range(start[,stop[,step]])&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> start&lt;stop:</span><br><span class="line">        start+=step</span><br><span class="line">        <span class="keyword">yield</span> start-step</span><br><span class="line">    <span class="keyword">raise</span> StopIteration <span class="comment">#生成器其实没必要在结束位置处显式抛出该异常，因为会自动抛，但是（非生成器的）迭代器必须手动抛出</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Range(<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>):</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line">print(<span class="built_in">list</span>(Range(<span class="number">5</span>))) <span class="comment">#[0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><div class="hide-toggle"><div class="hide-button toggle-title"><i class="fas fa-caret-right fa-fw"></i><span>惰性计算</span></div><div class="hide-content"><p>为了深入了解“惰性计算”，看个<a target="_blank" rel="noopener external nofollow noreferrer" href="https://segmentfault.com/q/1010000016013187">示例</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g=(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">10</span>]:</span><br><span class="line">    g=(i+j <span class="keyword">for</span> j <span class="keyword">in</span> g)</span><br><span class="line">print(<span class="built_in">list</span>(g))</span><br></pre></td></tr></table></figure><p>不少人（包括我）认为结果会是<code>[11,12,13,14]</code>，但是解释器运行结果却是<code>[20, 21, 22, 23]</code>，why？</p><p>对于一个生成器表达式<code>(expression1 for variables in expression2)</code>，<code>expression1</code>只有在调用生成器对象的<code>__next__()</code>方法时才会执行，而<code>for</code>子句则是即时计算的，即<code>expression2</code>是即时计算的（<code>expression2</code>应返回一个可迭代对象），另注意，<code>for</code>子句可能是多层<code>for</code>循环嵌套的，只有最左边的<code>for</code>子句才会即时计算，譬如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">range</span>(n)</span><br><span class="line"></span><br><span class="line">g1=(i <span class="keyword">for</span> i <span class="keyword">in</span> bar()) <span class="comment">#for子句表达式是即时计算的，此处等同于：g1=(i for i in range(2))</span></span><br><span class="line">n=<span class="number">3</span></span><br><span class="line">g2=((i,j) <span class="keyword">for</span> i <span class="keyword">in</span> bar() <span class="keyword">for</span> j <span class="keyword">in</span> bar()) <span class="comment">#只有最左侧的for子句表达式才即时计算，此处等同于：g2=((i,j) for i in range(3) for j in bar())</span></span><br><span class="line">n=<span class="number">4</span></span><br><span class="line">print(<span class="built_in">list</span>(g1))</span><br><span class="line">print(<span class="built_in">list</span>(g2)) <span class="comment">#list遍历生成器元素，由于最后修改的n值为4，于是此处等同于：g2=((i,j) for i in range(3) for j in range(4))</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">[0, 1]</span></span><br><span class="line"><span class="string">[(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3)]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果expression2是一个变量引用，将变量引用指向其他对象不会改变生成器数值，如果变量引用指向一个可变对象，修改该可变对象则会改变生成器数值：</span></span><br><span class="line">a=<span class="built_in">range</span>(<span class="number">2</span>)</span><br><span class="line">g=(i <span class="keyword">for</span> i <span class="keyword">in</span> a)</span><br><span class="line">a=<span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line">print(<span class="built_in">list</span>(g)) <span class="comment">#[0, 1]</span></span><br><span class="line"></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">g=(i <span class="keyword">for</span> i <span class="keyword">in</span> a)</span><br><span class="line">a.append(<span class="number">5</span>)</span><br><span class="line">print(<span class="built_in">list</span>(g)) <span class="comment">#[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>回到最初的问题，第一次循环，生成器<code>g</code>中的值其实就是<code>[i+0,i+1,i+2,i+3]</code>（尚未计算），第二次循环，<code>g</code>变成<code>[i+(i+0),i+(i+1),i+(i+2),i+(i+3)]</code>（尚未计算），最后通过<code>list(g)</code>遍历时，<code>i=10</code>，于是输出<code>[20,21,22,23]</code>。将其用生成器函数改写一下同时展开<code>for</code>循环，其执行过程相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen1</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen2</span>():</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> gen1():</span><br><span class="line">        <span class="keyword">yield</span> i+j</span><br><span class="line"></span><br><span class="line">i=<span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen3</span>():</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> gen2():</span><br><span class="line">        <span class="keyword">yield</span> i+j</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">list</span>(gen3())) <span class="comment">#[20, 21, 22, 23]</span></span><br></pre></td></tr></table></figure><p>这就很明了了，或者再改写一下得到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">i=<span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen3</span>():</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">yield</span> i+i+k</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">list</span>(gen3())) <span class="comment">#[20, 21, 22, 23]</span></span><br></pre></td></tr></table></figure><p>另外如果不是通过<code>list(g)</code>输出生成器序列元素，而是用<code>for</code>循环替换之：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> g:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">20</span></span><br><span class="line"><span class="string">41</span></span><br><span class="line"><span class="string">84</span></span><br><span class="line"><span class="string">171</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#破解之法就是替换for循环变量</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> g:</span><br><span class="line">    print(k)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">20</span></span><br><span class="line"><span class="string">21</span></span><br><span class="line"><span class="string">22</span></span><br><span class="line"><span class="string">23</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>要注意迭代变量的使用，如果使用<code>i</code>作为迭代变量，结果将会发生变化，这仍是惰性计算导致的，结合<code>for</code>循环原理原因就很清楚了（每次循环都会执行<code>i=next(g)</code>，而<code>i</code>将影响生成器序列的数值计算）</p></div></div><p><code>GeneratorExit</code>异常标志着生成器迭代过程的非正常终止，相反，正常终止不会引发该异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">n</span>):</span> <span class="comment">#不断生产数据</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> n</span><br><span class="line">            n-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span> GeneratorExit:</span><br><span class="line">        print(<span class="string">&#x27;exiting...&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">g=f(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> g: <span class="comment">#每产生一个数据就消耗一个数据，如果使用while循环是无法分离生产和消耗两个部分的，它们势必混合在一起</span></span><br><span class="line">    print(i) <span class="comment">#3 2 1</span></span><br></pre></td></tr></table></figure><p>如果生成器仅被部分使用，将在<code>yield</code>处引发<code>GeneratorExit</code>异常（但一般不用人为捕获），并自动调用<code>close()</code>方法关闭生成器，如果再次调用<code>next()</code>方法将引发<code>StopIteration</code>异常，它已不能继续产生新值了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g=f(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> g:</span><br><span class="line">    <span class="keyword">if</span> i&gt;<span class="number">1</span>:</span><br><span class="line">        print(i) <span class="comment">#3 2 exiting...</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">g.__next__() <span class="comment">#出现StopIteration异常，不要再期望输出1</span></span><br></pre></td></tr></table></figure><p>注：<code>for</code>语句能判断生成器函数是否全部完成，如果你是通过<code>while</code>和<code>next</code>进行迭代是无法判断的（只有在整个程序终止时才会引发该异常），这个时候就需要显式关闭（但这不是必须的），鉴于你通常会忘记，一般我们只使用<code>for</code>循环来迭代生成器</p><p>手动执行<code>close()</code>方法亦将在<code>yield</code>处引发<code>GeneratorExit</code>异常（假设生成器已被使用过的话）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g=f(<span class="number">3</span>)</span><br><span class="line">print(g.__next__()) <span class="comment">#3</span></span><br><span class="line">g.close() <span class="comment">#exiting...</span></span><br></pre></td></tr></table></figure><p>删除生成器对象也会引发该异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g=f(<span class="number">3</span>)</span><br><span class="line">print(g.__next__()) <span class="comment">#3</span></span><br><span class="line"><span class="keyword">del</span> g <span class="comment">#exiting...</span></span><br></pre></td></tr></table></figure><p>小结一下：</p><ol><li>生成器在<code>close()</code>方法后就无法再进行迭代，再调用<code>next()</code>方法就会抛出<code>StopIteration</code>异常</li><li>生成器调用<code>close()</code>方法会在<code>yield</code>处抛出<code>GeneratorExit</code>异常，但前提是至少调用一次生成器的<code>next()</code>方法才会产生<code>GeneratorExit</code>异常，如果生成器没有启动则不会抛出异常</li><li>生成器内捕捉<code>GeneratorExit</code>异常后，可以继续执行剩余的代码，但剩余的代码中不能再包含<code>yield</code>语句，否则抛出<code>RuntimeError</code>异常</li><li><code>GeneratorExit</code>异常不能通过<code>Exception</code>捕捉，<code>Exception</code>是常规异常的基类，但可以通过所有异常的基类<code>BaseException</code>来捕捉</li></ol><p>上面我们说了为什么内置的类型如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>都被设计为可迭代对象而非迭代器（迭代器是“一次性”的），原因不止一条，譬如<code>in</code>关键字就不能用于迭代器对象，<code>x in y</code>语句的工作原理是，首先调用对象<code>y</code>上的<code>iter()</code>方法，然后不断执行<code>next()</code>方法获取下一个元素，直至<code>x==next(y)</code>，返回<code>True</code>，否则返回<code>False</code>，表示容器<code>y</code>中不存在<code>x</code>，看一个错误范例就明了了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y=(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line">x=<span class="number">1</span></span><br><span class="line">print(x <span class="keyword">in</span> y) <span class="comment">#True</span></span><br><span class="line">print(x <span class="keyword">in</span> y) <span class="comment">#False</span></span><br></pre></td></tr></table></figure><p>第一次执行<code>x in y</code>时候，<code>iter(y)</code>返回<code>y</code>自身，执行两次<code>next(y)</code>，生成器<code>y</code>中的前两个元素0和1被消耗（发现<code>x</code>存在于<code>y</code>中），结果返回<code>True</code>，第二次执行<code>x in y</code>的时候，<code>iter(y)</code>仍旧返回被部分消耗的<code>y</code>自身，继续调用<code>next()</code>方法，显然后面的元素2、3、4中不存在1，因此返回<code>False</code>。这种情况下如果要进行存在性判断，可以先将生成器转换为列表（<code>list(y)</code>），一个可迭代对象（而<code>iter(可迭代对象)</code>总是返回一个全新的迭代器对象）</p><div class="hide-toggle"><div class="hide-button toggle-title"><i class="fas fa-caret-right fa-fw"></i><span><code>yield</code>与递归混用</span></div><div class="hide-content"><p>将<code>yield</code>与递归混用时要小心，很容易出错，先来看一个示例，遍历一个嵌套的列表（展平操作）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">lists</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lists:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(i,<span class="built_in">list</span>):</span><br><span class="line">            flatten(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(i)</span><br><span class="line"></span><br><span class="line">a=[<span class="number">0</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]],[<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]]</span><br><span class="line">flatten(a) <span class="comment">#0 1 2 3 4 5 6 7 8 9 10</span></span><br></pre></td></tr></table></figure><p>改写为生成器（这个改写是错误的）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">lists</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lists:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(i,<span class="built_in">list</span>):</span><br><span class="line">            flatten(i) <span class="comment">#位置2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> i <span class="comment">#位置1</span></span><br><span class="line">            </span><br><span class="line">a=[<span class="number">0</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]],[<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flatten(a):</span><br><span class="line">    print(i) <span class="comment">#仅仅打印出0</span></span><br></pre></td></tr></table></figure><p>这个结果似乎出人意料，分析一下，设<code>g=flatten(a)</code>，<code>for</code>语句第一次调用<code>g</code>的<code>next()</code>方法，由于列表<code>a</code>的第一个元素是数字，因此函数执行流将到达位置1处中止并返回<code>yield</code>表达式值，即0，第二次调用<code>next()</code>方法，执行流从中止处继续，由于列表<code>a</code>的第二个元素是列表，因此到达位置2处，关键即在于此，位置2处的<code>flatten(i)</code>将返回一个生成器，然而生成器是惰性的，在没有调用<code>next()</code>方法的情况下生成器根本不会执行（修正的办法就是手动去迭代这个生成器），更何况返回的生成器对象还没有被赋值，没有外部引用的它随即会被当作垃圾回收，因此完全可以忽略它的存在，即可以将位置2处的语句替换成<code>pass</code>，于是执行流继续向后执行，而列表<code>a</code>中的后面的两个元素仍都是列表对象，因此执行流不会再到达位置1，生成器也不会再生产值，执行流结束将抛出<code>StopIteration</code>异常，分析结束，可知<code>g</code>这个迭代器的长度仅为1。修正：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">lists</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lists:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(i,<span class="built_in">list</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> flatten(i):</span><br><span class="line">                <span class="keyword">yield</span> j</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>序列操作三大函数：</p><ul><li><p><code>map(func,seq1[,seq2,...])</code><br>批量映射函数，<code>map</code>将序列中的元素映射或转换成其他元素，<code>func</code>充当转换器</p><ol><li>当只有一个序列参数时，<code>map(func,seq)</code>等同于<code>[func(e) for e in seq]</code></li><li>当有多个序列参数时，<code>map(func,seq1,seq2,...)</code>等同于<code>[func(*t) for t in [*zip(seq1,seq2,...)]]</code>（这些序列的长度的长度可以不一致，按最短的来，在python2中，当<code>func</code>取<code>None</code>时，<code>map</code>就等同于<code>zip</code>，但python3已不再允许<code>func</code>参数为<code>None</code>）<br>打个比方，如果将<code>seq1</code>、<code>seq2</code>、… 各自比作飞机的不同的零件提供商，那么<code>map</code>函数就是批量制造飞机的工厂，<code>func</code>就是制造飞机的原理图纸</li></ol><div class="hide-toggle"><div class="hide-button toggle-title"><i class="fas fa-caret-right fa-fw"></i><span><code>zip</code>函数</span></div><div class="hide-content"><p>简单应用：</p><ul><li><p>快速构建字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过dict类初始化函数或者说工厂函数</span></span><br><span class="line">print(<span class="built_in">dict</span>(<span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">5</span>),<span class="built_in">range</span>(<span class="number">5</span>,<span class="number">10</span>)))) <span class="comment">#&#123;0: 5, 1: 6, 2: 7, 3: 8, 4: 9&#125;</span></span><br><span class="line"><span class="comment">#通过字典生成式</span></span><br><span class="line">print(&#123;k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">5</span>),<span class="built_in">range</span>(<span class="number">5</span>,<span class="number">10</span>))&#125;)</span><br></pre></td></tr></table></figure></li><li><p>利用<code>zip</code>完成二维矩阵转置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>], [<span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>], [<span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>], [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>]] <span class="comment">#按行描述的矩阵，现将该矩阵按列描述，即为转置的结果</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a: <span class="comment">#原矩阵</span></span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment">#利用列表生成式进行转置</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [[row[col] <span class="keyword">for</span> row <span class="keyword">in</span> a] <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a[<span class="number">0</span>]))]:</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment">#这个生成式正是zip压缩的过程，因此直接用zip很简便：</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(*a): <span class="comment">#*为解包裹函数参数传递</span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure></li><li><p>将序列按连续k个值分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#假设是将序列a按连续两个值分组</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#大佬写法1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(*[<span class="built_in">iter</span>(a)]*<span class="number">2</span>): <span class="comment">#操作符优先级为：zip(*([iter(a)]*2))，这里的*是函数参数的解包裹传递方式，就是将一个序列解包为诸多的位置参数传给函数</span></span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#普通写法2</span></span><br><span class="line">b=<span class="built_in">iter</span>(a)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(b,b): <span class="comment">#另注意不能构成长度为2的分组的部分元素（残值）将被丢弃</span></span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">(1, 2)</span></span><br><span class="line"><span class="string">(3, 4)</span></span><br><span class="line"><span class="string">(5, 6)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#正常人写法3</span></span><br><span class="line">myslice=<span class="keyword">lambda</span> a,k:[a[i:i+k] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(a),k)] <span class="comment">#缺点在于假设传入的a万一是一个迭代器（无法计算长度，无len()方法），那就需要转为列表或其它可计算长度的对象类型，相比之下，zip调用next()更鲁棒。这种写法不丢弃“残值”</span></span><br><span class="line">print(myslice(a,<span class="number">2</span>)) <span class="comment">#[[1, 2], [3, 4], [5, 6], [7]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#正常人写法4</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(a[::<span class="number">2</span>],a[<span class="number">1</span>::<span class="number">2</span>]): <span class="comment">#相邻2个元素</span></span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(a[::<span class="number">3</span>],a[<span class="number">1</span>::<span class="number">3</span>],a[<span class="number">2</span>::<span class="number">3</span>]): <span class="comment">#相邻3个元素</span></span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment"># 假设要相邻k个元素，就要进行k次切片，显然很麻烦，改写一下：</span></span><br><span class="line">myzip=<span class="keyword">lambda</span> k:<span class="built_in">zip</span>(*[a[i::k] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> myzip(<span class="number">4</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>解释：先说一下<code>zip</code>函数的工作原理，函数接收任意数量的可迭代对象参数，第一步利用<code>iter()</code>将参数全部转换为迭代器对象，第二步在一个<code>while</code>循环中，每一轮，依次获取每个迭代器的下一项，然后组装成一个元组，并追加到返回值序列中，当最短的迭代器对象抛出<code>StopIteration</code>异常时，退出<code>while</code>循环。<code>zip</code>原理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myzip</span>(<span class="params">*args</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;the principle of function zip&#x27;&#x27;&#x27;</span></span><br><span class="line">    m=<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">iter</span>,args))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ret=[] <span class="comment">#返回值序列</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            li=[]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(m)):</span><br><span class="line">                li.append(m[i].__next__())</span><br><span class="line">            ret.append(<span class="built_in">tuple</span>(li))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">ret=myzip([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],[<span class="number">13</span>,<span class="number">14</span>])</span><br><span class="line">print(ret) <span class="comment">#[(1, 4, 8, 13), (2, 5, 9, 14)]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;或者：</span></span><br><span class="line"><span class="string">def myzip(*args): #直接根据最短的列表长度确定轮回次数nloop</span></span><br><span class="line"><span class="string">    m=list(map(iter,args))</span></span><br><span class="line"><span class="string">    nloop=min([len(args[i]) for i in range(len(m))])</span></span><br><span class="line"><span class="string">    #ret=[tuple([m[i].__next__() for i in range(len(m))]) for j in range(len(list(m[0])))] #和下面修改的区别在于：list(one iteration)会导致对迭代器（参数）的一遍迭代，结果想再调用next就会立即抛出异常，由此我们可以大概知道工厂函数list的原理：list(iterable obj)，首先将可迭代参数对象转为迭代器，然后迭代(next)整个迭代器得到新的列表对象，其中的元素都是对参数对象中元素的引用</span></span><br><span class="line"><span class="string">    ret=[tuple([m[i].__next__() for i in range(len(m))]) for j in range(nloop)]</span></span><br><span class="line"><span class="string">    return ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>现在回头看写法2就非常明了了，写法1就是换个写法而已，前提是你要知道<code>[obj]*i</code>将返回一个长度为<code>i</code>的序列<code>[obj,obj,...]</code>，其中每一项都是对原始的<code>obj</code>对象的引用（或者说浅复制），如果是按连续k个值分组，那就将<code>zip(*[iter(a)]*2)</code>中的2换成k即可</p></li><li><p>滑动窗口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slicing</span>(<span class="params">obj,n</span>):</span></span><br><span class="line">    <span class="comment">#obj为可迭代序列，n为窗口大小或者说步长，每次滑动我们看见的序列内容都不一样，函数返回全部窗口滑动状态下的序列的内容视图</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">zip</span>(*[islice(obj,i,<span class="literal">None</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]) <span class="comment">#注意obj只能是可迭代对象，不能是迭代器，因为islice会消耗迭代器</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> slicing([<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">1</span>],<span class="number">3</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure></li><li><p>反转字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125; <span class="comment">#字典value必须都是不可变对象</span></span><br><span class="line">print(<span class="built_in">dict</span>(<span class="built_in">zip</span>(*<span class="built_in">list</span>(<span class="built_in">zip</span>(*m.items()))[::-<span class="number">1</span>]))) <span class="comment">#&#123;1: &#x27;a&#x27;, 2: &#x27;b&#x27;, 3: &#x27;c&#x27;, 4: &#x27;d&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul></div></div></li><li><p><code>filter(func,seq)</code><br>序列过滤器，过滤掉不符合条件的元素，返回那些符合条件的元素所组成的新（子）序列，<code>func</code>充当筛选器（应返回<code>True</code>或<code>False</code>）。等同于<code>[e for e in seq if func(e)]</code></p></li><li><p><code>reduce(func,seq[,initial])</code><br>该函数工作流程是：在迭代<code>seq</code>的过程中，首先将前两个元素传给<code>func</code>函数（可以通过<code>initial</code>参数额外指定首个元素值，相当于序列<code>seq</code>增加了一个元素，新序列为<code>[initial,*seq]</code>），函数加工后将返回值和<code>seq</code>序列的第三个元素重新传入<code>func</code>函数，再将返回值和<code>seq</code>的第四个元素一起传入<code>func</code>函数，以此类推，直至遍历到<code>seq</code>的最后一个元素，最后一次执行的<code>func</code>函数输出将作为<code>reduce</code>函数的返回值<br>注：python3从全局空间移除了该函数，需要从标准库<code>functools</code>中引入<br><code>reduce</code>最大的特点在于，过程中每一次迭代都携带着上一次的迭代结果，这种对历史的可见性有时候很有用。记忆力是个好东西<br>案例1（计算阶乘）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y:x*y,<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>)) <span class="comment">#计算5!</span></span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure><p>案例2（将整数列表拼成整数）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y:x*<span class="number">10</span>+y,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><div class="hide-toggle"><div class="hide-button toggle-title"><i class="fas fa-caret-right fa-fw"></i><span>案例3（计算斐波那契）</span></div><div class="hide-content"><div class="note green icon disabled"><i class="note-icon fas fa-question"></i><p>已知斐波那契数列：1、1、2、3、5、8、13、21、34、……<br>要求：输出数列第n项的值</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据数列规律：当前项的值等于前两项的和，即在迭代过程中只要保留最近的历史（前两项元素值）即可，因此基调确定，即reduce中的func参数应该返回一个二元组，而参数seq其实对计算没用，仅用于迭代。且实际假设斐波那契序列为（增加首项0）：0,1,1,2,3,5,8,...，然后将前两项(0,1)作为reduce的initial参数，于是reduce首次迭代可以计算出第三项数值（前两项和）为1，并使func返回第二项和第三项的值(1,1)，然后第二次迭代可以计算出第四项数值为2，并使func返回第三项和第四项的值(1,2)，以此类推</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">fib=<span class="keyword">lambda</span> n:<span class="number">1</span> <span class="keyword">if</span> n==<span class="number">1</span> <span class="keyword">else</span> reduce(<span class="keyword">lambda</span> x,y:(x[<span class="number">1</span>],x[<span class="number">0</span>]+x[<span class="number">1</span>]),<span class="built_in">range</span>(n-<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>))[<span class="number">1</span>]</span><br><span class="line">print(fib(<span class="number">10</span>)) <span class="comment">#55</span></span><br></pre></td></tr></table></figure><div class="hide-toggle"><div class="hide-button toggle-title"><i class="fas fa-caret-right fa-fw"></i><span>其他实现</span></div><div class="hide-content"><p>普通递归：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span>(<span class="params">n=<span class="number">6</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span> <span class="keyword">or</span> n==<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n-<span class="number">2</span>)+Fibonacci(n-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">ret=Fibonacci(<span class="number">10</span>) <span class="comment">#由于递归层数限制，如果n取值过大，会爆栈，所以严格来说，这种写法是错误的</span></span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><p>看看大佬们是怎么写的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib1</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> n&lt;=<span class="number">2</span> <span class="keyword">and</span> <span class="number">1</span> <span class="keyword">or</span> fib1(n-<span class="number">1</span>)+fib1(n-<span class="number">2</span>) <span class="comment">#秀我一脸</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#等价于：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib2</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n&lt;=<span class="number">2</span> <span class="keyword">else</span> fib2(n-<span class="number">1</span>)+fib2(n-<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#形式再简化：</span></span><br><span class="line">fib3=<span class="keyword">lambda</span> n:<span class="number">1</span> <span class="keyword">if</span> n&lt;=<span class="number">2</span> <span class="keyword">else</span> fib3(n-<span class="number">1</span>)+fib3(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure><div class="hide-toggle"><div class="hide-button toggle-title"><i class="fas fa-caret-right fa-fw"></i><span><code>and</code>与<code>or</code></span></div><div class="hide-content"><p><code>and</code>和<code>or</code>执行布尔逻辑运算，但是在python中返回值并非<code>True</code>或<code>False</code>，其返回的是两端的比较值之一</p><p>运算规则：</p><ul><li><code>and</code>运算规则<br><ol><li>当<code>and</code>左端表达式为真时，继续对右端表达式进行计算并返回该(右端)表达式的值</li><li>当<code>and</code>左端表达式为假时，立即返回该(左端)表达式的值</li></ol></li><li><code>or</code>运算规则<br><ol><li>当<code>or</code>左端表达式为假时，继续对右端表达式进行计算并返回该(右端)表达式的值</li><li>当<code>or</code>左端表达式为真时，立即返回该(左端)表达式的值</li></ol></li></ul>两规则的第二条体现了<code>and</code>和<code>or</code>的截断作用（其右端表达式没有被计算），因此<code>and</code>和<code>or</code>又被称为“短路运算符”（再次注意只有在<code>and</code>左边为假或者<code>or</code>左边为真才会表现出该特性）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">0</span> <span class="keyword">and</span> (<span class="number">3</span>-<span class="number">2</span>)) <span class="comment">#0</span></span><br><span class="line">print(<span class="number">1</span> <span class="keyword">or</span> <span class="number">0</span>) <span class="comment">#0</span></span><br></pre></td></tr></table></figure><p>简单使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#（一）and和or单独使用（多个and或者多个or）</span></span><br><span class="line"><span class="comment">#and：从左到右扫描，返回第一个为假的表达式值，无假值则返回最后一个表达式值。简单说就是：and返回真，除非遇见一个假，则返回假</span></span><br><span class="line"><span class="comment">#or：从左到右扫描，返回第一个为真的表达式值，无真值则返回最后一个表达式值。简单说就是：or返回假，除非遇见一个真，则返回真</span></span><br><span class="line">print(<span class="number">0</span> <span class="keyword">or</span> <span class="number">0</span> <span class="keyword">or</span> <span class="number">0</span> <span class="keyword">or</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">2</span> <span class="keyword">or</span> <span class="number">0</span>) <span class="comment">#1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#（二）and-or搭配使用</span></span><br><span class="line"><span class="comment">#and和or是同级运算符，计算顺序从左到右</span></span><br><span class="line"><span class="comment">#经典案例之逻辑表达式(condition and a or b)：</span></span><br><span class="line">a,b=<span class="string">&quot;JAVA&quot;</span>,<span class="string">&quot;PYTHON&quot;</span></span><br><span class="line">print(<span class="number">1</span> <span class="keyword">and</span> a <span class="keyword">or</span> b) <span class="comment">#JAVA</span></span><br><span class="line">print(<span class="number">0</span> <span class="keyword">and</span> a <span class="keyword">or</span> b) <span class="comment">#PYTHON</span></span><br><span class="line"><span class="comment">#我们可以通过控制condition的真假，控制输出a还是输出b。语义即为：“若 真 则返回 a，否则返回 b”，等同于C++中的条件运算符(bool? a:b)，但是必须注意：a和b都必须是逻辑真的</span></span><br><span class="line"></span><br><span class="line">print(<span class="number">1</span> <span class="keyword">and</span> <span class="number">0</span> <span class="keyword">or</span> a <span class="keyword">and</span> b <span class="keyword">and</span> <span class="number">0</span> <span class="keyword">and</span> a <span class="keyword">or</span> b) <span class="comment">#b</span></span><br><span class="line"><span class="comment">#对于一个比较复杂的混合应用，没有别的办法，只能从左到右由内而外层层计算：((((((1 and 0) or a) and b) and 0) and a) or b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#由于(condition and a or b)中a和b都要满足逻辑真，这如何确保？先看个反例：</span></span><br><span class="line">a,b=[],<span class="number">1</span> <span class="comment">#a是逻辑假的，此时and-or实现的条件运算将失效</span></span><br><span class="line">print(<span class="literal">True</span> <span class="keyword">and</span> a <span class="keyword">or</span> b) <span class="comment">#1</span></span><br><span class="line">print(<span class="literal">False</span> <span class="keyword">and</span> a <span class="keyword">or</span> b) <span class="comment">#1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#还是有安全的解法的，如下（套个[]强制变成逻辑真，新的逻辑表达式变为(condition and [a] or [b])[0]）：</span></span><br><span class="line">a=<span class="string">&#x27;&#x27;</span></span><br><span class="line">b=<span class="string">&quot;MSY&quot;</span></span><br><span class="line">print((<span class="number">0</span> <span class="keyword">and</span> [a] <span class="keyword">or</span> [b])[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#通常情况下，还是建议if-else实现条件运算符的功能，以增强程序的可读性，装B除外</span></span><br><span class="line">print(<span class="string">&#x27;daiyang&#x27;</span> <span class="keyword">if</span> <span class="literal">False</span> <span class="keyword">else</span> <span class="string">&#x27;daixiaodong&#x27;</span>) <span class="comment">#daixiaodong</span></span><br></pre></td></tr></table></figure><p>最有用的一条（上面代码可以跳过）就是：</p><p class="div-border green">and-or实现条件运算：<code>(condition and [a] or [b])[0]</code>等同于<code>condition ? a : b</code></p></div></div><p>在某些语言如C中可以使用尾递归解决递归爆栈问题，虽然python本身不支持尾递归，但是存在一些解决方案可以间接实现尾递归，下面我先给出尾递归形式的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib5</span>(<span class="params">n</span>):</span> <span class="comment">#计算原理同下面循环版本的fib4</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib_iter</span>(<span class="params">n,n1,n2</span>):</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>: <span class="keyword">return</span> n2</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> fib_iter(n-<span class="number">1</span>,n2,n1+n2)</span><br><span class="line">    <span class="keyword">return</span> fib_iter(n,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#lambda形式的尾递归</span></span><br><span class="line">fib6=<span class="keyword">lambda</span> n,n1=<span class="number">1</span>,n2=<span class="number">0</span>:n2 <span class="keyword">if</span> n==<span class="number">0</span> <span class="keyword">else</span> fib6(n-<span class="number">1</span>,n2,n1+n2) <span class="comment">#同fib5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#and-or形式的尾递归</span></span><br><span class="line">fib7=<span class="keyword">lambda</span> n,n1=<span class="number">1</span>,n2=<span class="number">0</span>:n==<span class="number">0</span> <span class="keyword">and</span> n2 <span class="keyword">or</span> fib7(n-<span class="number">1</span>,n2,n1+n2) <span class="comment">#同fib6</span></span><br></pre></td></tr></table></figure><div class="hide-toggle"><div class="hide-button toggle-title"><i class="fas fa-caret-right fa-fw"></i><span>python实现尾递归</span></div><div class="hide-content"><p>在计算机中，函数调用是通过“栈”这种数据结构实现的，每调用一个函数，就会往栈中压入一个栈帧对象，其中保存着函数所对应的可执行代码（即代码对象，通常由<code>compile()</code>函数返回，可通过栈帧对象<code>frame</code>的<code>f_code</code>属性访问）、变量命名空间（包含<code>frame.f_locals</code>局部变量、<code>frame.f_globals</code>全局变量和<code>frame.f_builtins</code>内置名称）以及其他一些属性（如<code>frame.f_back</code>，表示对当前调用者而言的上一个栈帧对象），当函数执行结束，就会从栈中删除当前栈帧，如果函数没有结束就又发生了其他函数调用，栈中的帧数就会线性增加，由于栈的大小不是无限的，对于递归函数，如果递归过深，很容易导致栈溢出错误</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.getrecursionlimit()) <span class="comment">#python允许的最大递归深度：1000</span></span><br></pre></td></tr></table></figure><p>那么旧的栈帧能不能删除呢？一般来说递归调用的返回结果是要为上层函数所使用的，即递归的回溯过程通常不可避免，所以不能删除。尽管如此，由于尾递归的特殊性（尾调用由于是函数执行流的最后一步，调用结果不需要反馈给调用者，因此在这种情况下旧的栈帧可以直接销毁，此即为&quot;尾调用优化&quot;），决定了这种递归形式在执行过程中是不需要回溯的，于是可以把原本需要线性复杂度栈内存空间的执行过程用常数复杂度的空间完成，实现该优化的解释器或编译器可以使得递归本身无论调用多少次，都只占用一个栈帧。本质上尾递归和循环没什么区别，要效率，还是建议循环</p><p>大佬实现的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://code.activestate.com/recipes/474088-tail-call-optimization-decorator/"><span class="inline-tag yellow">TCO(Tail-Call Optimization)</span></a>装饰器（原理简单来说就是当发现尾递归调用的函数在栈帧中重复出现时，手动抛出异常并携带着最新调用的函数参数返回上层，从而使之后重复调用的函数栈帧被销毁）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TailRecurseException</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, args, kwargs</span>):</span></span><br><span class="line">        self.args = args</span><br><span class="line">        self.kwargs = kwargs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tail_call_optimized</span>(<span class="params">g</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This function decorates a function with tail call</span></span><br><span class="line"><span class="string">    optimization. It does this by throwing an exception</span></span><br><span class="line"><span class="string">    if it is it&#x27;s own grandparent, and catching such</span></span><br><span class="line"><span class="string">    exceptions to fake the tail call optimization.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This function fails if the decorated</span></span><br><span class="line"><span class="string">    function recurses in a non-tail context.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        f = sys._getframe()</span><br><span class="line">        <span class="keyword">if</span> f.f_back <span class="keyword">and</span> f.f_back.f_back \</span><br><span class="line">            <span class="keyword">and</span> f.f_back.f_back.f_code == f.f_code: <span class="comment">#位置1</span></span><br><span class="line">            <span class="keyword">raise</span> TailRecurseException(args, kwargs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">return</span> g(*args, **kwargs) <span class="comment">#位置2</span></span><br><span class="line">                <span class="keyword">except</span> TailRecurseException <span class="keyword">as</span> e:</span><br><span class="line">                    args = e.args</span><br><span class="line">                    kwargs = e.kwargs</span><br><span class="line">    func.__doc__ = g.__doc__</span><br><span class="line">    <span class="keyword">return</span> func</span><br></pre></td></tr></table></figure><p>使用案例（尾递归实现的阶乘计算）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@tail_call_optimized</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n, acc=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="string">&quot;calculate a factorial&quot;</span> <span class="comment">#函数__doc__文档</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> acc</span><br><span class="line">    <span class="keyword">return</span> factorial(n-<span class="number">1</span>, n*acc) <span class="comment">#位置3</span></span><br><span class="line">    </span><br><span class="line">print(factorial(<span class="number">1000</span>))</span><br></pre></td></tr></table></figure><p>解读：首先得知道装饰器的基本原理，于是有<code>factorial=tail_call_optimized(factorial)</code>，即变量名<code>factorial</code>实际指向函数<code>func</code>，而<code>func</code>内部的变量<code>g</code>实际指向函数<code>factorial</code>。在执行<code>factorial(1000)</code>时，由函数<code>func</code>构成的栈帧将首次被压入函数调用栈中，程序执行到位置1，不符合<code>if</code>条件，于是执行到位置2，再一次发生函数调用，此时由函数<code>factorial</code>构成的栈帧将被压入栈中，程序继而执行到位置3并函数调用，于是由函数<code>func</code>构成的栈帧将再次被压入栈中，然后执行到位置1发现满足条件（当前栈帧的前两个栈帧存在且上上个栈帧的代码对象和当前栈帧的代码对象相同，即发生重复调用），于是向上层抛出异常（具体返回到哪一层就看哪一层捕捉到了该异常），同时携带着最新的调用参数，显然程序将返回到第一个栈帧（即第一个函数调用）的位置2处（此时栈内就只有这一个帧了），此处异常被捕捉，由于处在一个<code>while</code>循环中，于是又来到位置2并发生函数调用，函数<code>factorial</code>构成的栈帧将被压入栈中，来到位置3并发生函数调用，函数<code>func</code>构成的栈帧将被压入栈中，判断<code>if</code>条件，再次满足条件，抛出异常…，依此类推</p><p>之前的斐波那契问题，使用TCO修饰：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib5</span>(<span class="params">n</span>):</span></span><br><span class="line"><span class="meta">    @tail_call_optimized</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib_iter</span>(<span class="params">n,n1,n2</span>):</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>: <span class="keyword">return</span> n2</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> fib_iter(n-<span class="number">1</span>,n2,n1+n2)</span><br><span class="line">    <span class="keyword">return</span> fib_iter(n,<span class="number">1</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div></div><p>最正确且效率最高的当属循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#能用循环解决的问题，尽量不要使用递归，有时候递归可以极大简化问题，那也应当在合理的递归深度范围内，否则意味着错误必将发生</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib4</span>(<span class="params">n</span>):</span></span><br><span class="line">    n1,n2=<span class="number">1</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        n1,n2,n=n2,n1+n2,n-<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n2</span><br><span class="line">  </span><br><span class="line">print(fib4(<span class="number">10000</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#顺便给出打印完整数列的方法，稍微改造上述fib函数即可</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_fib</span>(<span class="params">n</span>):</span></span><br><span class="line">    n1,n2=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> count():</span><br><span class="line">        <span class="keyword">if</span> i==n:<span class="keyword">break</span></span><br><span class="line">        print(n2,end=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        n1,n2=n2,n1+n2</span><br><span class="line"></span><br><span class="line">all_fib(<span class="number">6</span>) <span class="comment">#1,1,2,3,5,8,13,21,34,55</span></span><br></pre></td></tr></table></figure></div></div></div></div></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dytab1-4"><div class="tabs" id="dytab1-2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#dytab1-2-1">字典</button></li><li class="tab"><button type="button" data-href="#dytab1-2-2">集合</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="dytab1-2-1"><p>字典又名哈希表、散列表，实现一个哈希表需要讨论两大基本问题：地址映射和冲突处理</p><ol><li><p>地址映射<br>一个好的<code>hash</code>方法是在对象不相同的情况下能产生不相等的哈希值，这是最理想的情况，退而求次，<code>hash</code>方法应尽力将数据集合中不相同的对象均匀分布到所有可能的地址上面，即通过哈希函数应能得到一个“尽可能随机的地址”</p></li><li><p>冲突处理<br>如果两个不同对象映射到了相同的地址，将产生冲突，无论怎样精心构造<code>hash</code>函数，这种冲突都不可避免，但是可以解决，如开放定址（探测再散列）、再哈希、链式、公共溢出区，其中链表法是比较常见的冲突处理办法，python采用开放定址办法</p></li></ol><p>因此当我们对字典成员对象进行操作时，需要能够计算对象的哈希并比较对象之间的异同，特别是用户自定义类型，需要用户自己实现。先说说几个特殊方法（也叫“魔法方法”，以双下划线开头且以双下划线结尾，这些方法会在进行特定操作时被自动调用，譬如运算符重载方法，如上面提到过的对象比较<code>==</code>相当于调用对象的<code>__eq__()</code>方法、加法<code>+</code>相当于调用对象的<code>__add__()</code>方法等）：</p><ul><li><code>object.__hash__(self)</code><br><p>注：这是<code>object</code>基类所定义的哈希方法签名，下同</p><p><code>__hash__()</code>会在以下情况被调用：1）由内置方法<code>hash()</code>调用（<code>hash(obj)</code>即等同于<code>obj.__hash__()</code>），2）对散列集合成员进行操作时被调用，散列集合类型包括<code>dict</code>、<code>set</code>和<code>frozenset</code>。注意<code>__hash__()</code>应当返回一个整数，对于用户自定义类型，我们建议将对象的不同组件打包进元组，然后计算元组的哈希值，譬如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>((self.name, self.sex, self.age))</span><br></pre></td></tr></table></figure></li><li><code>object.__getattribute__(self, name)</code><br><p>实例属性访问时始终会调用<code>__getattribute__()</code>方法（类属性访问则不会调用之，若类属性不存在也将触发<code>AttributeError</code>异常，据我所知，这应该是<code>__get__()</code>引发的），如果还定义了<code>__getattr__()</code>，则除非<code>__getattribute__()</code>显式调用它或者引发了<code>AttributeError</code>异常（属性不存在的默认行为），否则不会调用后者。为了防止在此方法中陷入无穷递归，其实现应始终调用具有相同名称的基类方法来访问其所需的任何属性，如<code>object.__getattribute__(self, name)</code>（之所以要传入当前实例<code>self</code>，是因为在类上访问方法返回的是“非绑定方法”，而在实例上访问方法返回的则是“绑定方法”，所谓绑定，即绑定实例，实例方法访问返回的其实是一个闭包对象，譬如<code>x.method</code>返回的相当于<code>partial(method,self=x)</code>），不过一般还是使用<code>super().method(arg)</code>实现基类方法调用。下面的错误示例将导致无限递归（但受最大递归层数限制）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self,item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__dict__[item] <span class="comment">#__dict__中存放着对象上绑定着的实例属性，若你想从中取值，self.__dict__又将调用self.__getattribute__()方法，从而陷入无穷递归</span></span><br><span class="line">      </span><br><span class="line">print(A(<span class="string">&#x27;a&#x27;</span>).name) <span class="comment">#RecursionError: maximum recursion depth exceeded while calling a Python object</span></span><br></pre></td></tr></table></figure>修改：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self,item</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>(A,self).__getattribute__(item) <span class="comment">#在python3中也可以简写为super()，完全等同于super(A,self)</span></span><br></pre></td></tr></table></figure><div class="hide-toggle"><div class="hide-button toggle-title"><i class="fas fa-caret-right fa-fw"></i><span>遇到的问题</span></div><div class="hide-content"><p>我写了下面的代码，但是对输出感到困惑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self,item</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;属性访问:&#x27;</span>,item)</span><br><span class="line">        print(<span class="string">&#x27;object的__getattr__方法:&#x27;</span>,<span class="built_in">super</span>(A,self).__getattr__) <span class="comment">#？</span></span><br><span class="line">        print(<span class="built_in">super</span>(A,self).__getattr__(item)) <span class="comment">#super到底发生了什么？</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(A,self).__getattribute__(item)</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self,item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;daiyang&#x27;</span></span><br><span class="line">      </span><br><span class="line">print(A(<span class="string">&#x27;a&#x27;</span>).name)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">属性访问: name</span></span><br><span class="line"><span class="string">daiyang</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>首先我们来看一下<code>super(…)</code>的原理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">super</span>(<span class="params">cls, inst</span>):</span></span><br><span class="line">    mro = inst.__class__.mro()</span><br><span class="line">    <span class="keyword">return</span> mro[mro.index(cls) + <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>MRO（method resolution order）列表记录了类继承体系中的成员解析顺序，每个类都有这样的属性，可以用来解决python中<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/czaiz/p/7772194.html">钻石继承</a>的难题，核心就在于它将非线性的父类继承顺序通过C3算法转换成线性顺序。因此以后千万不要再单纯地认为<code>super()</code>返回的就是当前类的父类了，这不一定（一般单继承则不用怀疑，肯定是父类啦），也可能是兄弟类，譬如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">      print(<span class="string">&quot;enter Base&quot;</span>)</span><br><span class="line">      print(<span class="string">&quot;leave Base&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;enter A&quot;</span>)</span><br><span class="line">        <span class="comment">#print(self.__class__.mro()) #[&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.Base&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span></span><br><span class="line">        <span class="built_in">super</span>(A,self).__init__() <span class="comment">#根据MRO列表可知，super(A,self)返回的是类B，注意了，这也是为什么说super()返回的不一定是父类，此处返回的是类A的兄弟B</span></span><br><span class="line">        print(<span class="string">&quot;leave A&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;enter B&quot;</span>)</span><br><span class="line">        <span class="comment">#print(self.__class__.mro()) #[&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.Base&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span></span><br><span class="line">        <span class="built_in">super</span>(B,self).__init__() <span class="comment">#根据MRO列表可知，super(B,self)返回的是类Base</span></span><br><span class="line">        print(<span class="string">&quot;leave B&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A,B</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;enter C&quot;</span>)</span><br><span class="line">        <span class="comment">#print(self.__class__.mro()) #[&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.Base&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span></span><br><span class="line">        <span class="built_in">super</span>(C,self).__init__() <span class="comment">#根据MRO列表可知，super(C,self)返回的是类A，准确来说返回的是绑定了self实例的超类对象（bound super object），可以通过__self__属性查看绑定的实例，super(C,self).__self__</span></span><br><span class="line">        print(<span class="string">&quot;leave C&quot;</span>)</span><br><span class="line"></span><br><span class="line">c=C()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">enter C</span></span><br><span class="line"><span class="string">enter A</span></span><br><span class="line"><span class="string">enter B</span></span><br><span class="line"><span class="string">enter Base</span></span><br><span class="line"><span class="string">leave Base</span></span><br><span class="line"><span class="string">leave B</span></span><br><span class="line"><span class="string">leave A</span></span><br><span class="line"><span class="string">leave C</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><code>super(cls,inst)</code>有两种用法，一是上述所说，参数1是类，参数2是实例，且必须满足<code>isinstance(inst,cls)</code>为<code>True</code>的条件，二是参数2也可以是一个类，此时则必须满足<code>issubclass(inst,cls)</code>为<code>True</code>的条件，两者返回的都是绑定了<code>inst</code>的超类对象</p><p>回到原题，现在我们知道<code>super(A,self).__getattribute__(item)</code>就等同于<code>object.__getattribute__(self,item)</code>，对于<code>__getattr__</code>也是一样，问题在于<code>object</code>类并未定义<code>__getattr__()</code>方法啊（参考书[1]出来挨打O(∩_∩)O），当访问一个不存在的属性（<code>super(A,self).__getattr__</code>）时将引发<code>AttributeError</code>异常，注意这个异常是在类A的<code>__getattribute__()</code>内部引发的，而由于定义了<code>__getattr__()</code>，因此程序最终输出了字符串<code>daiyang</code>。我们可以捕捉该异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self,item</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;属性访问:&#x27;</span>,item)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(<span class="string">&#x27;object的__getattr__方法:&#x27;</span>,<span class="built_in">super</span>(A,self).__getattr__)</span><br><span class="line">        <span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">&#x27;异常捕捉:&#x27;</span>,e)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(A,self).__getattribute__(item)</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self,item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;daiyang&#x27;</span></span><br><span class="line">      </span><br><span class="line">print(A(<span class="string">&#x27;a&#x27;</span>).name)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">属性访问: name</span></span><br><span class="line"><span class="string">异常捕捉: &#x27;super&#x27; object has no attribute &#x27;__getattr__&#x27;</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div></div></li><li><code>object.__getitem__(self,key)</code><br>执行<code>self[key]</code>时被调用，对于序列类型，接受的键应该是整数和切片对象，请注意，负索引的特殊解释（如果类希望模拟序列类型）取决于<code>__getitem__()</code>方法，如果key是不合适的类型，则可能引发<code>TypeError</code>，如果是序列的索引集合之外的值，则应引发<code>IndexError</code>，对于映射类型，如果缺少键（不在容器中），则应引发<code>KeyError</code></li><li><code>object.__setitem__(self,key,value)</code><br>执行<code>self[key]=value</code>时被调用</li></ul><p>一般我们使用内置的标准字典或集合，甚至不需要子类化进行任何定制，即使有其它方面的需求，也有第三方库提供的数据结构供我们使用，譬如<code>defaultdict</code>、<code>OrderedDict</code>。但是自定义成员对象并通过字典等存取时，基本都得重写<code>__hash__()</code>和<code>__eq__()</code>方法，这一点很重要，现假设我们要向集合中存放自定义类对象，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">man</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,sex,age</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.sex=sex</span><br><span class="line">        self.age=age</span><br><span class="line">        </span><br><span class="line">man1=man(<span class="string">&#x27;muggle&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="number">22</span>)</span><br><span class="line">man2=man(<span class="string">&#x27;muggle&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="number">22</span>)</span><br><span class="line"><span class="built_in">hash</span>(man1)==<span class="built_in">hash</span>(man2) <span class="comment">#False</span></span><br></pre></td></tr></table></figure><p>如你所见，两个“相同”（只要姓名、性别、年龄都一样，我们就认为两个人是同一人啊）对象的哈希值不一样，将它们存放到字典<code>s=set([man1,man2])</code>中的后果就是，字典<code>s</code>中竟然“有两个一毛一样的人”，这实在是匪夷所思，原因即在于，执行映射类容器相关操作的时候（譬如向字典中添加一个键值对，或查询某键的值），会先后调用键（此处<code>man</code>实例对象就是“键”）对象的<code>__hash__()</code>以及<code>__eq__()</code>，现在我们两个对象<code>man1</code>和<code>man2</code>的哈希值不一样，而且默认的<code>__eq__</code>方法也判断两个对象不相同，尽管哈希值不一样的键也有可能落到同一个“桶”里面，但是现在这两对象也不<code>equal</code>啊，于是这两个对象必然不同且同时存在于集合中，解决的办法就是为<code>man</code>类重写<code>__hash__()</code>和<code>__eq__()</code>（一般修改其中任意一个方法，另一个也要相应修改），它们必须满足以下两大规则：</p><ol><li>如果两个对象相同，即<code>obj1.equal(obj2)==True</code>，则两个对象的哈希地址映射也必须相同，即<code>hash(obj1)==hash(obj2)</code>（否则对象明明存在于容器中，却找不到）</li><li>如果两个对象的哈希地址映射不同，即<code>hash(obj1)!=hash(obj2)</code>，则两个对象必须不相同，即<code>obj1.equal(obj2)==False</code>（否则容器中将存在同一对象的多个“副本”，浪费存储资源）</li></ol><p>修改后的<code>man</code>类已满足上述规则：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">man</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,sex,age</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.sex=sex</span><br><span class="line">        self.age=age</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span>(<span class="params">self</span>):</span> <span class="comment">#用姓名、性别和年龄判断两个人是否相同，若相同，此时他们的哈希也必然相同，但是相同的哈希也可能对应不同的人，此时就要靠equal方法来判断了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>((self.name, self.sex, self.age))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self,other</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.name==other.name <span class="keyword">and</span> self.sex==other.sex <span class="keyword">and</span> self.age==other.age:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>关于<code>__hash__()</code>和<code>__eq__()</code>，官方文档中有非常明确的指示：</p><ol><li><p>如果重写了<code>__eq__()</code>，必须重写<code>__hash__()</code>，因为两个“相同”对象的哈希地址映射不一定相同，为了确保这一点，必须重写<code>__hash__()</code>加以保证。反之，如果重写了<code>__hash__()</code>，也必须重写<code>__eq__()</code>，因为两个哈希地址相同的对象，如果是相同对象，<code>__eq__()</code>也必须相同，否则不同，若两个对象哈希地址不同，则<code>__eq__()</code>必须不同，否则出错</p></li><li><p>如果只重写了<code>__eq__()</code>，那么该类对象将不能用于映射类容器，因为此时<code>__hash__()</code>将隐式地被赋为<code>None</code>，即此时<code>__hash__</code>方法失效，该类实例将不可哈希。如果想使用父类的<code>__hash__()</code>，需要明确说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    __hash__=A.__hash__</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self,other</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p>如果没有重写<code>__eq__()</code>，又希望使<code>__hash__()</code>失效，应明确赋值为<code>None</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>():</span></span><br><span class="line">    __hash__=<span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">s=<span class="built_in">set</span>()</span><br><span class="line">s.add(A()) <span class="comment">#TypeError: unhashable type: &#x27;A&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>如果可变对象的类实现了<code>__eq__()</code>，就不必再为之重写<code>__hash__()</code>了，因为即使你重写了一个看似不会抛异常的<code>__hash__()</code>，但是由于对象可变，它总是会出错（可变对象就不能作为字典或集合的“键”）。举个例子，我们子类化列表，重写<code>__eq__()</code>，规定只要新列表的第一个元素相同，那么两个新列表就相同，同时重写<code>__hash__()</code>，使它返回新列表第一个元素的哈希值，这一设定是合理的，并假设新列表的第一个元素我们总是使它是可哈希的，我们创建一个新列表的实例<code>a=['muggle']</code>，设对象<code>a</code>的哈希地址为<code>addr1</code>，将其添加到集合<code>s</code>中，于是<code>s={['muggle'],}</code>，我们修改<code>a</code>的第一个元素值为<code>'jingjing'</code>，结果就是<code>addr1</code>地址上存放的字符串从<code>muggle</code>变成了<code>jingjing</code>，现在新建一个新列表实例<code>b=['jingjing']</code>，设对象<code>b</code>的哈希地址为<code>addr2</code>，且<code>addr1!=addr2</code>，将<code>b</code>也添加到<code>s</code>中，于是<code>s={['jingjing'],['jingjing'],}</code>，可是根据我们的<code>__eq__</code>和<code>__hash__</code>方法，显然有<code>a==b</code>以及<code>hash(a)==hash(b)</code>成立啊，即这两个对象“完全相同”，而不该在集合中重复出现！代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span>(<span class="params"><span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,*args</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">            self.append(i)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self,index,value</span>):</span></span><br><span class="line">        self[index]=value</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(self[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self,other</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self[<span class="number">0</span>]==other[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">a=MyArray(<span class="string">&#x27;muggle&#x27;</span>)</span><br><span class="line">s=<span class="built_in">set</span>()</span><br><span class="line">s.add(a) <span class="comment">#s=&#123;[&#x27;muggle&#x27;]&#125;</span></span><br><span class="line">a[<span class="number">0</span>]=<span class="string">&#x27;jingjing&#x27;</span> <span class="comment">#&#123;[&#x27;jingjing&#x27;]&#125;</span></span><br><span class="line">b=MyArray(<span class="string">&#x27;jingjing&#x27;</span>)</span><br><span class="line">s.add(b) <span class="comment">#&#123;[&#x27;jingjing&#x27;], [&#x27;jingjing&#x27;]&#125;</span></span><br><span class="line"><span class="built_in">hash</span>(a)==<span class="built_in">hash</span>(b) <span class="comment">#True</span></span><br><span class="line">a==b <span class="comment">#True</span></span><br></pre></td></tr></table></figure></li><li><p>用户自定义类默认的<code>__hash__()</code>和<code>__eq__()</code>继承自基类<code>object</code>，它们都是非常严格的，判断两个实例相不相同是根据唯一身份标识<code>id</code>，哈希也是对身份标识进行哈希</p></li></ol><p>字典的使用和一些注意点：</p><ol><li><p>Python2中判断某个<code>key</code>是否存在字典中可使用<code>has_key()</code>方法，另外一种方式是使用<code>in</code>关键字（<code>key in dict</code>），推荐使用后者，因为<code>in</code>的处理速度更快，另一个原因是<code>has_key()</code>这个方法在Python3被移除了</p></li><li><p>获取字典中某个键的值，两种方式：<code>dict[key]</code>或<code>dict.get(key[, default])</code>，前者简便但如果键不存在会导致KeyError异常，为了避免异常不得不先进行键存在性的判断，或者捕捉异常，如果不想手动捕捉异常那就子类化字典并重新定义字典的<code>__missing__()</code>方法以避免异常的抛出，该特殊方法只有在使用<code>dict[key]</code>且<code>key</code>不存在时才会被调用。一般我们使用<code>dict.get()</code>方法，键不存在则返回<code>None</code>（可通过<code>default</code>参数修改该默认值），但并不会修改底层数据，这不同于<code>defaultdict</code>类或<code>dict.setdefault(key,default)</code>，示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDict</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span>(<span class="params">self,key</span>):</span></span><br><span class="line">        <span class="comment">#self[key]=0 #通常都会这么做，修改底层数据，否则就没有意义了，因为还不如直接通过dict.get(key,default)设置缺省值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">d=MyDict()</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="string">&#x27;11422134431&#x27;</span>: <span class="comment">#计数器</span></span><br><span class="line">    d[k]+=<span class="number">1</span></span><br><span class="line">print(d) <span class="comment">#&#123;&#x27;1&#x27;: 4, &#x27;4&#x27;: 3, &#x27;2&#x27;: 2, &#x27;3&#x27;: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#或者：</span></span><br><span class="line">d=<span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="string">&#x27;11422134431&#x27;</span>:</span><br><span class="line">    d[k]=d.get(k,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">print(d) <span class="comment">#&#123;&#x27;1&#x27;: 4, &#x27;4&#x27;: 3, &#x27;2&#x27;: 2, &#x27;3&#x27;: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#或者：</span></span><br><span class="line">d=&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="string">&#x27;11422134431&#x27;</span>:</span><br><span class="line">    d[k]=d.setdefault(k,<span class="number">0</span>)+<span class="number">1</span> <span class="comment">#setdefault(key,default=None)和get(key,default=None)方法用法类似，区别是，如果键不存在于字典中，将会添加键并将值设为默认值，即会直接修改底层数据。如果字典中包含有给定键，则返回键所对应的值，否则返回为键设置的default值</span></span><br><span class="line">print(d) <span class="comment">#&#123;&#x27;1&#x27;: 4, &#x27;4&#x27;: 3, &#x27;2&#x27;: 2, &#x27;3&#x27;: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#或者：</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">d=defaultdict(<span class="built_in">int</span>) <span class="comment">#defaultdict类的初始化函数接受一个工厂函数作为参数，作用是当key不存在时，返回的是工厂函数的默认值，比如list对应[]，str对应的是空字符串，set对应set()，int对应0</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="string">&#x27;11422134431&#x27;</span>:</span><br><span class="line">    d[k]+=<span class="number">1</span></span><br><span class="line">print(d) <span class="comment">#defaultdict(&lt;class &#x27;int&#x27;&gt;, &#123;&#x27;1&#x27;: 4, &#x27;4&#x27;: 3, &#x27;2&#x27;: 2, &#x27;3&#x27;: 2&#125;)</span></span><br></pre></td></tr></table></figure></li><li><p>创建字典的几种方式：</p><ul><li><p><code>dict()</code>实例化字典对象（默认无参数时创建一个空字典，也可以直接写<code>d={}</code>），可以传递任意数量的关键字参数，或者是一个二元元组列表以及任意数量的关键字参数，再或者是一个字典和任意数量的关键字参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data=[(<span class="string">&quot;animal&quot;</span>, <span class="string">&quot;bear&quot;</span>),(<span class="string">&quot;animal&quot;</span>, <span class="string">&quot;duck&quot;</span>),(<span class="string">&quot;plant&quot;</span>, <span class="string">&quot;cactus&quot;</span>),(<span class="string">&quot;vehicle&quot;</span>, <span class="string">&quot;speed boat&quot;</span>),(<span class="string">&quot;vehicle&quot;</span>, <span class="string">&quot;school bus&quot;</span>)]</span><br><span class="line"><span class="built_in">dict</span>() <span class="comment">#&#123;&#125;，空字典</span></span><br><span class="line"><span class="built_in">dict</span>(data) <span class="comment">#&#123;&#x27;animal&#x27;: &#x27;duck&#x27;, &#x27;plant&#x27;: &#x27;cactus&#x27;, &#x27;vehicle&#x27;: &#x27;school bus&#x27;&#125;，通常是一个二元元组列表，实际上只要是可迭代的对象且对象元素也是可迭代对象且这些元素长度一律为2的都可以</span></span><br><span class="line"><span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])) <span class="comment">#&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span></span><br><span class="line"><span class="built_in">dict</span>(([<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>],[<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>]),c=<span class="number">3</span>) <span class="comment">#&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span></span><br><span class="line"><span class="built_in">dict</span>(&#123;<span class="number">1</span>:<span class="number">2</span>,<span class="number">3</span>:<span class="number">4</span>&#125;,last=<span class="number">6</span>) <span class="comment">#&#123;1: 2, 3: 4, &#x27;last&#x27;: 6&#125;，通常是一个字典，实际上只要是mapping类型都可以，python标准mapping就是dict</span></span><br><span class="line"><span class="built_in">dict</span>(name=<span class="string">&#x27;daiyang&#x27;</span>,sex=<span class="string">&#x27;male&#x27;</span>) <span class="comment">#&#123;&#x27;name&#x27;: &#x27;daiyang&#x27;, &#x27;sex&#x27;: &#x27;male&#x27;&#125;，关键字参数，此时字典的关键字全部是字符串</span></span><br></pre></td></tr></table></figure></li><li><p><code>dict.fromkeys(seq[,initial])</code>根据序列<code>seq</code>构造字典，列表中的元素将作为键，需另外指定初始值<code>initial</code>，若未指定则值全部为<code>None</code>，<code>fromkeys()</code>完全可以用字典生成式实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d=[<span class="string">&#x27;first&#x27;</span>,<span class="string">&#x27;second&#x27;</span>,<span class="string">&#x27;third&#x27;</span>]</span><br><span class="line"><span class="built_in">dict</span>.fromkeys(d,<span class="number">8</span>) <span class="comment">#&#123;&#x27;first&#x27;: 8, &#x27;second&#x27;: 8, &#x27;third&#x27;: 8&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>字典生成式，现在有两个序列，分别为一一对应的键值序列，将其组装为字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="string">&#x27;first&#x27;</span>,<span class="string">&#x27;second&#x27;</span>,<span class="string">&#x27;third&#x27;</span>]</span><br><span class="line">b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">d=&#123;k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">zip</span>(a,b)&#125; <span class="comment">#&#123;&#x27;first&#x27;: 1, &#x27;second&#x27;: 2, &#x27;third&#x27;: 3&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>字典更新</p><ul><li><p><code>d.update(other_d)</code>，用另一个字典<code>other_d</code>更新原字典<code>d</code>，对于原字典中不存在的键值对直接增添，若存在，则更新旧值为新值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d=&#123;<span class="string">&#x27;1&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;2&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;3&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line">d.update(&#123;<span class="string">&#x27;1&#x27;</span>:<span class="number">11</span>,<span class="string">&#x27;4&#x27;</span>:<span class="number">4</span>,<span class="string">&#x27;5&#x27;</span>:<span class="number">5</span>&#125;) <span class="comment">#&#123;&#x27;1&#x27;: 11, &#x27;2&#x27;: 2, &#x27;3&#x27;: 3, &#x27;4&#x27;: 4, &#x27;5&#x27;: 5&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>d[key]=value</code>方式用于添加一个新的键值对或者更新某个键的旧值</p></li></ul></li><li><p>字典元素删除</p><ul><li><p>使用<code>d.pop(key[,default])</code>删除键值对，可以指定默认的返回值，可以避免由于键不存在而导致的KeyError：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment">#d.pop(&#x27;e&#x27;) #KeyError: &#x27;e&#x27;</span></span><br><span class="line">d.pop(<span class="string">&#x27;e&#x27;</span>,<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>popitem()</code>返回并删除字典中的最后一对键和值（这里没搞懂，最后一对键值是怎么确定的？）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line">d.popitem()</span><br><span class="line">print(d) <span class="comment">#&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>del</code>执行删除，既可以删除整个字典，也可以删除字典的某个键值对，如果删除的键不存在，则会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">del</span> d[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> d <span class="comment">#再要访问d，将报错：NameError: name &#x27;d&#x27; is not defined</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>字典遍历<br><code>d.keys()</code>、<code>d.values()</code>、<code>d.items()</code>，其中<code>items()</code>多用于<code>for</code>循环遍历：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> d.items():</span><br><span class="line">    print(k,v)</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dytab1-2-2"><p>和字典一样，集合虽然可以迭代，但它们都是无序的，不支持切片和index（数值下标）索引</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tip fas fa-quote-left"><p>[1] <a target="_blank" rel="noopener external nofollow noreferrer" href="https://pan.baidu.com/s/17r__wNMxIXTMWhglf3wyuw" title="密码：1y2r"><span style="color:red">Python参考手册</span></a> 第4版 修订版 [美] 大卫·M.比兹利（David M.Beazley）著，谢俊，杨越，高伟 译</p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">Muggledy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://muggledy.github.io/posts/5311/">https://muggledy.github.io/posts/5311/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://muggledy.github.io" target="_blank">Muggledy's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210323121638.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Gitalk</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@v0.1/img/20210202152223.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210328224511.gif"' alt="avatar"><div class="author-info__name">Muggledy</div><div class="author-info__description">孤筏重洋</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/muggledy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/muggledy" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210209044239.jpg" rel="external nofollow noreferrer" target="_blank" title="WeChat"><i class="fab fa-weixin"></i></a><a class="social-icon" href="mailto:zgjsycfndy2015@163.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=3101266674&amp;site=qq&amp;menu=yes" rel="external nofollow noreferrer" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><a href="/note/"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></a><div class="announcement_content">本人的更新是极慢的~</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BA%AB%E4%BB%BD%E4%B8%8E%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">对象的身份与类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">类型的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E4%B8%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">对象的引用与复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">基础数据类型</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/65257/" title="魔改部分记录"><img src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210328214628.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210328224519.jpg"' alt="魔改部分记录"></a><div class="content"><a class="title" href="/posts/65257/" title="魔改部分记录">魔改部分记录</a><time datetime="2021-03-24T16:00:00.000Z" title="发表于 2021-03-25 00:00:00">2021-03-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/17177/" title="Hexo博客简易配置"><img src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210217121829.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210328224519.jpg"' alt="Hexo博客简易配置"></a><div class="content"><a class="title" href="/posts/17177/" title="Hexo博客简易配置">Hexo博客简易配置</a><time datetime="2021-02-05T16:00:00.000Z" title="发表于 2021-02-06 00:00:00">2021-02-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By Muggledy</div><div class="footer_custom_text"><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io/zh-cn/"><img src="https://img.shields.io/badge/Frame-Hexo-blue"></a>&nbsp;<a target="_blank" rel="noopener external nofollow noreferrer" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-brightgreen"></a>&nbsp;<a target="_blank" rel="noopener external nofollow noreferrer" href="https://pages.github.com/"><img src="https://img.shields.io/badge/Hosted-Github-red"></a>&nbsp;<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsdelivr-blueviolet"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v1.2/js/utils.js"></script><script src="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v1.4/js/main.js"></script><script src="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v1.2/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v1.2/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>document.querySelectorAll("#article-container span.katex-display").forEach(a=>{btf.wrap(a,"div","","katex-wrap")})</script><script>document.getElementsByClassName("mermaid").length&&(window.mermaidJsLoad?mermaid.init():getScript("https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js").then(()=>{window.mermaidJsLoad=!0,mermaid.initialize({theme:"default"}),mermaid.init()}))</script><script>function loadValine(){function e(){new Valine(Object.assign({el:"#vcomment",appId:"b7x9hYzkDTy4reR4khezoDcf-gzGzoHsz",appKey:"ReeSRhiVzefUKIsJwSvUD6qV",placeholder:"快来评论吧(请注意“最新评论”只关联了Gitalk评论系统哦)~",avatar:"monsterid",meta:"nick,mail,link".split(","),pageSize:"10",lang:"zh-CN",recordIP:!1,serverURLs:"",emojiCDN:"",emojiMaps:"",enableQQ:!0,path:window.location.pathname,requiredFields:["nick,mail"],visitor:!1,master:"5f452633ebd48518f8778c240d946335".split(","),friends:"a483c79213701a5644bec62de88f974d,34c64a0cb78287b2ae889cda5d9d2a91,574fbd33aa74a09d671f4608af20fd2b".split(",")},null))}"function"==typeof Valine?e():getScript("https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js").then(e)}{function loadOtherComment(){loadValine()}setTimeout(loadValine,0)}</script><script>function addGitalkSource(){const e=document.createElement("link");e.rel="stylesheet",e.href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css",document.getElementsByTagName("head")[0].appendChild(e)}function loadGitalk(){function e(){new Gitalk(Object.assign({clientID:"05956758b57064d95a57",clientSecret:"3c4ddd74e671e3d79aac8417e708f69ff93b3e28",repo:"muggledy.github.io",owner:"muggledy",admin:["muggledy"],id:"f957a824741ca8a9f7319cbd51d0083d",language:"zh-CN",perPage:10,distractionFreeMode:!1,pagerDirection:"last",createIssueManually:!1,updateCountCallback:commentCount},null)).render("gitalk-container")}"function"==typeof Gitalk?e():(addGitalkSource(),getScript("https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js").then(e))}function commentCount(e){let t=document.querySelector("#post-meta .gitalk-comment-count");t&&(t.innerHTML=e)}{function loadOtherComment(){loadGitalk()}loadGitalk()}</script></div><script>window.addEventListener("load",()=>{const e=()=>{fetch("https://api.github.com/repos/muggledy/muggledy.github.io/issues/comments?sort=updated&direction=desc&per_page=6&page=1",{headers:{Accept:"application/vnd.github.v3.html+json"}}).then(e=>e.json()).then(e=>{(e=>{let a="";Promise.all(e.map(e=>fetch(e.url).then(e=>e.json()).then(e=>"utterances-bot"===e.user.login?(a=e.body.match(/https?\:\/\/[^\" ]+/gi).slice(-1),a[0]):(a=e.body.match(/https?\:\/\/[^\" ]+/i),a[0])))).then(a=>{e=e.map((e,t)=>({...e,url:a[t]})),saveToLocal.set("github-newest-comments",JSON.stringify(e),5/1440),t(e)})})(e.map(e=>{return{avatar:e.user.avatar_url,content:(t=e.body_html,""===t||(t=(t=(t=(t=t.replace(/<img.*?src="(.*?)"?[^\>]+>/gi,"[图片]")).replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi,"[链接]")).replace(/<pre><code>.*?<\/pre>/gi,"[代码]")).replace(/<[^>]+>/g,"")).length>150&&(t=t.substring(0,150)+"..."),t),nick:e.user.login,url:e.issue_url,date:e.updated_at,githubUrl:e.html_url};var t}))}).catch(e=>{document.querySelector("#card-newest-comments .aside-list").innerHTML="无法获取评论，请确认相关配置是否正确"})},t=e=>{let t="";if(e.length)for(let a=0;a<e.length;a++){t+="<div class='aside-list-item'>";{const n="src";t+=`<a href='${e[a].url}' class='thumbnail'><img ${n}='${e[a].avatar}' alt='${e[a].nick}'></a>`}t+=`<div class='content'>\n        <a class='comment' href='${e[a].url}'>${e[a].content}</a>\n        <div class='name'><span>${e[a].nick} / </span><time datetime="${e[a].date}">${btf.diffDate(e[a].date,!0)}</time></div>\n        </div></div>`}else t+="没有评论";let a=document.querySelector("#card-newest-comments .aside-list");a.innerHTML=t,window.lazyLoadInstance&&window.lazyLoadInstance.update(),window.pjax&&window.pjax.refresh(a)},a=()=>{if(document.querySelector("#card-newest-comments .aside-list")){const a=saveToLocal.get("github-newest-comments");a?t(JSON.parse(a)):e()}};a(),document.addEventListener("pjax:complete",a)})</script><script src="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v1.2/js/t_chart.js"></script><script src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/data/funny_title/funny-title-js.js"></script><script async src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/data/font_animal/font_animal.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v1.2/js/cal_rs.js"></script><script src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/data/visitors_map/vis_m.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#web_bg","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:send",(function(){if("object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="dyminimenu"><ul><li onclick="wll_menu(1)"><span>📝 添加mini便签</span></li><li onclick="wll_menu(2)"><span>🆑 清空当前页面</span></li></ul></div><script data-pjax>function history_calendar_injector_config(){var i=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载history_calendar"),i.insertAdjacentHTML("afterbegin",'<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>')}document.getElementsByClassName("sticky_layout")[0]&&"/"===location.pathname&&history_calendar_injector_config()</script><script data-pjax src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script></body><script async data-pjax>IsPC()&&btf.isJqueryLoad(image_preview_wrapper),btf.isJqueryLoad(dybubblefn)</script></html>