<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Python基础 - 面向对象编程 | Muggledy's Blog</title><meta name="keywords" content="Python"><meta name="author" content="Muggledy"><meta name="copyright" content="Muggledy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="类是创建新对象类型的机制，当解决一个问题的时候，面向对象会把事物抽象成对象的概念，就是说这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题得到解决..."><meta property="og:type" content="article"><meta property="og:title" content="Python基础 - 面向对象编程"><meta property="og:url" content="https://muggledy.top/posts/22901/index.html"><meta property="og:site_name" content="Muggledy&#39;s Blog"><meta property="og:description" content="类是创建新对象类型的机制，当解决一个问题的时候，面向对象会把事物抽象成对象的概念，就是说这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题得到解决..."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://i.loli.net/2021/09/16/tdDuVfFBgy5bGpr.jpg"><meta property="article:published_time" content="2021-05-01T13:05:41.000Z"><meta property="article:modified_time" content="2021-05-05T15:36:03.000Z"><meta property="article:author" content="Muggledy"><meta property="article:tag" content="Python"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://i.loli.net/2021/09/16/tdDuVfFBgy5bGpr.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210207091812.png"><link rel="canonical" href="https://muggledy.top/posts/22901/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v5.7/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:{limitDay:500,position:"top",messagePrev:"这篇文章已经发表了",messageNext:"天了，其中某些内容可能已经过时。"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: Muggledy",link:"链接: ",source:"来源: Muggledy's Blog",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!0,isToc:!0,postUpdate:"2021-05-05 23:36:03"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,n={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(n))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=(new Date).getHours();void 0===t?o<=6||o>=18?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode();const a=saveToLocal.get("aside-status");void 0!==a&&("hide"===a?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"))})(window)</script><link rel="stylesheet" href="/css/mystyle.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/data/font_awesome/font-awesome-animation.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/data/button/buttons.min.css"><script src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@v0.2/data/katong_font/katong-font.js"></script><script src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@v0.9/data/img_preview/article_img_preview.js"></script><script src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@v1.0/data/bubble/bubble.js"></script><script src="https://cdn.staticfile.org/moment.js/2.24.0/moment.js"></script><script src="https://cdn.jsdelivr.net/npm/echarts@5.1.2/dist/echarts.min.js"></script><script src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@latest/data/is_pc/is-pc-etc.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@v3.1/data/hint/hint.min.css"><script>IsPC()&&loadJS("/live2d-widget/autoload.js",(function(){}))</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Muggledy's Blog" type="application/atom+xml"></head><div class="dyminibox"></div><body><div class="dy-show-cbg" id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@v0.1/img/20210202152223.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@latest/img/20210328224511.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-book"></i> <span>文章</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child" style="left:-73.89999999999999px"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="fa-fw fas fa-archive faa-tada"></i> <span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="fa-fw fas fa-tags faa-tada"></i> <span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-folder-open faa-tada"></i> <span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart card-announcement-animation"></i> <span>关于</span></a></div><div class="menus_item"><a class="site-page" href="/note/"><i class="fa-fw fas fa-bullhorn"></i> <span>公示</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i> <span>更多</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child" style="left:-90.69999999999999px"><li><a class="site-page child faa-parent animated-hover" href="/gallery/"><i class="fa-fw fas fa-image faa-tada"></i> <span>图册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><i class="fa-fw fas fa-video faa-tada"></i> <span>电影</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:void(0);" rel="external nofollow noreferrer" onclick="dogo()"><i class="fa-fw fas fa-layer-group faa-tada"></i> <span>随便看看</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@v2.1/compress/16.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Muggledy's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw faa-wrench animated"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-book"></i> <span>文章</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child" style="left:-73.89999999999999px"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="fa-fw fas fa-archive faa-tada"></i> <span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="fa-fw fas fa-tags faa-tada"></i> <span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-folder-open faa-tada"></i> <span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart card-announcement-animation"></i> <span>关于</span></a></div><div class="menus_item"><a class="site-page" href="/note/"><i class="fa-fw fas fa-bullhorn"></i> <span>公示</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i> <span>更多</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child" style="left:-90.69999999999999px"><li><a class="site-page child faa-parent animated-hover" href="/gallery/"><i class="fa-fw fas fa-image faa-tada"></i> <span>图册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><i class="fa-fw fas fa-video faa-tada"></i> <span>电影</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:void(0);" rel="external nofollow noreferrer" onclick="dogo()"><i class="fa-fw fas fa-layer-group faa-tada"></i> <span>随便看看</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Python基础 - 面向对象编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-01T13:05:41.000Z" title="发表于 2021-05-01 21:05:41">2021-05-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-05T15:36:03.000Z" title="更新于 2021-05-05 23:36:03">2021-05-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Python基础 - 面向对象编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/22901/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/posts/22901/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><div style="display:none"><div class="note green icon flat"><i class="note-icon fas fa-rocket"></i><p>📚 文档目录<br>🎃 <span style="color:#49b1f5;cursor:pointer" onclick='pjax.loadUrl("/posts/5311/")'><span style="color:#3a96dd">类型和对象</span></span> - 🎈 <span style="color:#49b1f5;cursor:pointer" onclick='pjax.loadUrl("/posts/176/")'><span style="color:#3a96dd">程序结构与函数编程</span></span> - 🎏 面向对象编程</p></div></div><div class="note green icon flat"><i class="note-icon fas fa-rocket"></i><p>📚 文档目录<br>🎃 <a href="/posts/5311/"><span style="color:#3a96dd">类型和对象</span></a> - 🎈 <a href="/posts/176/"><span style="color:#3a96dd">程序结构与函数编程</span></a> - 🎏 面向对象编程</p></div><h2 id="类">类</h2><div class="tabs" id="sxfwkz"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#sxfwkz-1"><code>class</code>语句</button></li><li class="tab"><button type="button" data-href="#sxfwkz-2"><code>__slots__</code></button></li><li class="tab"><button type="button" data-href="#sxfwkz-3">私有属性</button></li><li class="tab"><button type="button" data-href="#sxfwkz-4"><code>__new__()</code></button></li><li class="tab"><button type="button" data-href="#sxfwkz-5">元类</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="sxfwkz-1"><p>类定义了一组属性，包括变量（指类变量，为所有实例共享）、方法（有三种类型，实例方法、静态方法和类方法）以及由<code>@property</code>支持的特性（需要计算的属性），使用<code>class</code>语句可以创建类对象（注意区分“类对象”和“类实例”），类可以充当一个命名空间，与模块很类似，类的实例是以函数形式调用类对象来创建的（类名后加小括号），然后将创建的实例传递给类的<code>__init__()</code>方法，<code>__init__()</code>方法的参数包括新创建的实例<code>self</code>和用于初始化实例的一些其他参数（可以缺省），注意<code>__init__()</code>只能返回<code>None</code>，可以在其中将一些初始化参数绑定在<code>self</code>对象上作为实例属性，之后可以通过属性名和<code>.</code>运算符访问到实例的这些属性（任意对象都有一个<code>__dict__</code>字典属性，当然也有特例，存储了所有通过<code>obj.property=value</code>方式动态绑定在对象上的属性），在访问属性时，首先会检查实例，如果不知道该属性的任何信息，则会对实例的类进行搜索，如果还没有，会继续搜索其父类，直到没有更多的基类可供搜索</p><p>继承是一种创建新类的机制，目的是专门使用或修改现有类的行为，原始类称为基类或超类，新类称为派生类或子类，通过继承创建类时（可以有多个基类，即多继承，否则叫单继承），所创建的类将继承其基类定义中的属性（注意继承的是类属性而不会继承基类的任何实例的绑定属性），且派生类可以重新定义任何这些属性并添加自己的新属性。子类如果没有定义自己的<code>__init__()</code>方法，实例化子类的时候将会自动调用父类的初始化函数（<code>__new__()</code>也一样），反之，则不会调用，除非手动执行<code>super().__init__()</code>（不建议通过父类类名调用<code>__init__()</code>方法），关于多重继承时的属性查找，会按照MRO顺序（<a href="/posts/5311/">第一章节</a>已经谈过这个问题）依序搜索基类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkDog</span>(<span class="params">Dog</span>):</span> <span class="comment">#工作狗</span></span><br><span class="line">    allnum=<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,identity</span>):</span> <span class="comment">#工作狗除了姓名，还具有编制identity，当前全部注册的工作狗数量由allnum类属性记录</span></span><br><span class="line">        self.__class__.allnum+=<span class="number">1</span> <span class="comment">#千万不能写成self.allnum+=1或者WorkDog.allnum+=1，如果没有派生类的话，后者才正确，前者将会创建一个与类属性allnum同名的实例绑定属性（但若类定义allnum是一个可变对象的话，则又不会新创建实例绑定属性，除非写成self.allnum=self.allnum+1的形式，因为+=对可变对象来说是一个原址操作，示例参见https://github.com/leisurelicht/wtfpython-cn#-class-attributes-and-instance-attributes%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7），数值将总是为1，但是在访问该类属性的时候，总是可以写成self.allnum，因为实例上找不到，会自动到类中寻找</span></span><br><span class="line">        self.identity=identity</span><br><span class="line">        <span class="built_in">super</span>().__init__(name) <span class="comment">#自定义__init__()后，除非手动调用父类初始化方法，否则不会自动调用，在单继承情况下写成Dog.__init__(self,name)也没问题，但是多继承就不一定了，因此总是建议采用super方式，而且后者形式更加简约，super()（python3中等价于super(WorkDog,self)）返回super对象（相当于父类但不是原始父类，是绑定了实例self的bound super object，且多继承的时候返回的还可能是兄弟类，具体参见第一章节所提到的钻石继承），不同于其他通过类访问实例方法（返回非绑定方法，只有通过实例访问实例方法才返回绑定方法）的情况，此处返回的也是“绑定方法”，即绑定了self参数的父类__init__()方法，因此调用时不需要再传入self参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">self</span>):</span> <span class="comment">#一个公开的未实现的接口，子类应重载之</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__class__.allnum-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArmyDog</span>(<span class="params">WorkDog</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span>(<span class="subst">&#123;self.identity&#125;</span>)在追击敌人&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DrugDog</span>(<span class="params">WorkDog</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span>(<span class="subst">&#123;self.identity&#125;</span>)在追查毒品&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperDog</span>(<span class="params">DrugDog,ArmyDog</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,identity</span>):</span></span><br><span class="line">        self.__class__.allnum=<span class="number">0</span> <span class="comment">#访问SuperDog.allnum时会在基类（ArmyDog或DrugDog）中查找，可能已经非零了</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name,identity)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">army_dog_1=ArmyDog(<span class="string">&#x27;Cherry&#x27;</span>,<span class="built_in">id</span>(<span class="string">&#x27;Cherry&#x27;</span>)) <span class="comment">#ArmyDog直接继承了父类的__init__()方法，初始化ArmyDog类实例的时候会自动调用之</span></span><br><span class="line">army_dog_2=ArmyDog(<span class="string">&#x27;Black&#x27;</span>,<span class="built_in">id</span>(<span class="string">&#x27;Black&#x27;</span>))</span><br><span class="line"></span><br><span class="line">print(army_dog_2.__dict__) <span class="comment">#&#123;&#x27;identity&#x27;: 1761656222920, &#x27;name&#x27;: &#x27;Black&#x27;&#125; #通过__dict__实例属性字典查找用户绑定在实例上的所有属性</span></span><br><span class="line">army_dog_2_ref=army_dog_2 <span class="comment">#对army_dog_2所指向的对象引用计数+1，于是当前引用数总计为2</span></span><br><span class="line"></span><br><span class="line">drug_dog_1=DrugDog(<span class="string">&#x27;HelloKit&#x27;</span>,<span class="built_in">id</span>(<span class="string">&#x27;HelloKit&#x27;</span>))</span><br><span class="line">drug_dog_2=DrugDog(<span class="string">&#x27;Jack&#x27;</span>,<span class="built_in">id</span>(<span class="string">&#x27;Jack&#x27;</span>))</span><br><span class="line">drug_dog_3=DrugDog(<span class="string">&#x27;Pig&#x27;</span>,<span class="built_in">id</span>(<span class="string">&#x27;Pig&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> army_dog_2 <span class="comment">#del语句看似是“删除对象”，准确说其实是对象引用计数-1，且del语句并不会立即执行__del__()方法，只有在对象的引用计数降为0的时候才会执行，这时候对象才会真的从内存中删除</span></span><br><span class="line">print(ArmyDog.allnum) <span class="comment">#2 #写成army_dog_1.allnum也正确，但是语义不明，因为allnum明明是一个类属性，通过实例访问会让人误以为是实例属性</span></span><br><span class="line">print(DrugDog.allnum) <span class="comment">#3</span></span><br><span class="line"><span class="keyword">del</span> army_dog_2_ref</span><br><span class="line">print(ArmyDog.allnum) <span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">drug_dog_2.work() <span class="comment">#Jack(2607617062368)在追查毒品</span></span><br><span class="line"></span><br><span class="line">super_dog_1=SuperDog(<span class="string">&#x27;Hero&#x27;</span>,<span class="built_in">id</span>(<span class="string">&#x27;Hero&#x27;</span>))</span><br><span class="line">print(super_dog_1.__class__.mro()) <span class="comment">#[&lt;class &#x27;__main__.SuperDog&#x27;&gt;, &lt;class &#x27;__main__.DrugDog&#x27;&gt;, &lt;class &#x27;__main__.ArmyDog&#x27;&gt;, &lt;class &#x27;__main__.WorkDog&#x27;&gt;, &lt;class &#x27;__main__.Dog&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span></span><br><span class="line">super_dog_1.work() <span class="comment">#Hero(2359695357632)在追查毒品 #SuperDog并未实现自己的work()方法，因此在属性查找时，会顺着MRO列表依次在“基类”中寻找，MRO列表中位于SuperDog之后的正是DrugDog，而DrugDog类确实定义了自己的work()方法，所以属性查找到此结束，就是它</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span>(<span class="subst">&#123;self.identity&#125;</span>)在追击敌人，同时在追查毒品&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">SuperDog.work=work <span class="comment">#给类动态绑定属性方法，且默认是实例方法，相当于你一开始在定义SuperDog的地方写了work()方法</span></span><br><span class="line">super_dog_1.work() <span class="comment">#Hero(1559184520896)在追击敌人，同时在追查毒品</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_allnum</span>(<span class="params">cls</span>):</span></span><br><span class="line">    print(<span class="string">f&#x27;<span class="subst">&#123;cls&#125;</span>类总数量为<span class="subst">&#123;cls.allnum&#125;</span>&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">SuperDog.print_allnum=print_allnum <span class="comment">#给类对象动态绑定类方法，同理静态方法也可以</span></span><br><span class="line">SuperDog.print_allnum() <span class="comment">#&lt;class &#x27;__main__.SuperDog&#x27;&gt;类总数量为1 #也可以通过实例调用类方法，super_dog_1.print_allnum()</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="sxfwkz-2"><p>通常你可以为类实例动态绑定任意数量的任意属性，当你要限制此行为时，或者当一个类需要创建大量实例要节省内存时，可以设置<code>__slots__</code>类属性声明实例可动态绑定的属性范围，一旦定义<code>__slots__</code>，类实例就不再有<code>__dict__</code>属性，且类中不能再定义与<code>__slots__</code>列表中同名的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>:</span></span><br><span class="line">    __slots__=(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;score&#x27;</span>)</span><br><span class="line">    <span class="comment">#name=&#x27;xxx&#x27; #ValueError: &#x27;name&#x27; in __slots__ conflicts with class variable #类中不能再定义出现在__slots__列表中的属性</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">s=student()</span><br><span class="line">s.name=<span class="string">&#x27;dy&#x27;</span></span><br><span class="line">s.score=<span class="number">8.0</span></span><br><span class="line"><span class="comment">#s.sex=&#x27;female&#x27; #AttributeError: &#x27;student&#x27; object has no attribute &#x27;sex&#x27; #无法为实例动态绑定非__slots__列表属性</span></span><br><span class="line"><span class="comment">#print(s.__dict__) #AttributeError: &#x27;student&#x27; object has no attribute &#x27;__dict__&#x27; #定义__slots__类属性的类实例不再有__dict__属性字典</span></span><br><span class="line"></span><br><span class="line">student.school=<span class="string">&#x27;nuist&#x27;</span> <span class="comment">#__slots__不会限制类本身可动态绑定属性的范围</span></span><br><span class="line">print(student.__dict__) <span class="comment">#&#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__slots__&#x27;: (&#x27;name&#x27;, &#x27;score&#x27;), &#x27;name&#x27;: &lt;member &#x27;name&#x27; of &#x27;student&#x27; objects&gt;, &#x27;score&#x27;: &lt;member &#x27;score&#x27; of &#x27;student&#x27; objects&gt;, &#x27;__doc__&#x27;: None, &#x27;school&#x27;: &#x27;nuist&#x27;&#125; #注意看类的__dict__中有了name和score两个属性，这也是为什么上面在类中定义同名属性name时会发生冲突</span></span><br></pre></td></tr></table></figure><p>在实际使用中，<code>__slots__</code>不是作为一种安全特性，虽然定义了<code>__slots__</code>的类不再依赖<code>__dict__</code>字典进行实例属性的存储和查找，从而达到隐藏实例动态绑定的属性的目的，但是并没有对属性访问本身增加任何控制，其主要目的还是对内存和性能的优化，使用<code>__slots__</code>的类实例不再使用字典来存储实例绑定属性，它会使用基于数组的更加紧密的数据结构，在创建大量对象的程序中，使用<code>__slots__</code>可以显著减少<a target="_blank" rel="noopener external nofollow noreferrer" href="http://tech.oyster.com/save-ram-with-python-slots/">内存占用</a>和执行时间（直接通过数组内存地址偏移访问<code>__slots__</code>中定义的属性比通过<code>__dict__</code>字典进行属性查找要快），但是也会带来一些需要注意的问题，1）<code>__slots__</code>无法被继承，每个子类都要重新定义一遍，如果忘记这一点，子类的执行速度将比没有使用<code>__slots__</code>时更慢，2）实例只能动态绑定那些在<code>__slots__</code>列表中出现的属性，极大影响了程序的灵活性，3）实例不能被弱引用，除非将<code>'__weakref__'</code>放进<code>__slots__</code></p><p>关于上述第一点，子类如果没有重新定义<code>__slots__</code>，动态绑定将不受限制，重新定义时如果和基类一致，可以直接赋一个空值<code>__slots__=()</code>，也可以在基类的基础上进行增补，但无法删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">graduate</span>(<span class="params">student</span>):</span></span><br><span class="line">    __slots__=(<span class="string">&#x27;sex&#x27;</span>) <span class="comment">#一个笔误，之前以为__slots__必须是一个列表，此处等同于：__slots__=&#x27;sex&#x27;，当前子类graduate的__slots__在基类基础上扩展，属性范围限制在[&#x27;name&#x27;,&#x27;score&#x27;,&#x27;sex&#x27;]</span></span><br><span class="line">    </span><br><span class="line">g=graduate()</span><br><span class="line">g.name=<span class="string">&#x27;dy&#x27;</span></span><br><span class="line">g.score=<span class="number">25</span></span><br><span class="line">g.sex=<span class="string">&#x27;female&#x27;</span></span><br><span class="line">print(g.sex)</span><br></pre></td></tr></table></figure><p>关于第三点，弱引用的问题，定义了<code>__slots__</code>的类实例无法被弱引用，因为此时不仅是类实例的<code>__dict__</code>属性被禁用，<code>__weakref__</code>属性也被禁用，<code>__weakref__</code>属性是干嘛的？假设对对象进行弱引用，那么创建的弱引用将存储在对象的<code>__weakref__</code>属性中，因此解决办法就是将<code>'__weakref__'</code>放进<code>__slots__</code>列表中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">graduate</span>(<span class="params">student</span>):</span></span><br><span class="line">    __slots__=(<span class="string">&#x27;sex&#x27;</span>,<span class="string">&#x27;__weakref__&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line">g=graduate()</span><br><span class="line">print(g.__weakref__) <span class="comment">#None #此时还没有弱引用</span></span><br><span class="line">ref=weakref.ref(g) <span class="comment">#如果没有将&#x27;__weakref__&#x27;放到__slots__中，则报错：TypeError: cannot create weak reference to &#x27;graduate&#x27; object</span></span><br><span class="line">print(g.__weakref__) <span class="comment">#&lt;weakref at 0x000002595C39C4F8; to &#x27;graduate&#x27; at 0x000002595C60CDC8&gt;</span></span><br><span class="line"></span><br><span class="line">g.name=<span class="string">&#x27;muggle&#x27;</span></span><br><span class="line">g.score=<span class="number">25</span></span><br><span class="line">g.sex=<span class="string">&#x27;female&#x27;</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">f&#x27;<span class="subst">&#123;ref().name&#125;</span>,<span class="subst">&#123;ref().sex&#125;</span>,<span class="subst">&#123;ref().score&#125;</span>&#x27;</span>) <span class="comment">#muggle,female,25 #调用弱引用将获取被弱引用的原始对象</span></span><br></pre></td></tr></table></figure><div class="hide-toggle"><div class="hide-button toggle-title"><i class="fas fa-caret-right fa-fw"></i><span>弱引用</span></div><div class="hide-content"><p><code>weakref</code>模块允许用户创建对对象的弱引用（weak reference），相比于普通的引用（为了和“弱引用”这一名词对应，在官方文档中明确有strong reference“强引用”一说）来说，只要存在任何一个对对象的强引用（即引用计数大于1，注意弱引用不计在内，要删除某个强引用，使用<code>del</code>语句，引用计数减一），这个对象就不会被垃圾收集器销毁，而当引用计数为0时（没有强引用），无论还有多少弱引用，那么它将会被垃圾收集器收回。在对象未被销毁之前，可以通过弱引用访问到对象，否则只能得到<code>None</code></p><p>weakref运行在“观察者模式”，当我们创建一个对对象的弱引用，意味着对该对象进行观察，当对象被回收，观察者将立即得到一个反馈并执行回调函数，假设存在的话。另外并非所有对象都可以创建弱引用，可以创建弱引用的对象包括类实例、函数对象、实例方法、集合、冰冻集合、文件对象、生成器、类对象、sockets、数组、队列（deque）、正则表达式对象（regular expression pattern）以及code对象，而列表和字典是不能直接支持弱引用的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wr=weakref.ref(a)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: cannot create weak reference to <span class="string">&#x27;list&#x27;</span> <span class="built_in">object</span></span><br></pre></td></tr></table></figure><p>通过子类化列表或字典可以增加这样的支持：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">new_list</span>(<span class="params"><span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">ref</span>):</span></span><br><span class="line">    <span class="keyword">if</span> ref <span class="keyword">is</span> wr:</span><br><span class="line">        print(<span class="string">&#x27;列表对象[1,2,3]被回收&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a=new_list([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">wr=weakref.ref(a,callback)</span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">列表对象[1,2,3]被回收</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>但是像元组和整型，即使子类化也不能支持弱引用。在上述示例中，通过<code>weakref.ref()</code>创建了一个弱引用对象，可以像调用函数那样调用它以获取被引用的对象（因为弱引用类实现了<code>__call__()</code>方法），称之为referent，如果referent不再存活，调用将返回<code>None</code>，因此如果你要测试一个referent是否存活，可以使用逻辑表达式<code>ref() is not None</code>（其中<code>ref</code>是一个弱引用对象）</p><p>简单介绍<code>weakref</code>模块的类或方法：</p><ul><li><p><code>class weakref.ref(obj[, callback])</code>（创建对对象的弱引用）<br>参数<code>obj</code>是被弱引用的原始对象（被称为referent），<code>callback</code>是回调函数，当<code>obj</code>引用计数减为0被当作垃圾回收清理的时候，会自动调用该函数，且传入该弱引用作为唯一参数，可以创建多个弱引用，当referent被回收的时候，会根据弱引用创建的时间由近及远地逐个执行回调函数，假设定义了的话</p><p>假设referent是可哈希的，弱引用对象也是可哈希的，即使referent被销毁，弱引用对象仍能维持其哈希值，但是如果你在referent被销毁之后才第一次计算弱引用对象的哈希值，将导致<code>TypeError</code></p><p>弱引用对象支持等值测试（<code>==</code>），但是不支持排序，不同弱引用之间的等值关系等同于各自对应的referent之间的等值关系（举个例子，假设有两个不同对象满足<code>a==b</code>，且<code>wra</code>是对<code>a</code>的弱引用，<code>wrb</code>是对<code>b</code>的弱引用，那么立即推，<code>wra==wrb</code>是成立的，若其中一方的referent被销毁，则不再相等），特别的，对同一对象所创建的不同弱引用总是等值的（创建弱引用时所传入的回调函数参数不影响等值测试的结果，但会影响<code>is</code>判断的结果），示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(self.name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self,another</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.name==another.name:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">a=A(<span class="string">&#x27;msy&#x27;</span>)</span><br><span class="line">b=A(<span class="string">&#x27;msy&#x27;</span>)</span><br><span class="line">wra=weakref.ref(a)</span><br><span class="line">wrb=weakref.ref(b)</span><br><span class="line">print(a==b,wra==wrb)</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">hash</span>(wra))</span><br><span class="line"><span class="keyword">del</span> b</span><br><span class="line"><span class="comment">#print(hash(wrb)) #TypeError: weak object has gone away</span></span><br><span class="line">print(wra==wrb) <span class="comment">#False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">ref</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">wra2=weakref.ref(a,<span class="built_in">callable</span>)</span><br><span class="line">print(wra==wra2,wra <span class="keyword">is</span> wra2) <span class="comment">#True False</span></span><br><span class="line">wra3=weakref.ref(a)</span><br><span class="line">print(wra==wra2,wra <span class="keyword">is</span> wra3) <span class="comment">#True True</span></span><br></pre></td></tr></table></figure></li><li><p><code>weakref.proxy(obj[, callback])</code>（创建对对象的代理）<br>代理对象是不可哈希的（无论referent可不可哈希），这阻止了将其用于字典的键，和<code>weakref.ref()</code>一样，支持回调，代理和弱引用的显著的区别是，1）要从弱引用获取referent，你需要使用<code>()</code>调用这个弱引用对象，但是代理不需要，使用代理对象就如同使用对象本身一样，2）当referent销毁后，弱引用调用会返回<code>None</code>，而访问代理则导致<code>ReferenceError</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line">a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">wr=weakref.ref(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">ref</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;删除对象&#x27;</span>)</span><br><span class="line"></span><br><span class="line">proxy=weakref.proxy(a,callback)</span><br><span class="line"></span><br><span class="line">print(wr()) <span class="comment">#&#123;1, 2, 3&#125;</span></span><br><span class="line">print(<span class="built_in">repr</span>(proxy))</span><br><span class="line">print(proxy) <span class="comment">#&#123;1, 2, 3&#125;</span></span><br><span class="line"></span><br><span class="line">proxy.add(<span class="number">4</span>)</span><br><span class="line">print(proxy) <span class="comment">#&#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a <span class="comment">#对象a的引用计数降为0后，自动调用代理的回调函数，输出：删除对象</span></span><br><span class="line"></span><br><span class="line">print(wr()) <span class="comment">#None</span></span><br><span class="line">print(proxy) <span class="comment">#ReferenceError: weakly-referenced object no longer exists</span></span><br></pre></td></tr></table></figure></li><li><p><code>weakref.getweakrefcount(obj)</code>（返回对象<code>obj</code>的全部弱引用以及代理数量）</p></li><li><p><code>weakref.getweakrefs(obj)</code>（返回对象<code>obj</code>的全部弱引用和代理对象，以列表返回）</p></li><li><p><code>class weakref.WeakMethod(method)</code>（创建对绑定方法的弱引用）<br>假设你有一个类实例<code>a</code>，<code>f</code>是实例方法，要对<code>a.f</code>创建弱引用，使用<code>WeakMethod(a.f)</code>即可，而标准弱引用对象构造办法（<code>ref(a.f)()</code>将返回<code>None</code>）无法做到这一点，因为<code>a.f</code>返回的是一个全新的“绑定了实例的方法”，其引用计数为0，如果一定要使用标准弱引用对象构造办法，只要将<code>a.f</code>赋给一个变量即可（使引用计数非0），因为<code>WeakMethod</code>是<code>ref</code>的子类，因此要获取被弱引用的原始绑定方法对象，也是通过<code>()</code>进行调用来获取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;实例方法&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cf</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;类方法&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sf</span>():</span></span><br><span class="line">        print(<span class="string">&#x27;静态方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a=A()</span><br><span class="line">m1=weakref.WeakMethod(a.f) <span class="comment">#替换成WeakMethod(a.cf)也可以，但是替换成WeakMethod(a.sf)不行，因为a.sf返回的是非绑定方法</span></span><br><span class="line">m1()()</span><br><span class="line"></span><br><span class="line">print(weakref.ref(a.f)()) <span class="comment">#None</span></span><br><span class="line">t=a.f <span class="comment">#替换成a.sf或a.cf都可以</span></span><br><span class="line">m2=weakref.ref(t)</span><br><span class="line">m2()()</span><br></pre></td></tr></table></figure></li><li><p><code>class weakref.finalize(obj, func, *args, **kwargs)</code><br>创建一个可通过<code>()</code>调用的finalizer对象（<code>finalize</code>类的<code>__call__()</code>方法体即是执行<code>func(*args,**kwargs)</code>），当referent对象<code>obj</code>的引用计数降为0时将自动触发调用，另外在程序结束时也总会调用这些finalizer对象（调用顺序和这些对象的创建顺序相反，对比<code>ref(obj,callback)</code>，程序结束时则不会调用<code>callback()</code>，除非在程序中手动执行<code>del</code>语句降低引用计数为0），除非其<code>atexit</code>属性被设置为<code>False</code>，finalizer一旦被调用一次将“死亡”，若调用一个死亡了的finalizer，将返回<code>None</code>（另请注意<code>func</code>、<code>args</code>和<code>kwargs</code>不能直接或间接对<code>obj</code>存在任何引用，否则会导致<code>obj</code>不能被回收，特别的，<code>func</code>不能是<code>obj</code>的实例绑定方法）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;回收&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">888</span></span><br><span class="line"></span><br><span class="line">a=A()</span><br><span class="line">t=weakref.finalize(a,callback)</span><br><span class="line">print(t())</span><br><span class="line">print(t()) <span class="comment">#1、如果替换这两行为del a，输出结果一致，2、如果注释掉这两行，将先后输出&quot;OVER&quot;和&quot;回收&quot;</span></span><br><span class="line">print(<span class="string">&#x27;OVER&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">回收</span></span><br><span class="line"><span class="string">888</span></span><br><span class="line"><span class="string">None</span></span><br><span class="line"><span class="string">OVER</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>finalizer对象的属性、方法：</p><ul><li><code>__call__()</code><br>当finalizer对象存活时调用<code>__call__()</code>将返回<code>func(*args,**kwargs)</code>的结果，并在此之后宣判其死亡，当finalizer对象死亡时调用<code>__call__()</code>将返回<code>None</code></li><li><code>detach()</code><br>当finalizer对象存活时调用<code>detach()</code>将返回<code>(obj, func, args, kwargs)</code>元组，并在此之后宣判其死亡，当finalizer对象死亡时调用<code>detach()</code>将返回<code>None</code></li><li><code>peek()</code><br>同<code>detach()</code>，但是调用后不会导致finalizer对象死亡</li><li><code>alive</code><br>判断finalizer对象是否存活</li><li><code>atexit</code><br>一个可写的布尔属性，默认值为<code>True</code>，且只有<code>atexit</code>属性为<code>True</code>的finalizer对象才会被触发调用</li></ul></li><li><p><code>weakref.ReferenceType</code>（返回弱引用对象的类型<code>&lt;class 'weakref'&gt;</code>）</p></li><li><p><code>weakref.ProxyType</code>（返回不可调用对象的弱代理的类型<code>&lt;class 'weakproxy'&gt;</code>）</p></li><li><p><code>weakref.CallableProxyType</code>（返回可调用对象的弱代理的类型<code>&lt;class 'weakcallableproxy'&gt;</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line">s=<span class="built_in">set</span>() <span class="comment">#不可调用对象</span></span><br><span class="line"></span><br><span class="line">t1=weakref.proxy(s)</span><br><span class="line">print(<span class="built_in">type</span>(t1))</span><br><span class="line">print(<span class="built_in">isinstance</span>(t1,weakref.ProxyType))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span> <span class="comment">#可调用对象</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">t2=weakref.proxy(f)</span><br><span class="line">print(<span class="built_in">type</span>(t2))</span><br><span class="line">print(<span class="built_in">isinstance</span>(t2,weakref.CallableProxyType))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">&lt;class &#x27;weakproxy&#x27;&gt;</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">&lt;class &#x27;weakcallableproxy&#x27;&gt;</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><code>weakref.ProxyTypes</code>（返回全部代理类型，即<code>(&lt;class 'weakproxy'&gt;, &lt;class 'weakcallableproxy'&gt;)</code>）</p></li></ul><p>弱引用的主要用途是实现持有大量“大”对象（指占用内存大）的高速缓存或映射，以往由于对象作为高速缓存或映射的条目被引用，导致用户使用完后无法使用<code>del</code>将这些对象的引用计数降为0（只要高速缓存或映射还存在），从而浪费大量空间，为此<code>weakref</code>模块提供了<code>WeakKeyDictionary</code>和<code>WeakValueDictionary</code>用来解决该问题</p><ul><li><code>class weakref.WeakKeyDictionary([dict])</code><br>该字典中的键是弱引用的，当外部不存在对某键的强引用时，会自动删除字典中此键对应的条目，另外<code>WeakKeyDictionary</code>对象拥有一个额外的方法<code>keyrefs()</code>，其返回全部弱引用的键的列表<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">d=weakref.WeakKeyDictionary()</span><br><span class="line">d[A()]=<span class="number">1</span></span><br><span class="line">print(<span class="built_in">list</span>(d.keys())) <span class="comment">#[] #弱字典中空无一物，原因在于&quot;d[A()]=1&quot;中的键&quot;A()&quot;的引用计数为0，它随即被删除</span></span><br><span class="line"></span><br><span class="line">a=A()</span><br><span class="line">d[a]=<span class="number">1</span> <span class="comment">#键&quot;a&quot;存在外部引用：a=A()，其引用计数为1</span></span><br><span class="line">print(<span class="built_in">list</span>(d.keys())) <span class="comment">#[&lt;__main__.A object at 0x000001FA6AB16EB8&gt;]</span></span><br><span class="line">print(d[a]) <span class="comment">#1</span></span><br><span class="line"><span class="keyword">del</span> a <span class="comment">#del使&quot;a&quot;的引用计数减1，变为0</span></span><br><span class="line">print(<span class="built_in">list</span>(d.keys())) <span class="comment">#[]</span></span><br><span class="line"><span class="comment">#print(d[a]) #NameError: name &#x27;a&#x27; is not defined</span></span><br></pre></td></tr></table></figure></li><li><code>class weakref.WeakValueDictionary([dict])</code><br>该字典中键的值是弱引用的，当外部不存在对某键值的强引用时，会自动删除此字典中该键值对应的条目，另外<code>WeakValueDictionary</code>对象拥有一个额外的方法<code>valuerefs()</code>，其返回全部弱引用的值的列表</li></ul><p>除了“弱字典”，模块还提供了“弱集合”<code>class weakref.WeakSet([elements])</code>，当弱集合中的某个元素的引用计数降低为0时，将自动从弱集合中删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">s=weakref.WeakSet()</span><br><span class="line">a=A()</span><br><span class="line">b=A()</span><br><span class="line">s.add(a)</span><br><span class="line">s.add(b)</span><br><span class="line">print(<span class="built_in">list</span>(s))</span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line">print(<span class="built_in">list</span>(s))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">[&lt;__main__.A object at 0x0000019127A1D588&gt;, &lt;__main__.A object at 0x0000019127A1D160&gt;]</span></span><br><span class="line"><span class="string">[&lt;__main__.A object at 0x0000019127A1D588&gt;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="sxfwkz-3"><p>Python中无法为类声明私有类型的属性，声明私有类型的目的是阻止子类继承该属性，并且只能在类定义中访问私有属性，在类外任何地方都无法直接通过属性名访问它。一种变通是python内部会对类定义中所有以<code>__</code>双下划线开头且不超过一个下划线结尾（这样命名的属性就被认为是“私有属性”）的属性进行名字转换，具体的，在原始属性名前加上“<code>_类名</code>”，譬如：类<code>Foo</code>的“私有属性”<code>__spam</code>被替换为<code>_Foo__spam</code>，使得子类无法通过原始属性名访问它，python把这种技术叫做“name mangling”（属性名轧压机制），示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__private()</span><br><span class="line">        self.public()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__private</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;A.__private()&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;A.public()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="comment"># def __init__(self): #此处写不写都一样，因为没有实现__init__方法时，本就会自动调用父类的__init__方法</span></span><br><span class="line">    <span class="comment">#     super(B,self).__init__() #或者A.__init__(self)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__private</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;B.__private()&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;B.public()&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">a=A()</span><br><span class="line">b=B()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">A.__private()</span></span><br><span class="line"><span class="string">A.public()</span></span><br><span class="line"><span class="string">A.__private()</span></span><br><span class="line"><span class="string">B.public()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>输出倒数第二行为什么是<code>A.__private()</code>而不是<code>B.__private()</code>（上述示例既展示了python中“私有属性”的工作方式，也展示其愚蠢，为了纠正，应这样实现<code>B</code>的初始化函数：<code>self.__private();self.public()</code>，而不是偷懒直接调用父类的初始化函数），不急，先来看看属性名轧压机制是否真的工作了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.__private()</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">2</span>-cc12b64d1d3b&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 a.__private()</span><br><span class="line"></span><br><span class="line">AttributeError: <span class="string">&#x27;A&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;__private&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a._A__private()</span><br><span class="line">A.__private()</span><br></pre></td></tr></table></figure><p>对象<code>a</code>确实访问不到原始的属性方法<code>__private</code>了，名字已经转变为<code>_A__private</code>，实际上解释器在遇到类定义语句时，会首先修改这些“私有”属性的名字，即在内存中的类定义如下（在类定义外动态绑定的双下划线属性名不会被轧压）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._A__private() <span class="comment">#修改1</span></span><br><span class="line">        self.public()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_A__private</span>(<span class="params">self</span>):</span> <span class="comment">#修改2</span></span><br><span class="line">        print(<span class="string">&#x27;A.__private()&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;A.public()&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_B__private</span>(<span class="params">self</span>):</span> <span class="comment">#修改3</span></span><br><span class="line">        print(<span class="string">&#x27;B.__private()&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;B.public()&#x27;</span>)</span><br></pre></td></tr></table></figure><p>现在可以回答上述问题了，当实例化<code>B</code>类时，会调用父类<code>A</code>类的初始化函数，并传入<code>B</code>类实例，记作<code>b</code>，于是在<code>__init__()</code>中将先后执行<code>b._A__private()</code>和<code>b.public()</code>，真相大白</p><p>另外经常遇到以<code>_</code>单下划线开头的变量名（实际上是以任何数量下划线开头的变量，仅习惯上以单下划线打头），如果位于模块级别，在<code>from module import *</code>时是无法导入的（可以预防错误，因为这种方式导入的变量很容易导致“覆盖”，即“命名空间污染”），如果要设置<code>from module import *</code>所允许导入的变量，可以使用<code>__all__</code>指定</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="sxfwkz-4"><p><code>__new__()</code>是一个静态方法，通用的定义为<code>__new__(cls,*args,**kwargs)</code>（第一个参数<code>cls</code>表示要实例化的类，你总是需要手动传递它），其中<code>*args</code>和<code>**kwargs</code>接收的参数与传递给<code>__init__()</code>的参数相同，注意<code>__new__()</code>是唯一可以编写在创建实例之前执行的代码的地方，其必须有返回值，返回的是创建的实例对象，一般调用父类或<code>object</code>类的<code>__new__()</code>方法来创建，如果返回值不是当前类的实例那么<code>__init__()</code>函数将不会被调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls,*args,**kwargs</span>):</span> <span class="comment">#__new__和__init__方法的参数除第一个参数(cls或self)外必须完全一致</span></span><br><span class="line">        ret=<span class="built_in">super</span>(A,cls).__new__(cls)</span><br><span class="line">        print(<span class="string">f&#x27;Return of __new__(): <span class="subst">&#123;ret&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,*args,**kwargs</span>):</span></span><br><span class="line">        print(<span class="string">f&#x27;Init A <span class="subst">&#123;self&#125;</span> with <span class="subst">&#123;args&#125;</span> and <span class="subst">&#123;kwargs&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="keyword">return</span> A.__new__(A) <span class="comment">#事实上__new__方法可以生产非当前类的其他任意类的实例对象，这表示__new__方法拥有决定实例对象所属类型的绝对权力，但此时__init__方法则不再被自动调用</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Init B&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a=A(<span class="string">&#x27;Hello,&#x27;</span>,<span class="string">&#x27;muggledy&#x27;</span>)</span><br><span class="line">b=B()</span><br><span class="line">print(<span class="string">&#x27;-&#x27;</span>*<span class="number">10</span>)</span><br><span class="line">b.__init__()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;OUTPUT</span></span><br><span class="line"><span class="string">Return of __new__(): &lt;__main__.A object at 0x0000013B40CFB4A8&gt;</span></span><br><span class="line"><span class="string">Init A &lt;__main__.A object at 0x0000013B40CFB4A8&gt; with (&#x27;Hello,&#x27;, &#x27;muggledy&#x27;) and &#123;&#125;</span></span><br><span class="line"><span class="string">Return of __new__(): &lt;__main__.A object at 0x0000013B40CFB518&gt;</span></span><br><span class="line"><span class="string">----------</span></span><br><span class="line"><span class="string">Init A &lt;__main__.A object at 0x0000013B40CFB518&gt; with () and &#123;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><code>__new__</code>方法可用于当你继承一些不可变的类型时（如<code>int</code>、<code>str</code>、<code>tuple</code>），提供给你一个自定义这些类的实例化过程的途径，譬如你要继承<code>int</code>类型实现一个永远为正数的整型，由于是不可变对象，显然你无法在实例创建之后（如<code>__init__()</code>中）进行任何修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PositiveInteger</span>(<span class="params"><span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls,value</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(PositiveInteger,cls).__new__(cls,<span class="built_in">abs</span>(value))</span><br><span class="line"></span><br><span class="line">i=PositiveInteger(-<span class="number">3</span>)</span><br><span class="line">print(i) <span class="comment">#3</span></span><br></pre></td></tr></table></figure><p>还可以用来实现“单例”，具体后面再说</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="sxfwkz-5"><p>所谓元类，就是创建类对象本身的类，我们在创建类实例的时候，是通过类名加括号（括号中是初始化参数）的方式，又知道“类的类”是<code>type</code>类型，可想而知类对象是通过<code>type(...)</code>形式创建的，现给定一个类定义，解释器究竟做了什么呢？譬如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>解释器扫描完这一段内容后，可以得到类名<code>class_name</code>、继承的基类<code>bases</code>以及类主体<code>class_body</code>三个内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class_name=<span class="string">&#x27;Foo&#x27;</span></span><br><span class="line">bases=(<span class="built_in">object</span>,)</span><br><span class="line">class_body= \</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;\</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">def func(self):</span></span><br><span class="line"><span class="string">    pass</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>然后在局部空间<code>class_dict={}</code>中执行类主体：<code>exec(class_body,globals(),class_dict)</code>，最后使用默认元类也就是<code>type</code>类创建类对象：<code>Foo=type(class_name,bases,class_dict)</code></p><p>除了使用默认的<code>type</code>类创建类对象，还可以继承<code>type</code>类，也就是自定义元类，通过重载<code>__new__()</code>或<code>__init__()</code>来进一步控制用户自定义类的定义内容（如果是修改类定义的话，应该在<code>__new__()</code>中类对象创建之前修改，如果是一些检查逻辑如类属性值是否合法等，则在类对象创建后再检查也不迟，即放在<code>__init__()</code>中），看个示例，已知有一个<code>factory</code>类，现要求其只能有三个属性，名称<code>name</code>、地址<code>location</code>以及业务<code>business</code>，其实就是添加一个类属性<code>__slots__</code>（注意类对象创建后，再添加类属性<code>__slots__</code>是没效果的，必须写在类定义中）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMetaCls</span>(<span class="params"><span class="built_in">type</span></span>):</span> <span class="comment">#自定义元类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls,class_name,bases,class_dict</span>):</span></span><br><span class="line">        class_dict[<span class="string">&#x27;__slots__&#x27;</span>]=[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;location&#x27;</span>,<span class="string">&#x27;business&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls,class_name,bases,class_dict)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">factory</span>(<span class="params">metaclass=MyMetaCls</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,location,business</span>):</span></span><br><span class="line">        self.name,self.location,self.business=name,location,business</span><br><span class="line">    </span><br><span class="line">f=factory(name=<span class="string">&#x27;中石化&#x27;</span>,location=<span class="string">&#x27;西北&#x27;</span>,business=<span class="string">&#x27;中国能源供给&#x27;</span>)</span><br><span class="line">f.xxx=<span class="string">&#x27;xxx&#x27;</span> <span class="comment">#AttributeError: &#x27;factory&#x27; object has no attribute &#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure><p>如上，要设置元类，只需要在基类元组中提供<code>metaclass</code>关键字参数，或者在类定义中指定<code>__metaclass__</code>属性。尽管使用元类可以显著改变用户定义的类的行为和语义，但在使用元类时，不应使类的工作方式和其文档描述相距甚远，这会使得用户对代码感到困惑</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="属性访问控制">属性访问控制</h2><div class="tabs" id="sxfwkz"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#sxfwkz-1">静态方法与类方法</button></li><li class="tab"><button type="button" data-href="#sxfwkz-2"><code>&#64;property</code>特性</button></li><li class="tab"><button type="button" data-href="#sxfwkz-3">描述符</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="sxfwkz-1"><p>在类定义中，所有方法默认都是在实例上操作的，特点是总是存在一个名为<code>self</code>（当然名称可以自定义）的位置参数，在通过实例访问这些方法属性时，譬如<code>obj.method</code>（<code>obj</code>是某一类实例，<code>method</code>是类中定义的普通实例方法），python会利用“特性”（特殊属性）机制来进行访问控制，事实上，用户得到的不是原始函数对象<code>method</code>，而是会得到所谓的“绑定方法”，绑定方法类似于偏函数（<code>obj.method</code>返回的相当于是<code>partial(method,self=obj)</code>），其中<code>self</code>参数已经填入，保存在绑定方法的执行环境中，但是其他参数仍需在调用该（绑定）方法时提供（其实你也可以通过类调用实例方法，不过这时候你就需要手动传入实例对象了，如<code>cls.method(obj,...)</code>，<code>cls</code>为<code>obj</code>的所属类，省略号省略了方法可能存在的其他参数），这种绑定方法是由在后台执行的特性函数静默创建的，你还可以手动指定其他两种特性函数分别用于创建静态方法和类方法，静态方法是一种普通函数，但是位于类定义的命名空间中，要定义静态方法，可使用<code>@staticmethod</code>装饰器，譬如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x,y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x+y</span><br></pre></td></tr></table></figure><p>不同于实例方法，静态方法属性访问返回的就是原始的函数对象而非绑定方法，且既可以通过类也可以通过实例来调用静态方法。如果在编写类时需要采用很多不同的方式来创建新实例，而类中只能由一个<code>__init__()</code>方法，可以使用静态方法，替代的创建函数通常按如下形式定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,year,month,day</span>):</span></span><br><span class="line">        self.year,self.month,self.day=year,month,day</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">now</span>():</span></span><br><span class="line">        t=time.localtime()</span><br><span class="line">        <span class="keyword">return</span> Date(t.tm_year,t.tm_mon,t.tm_mday)</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tomorrow</span>():</span></span><br><span class="line">        t=time.localtime(time.time()+<span class="number">86400</span>)</span><br><span class="line">        <span class="keyword">return</span> Date(t.tm_year,t.tm_mon,t.tm_mday)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.year&#125;</span>-<span class="subst">&#123;self.month&#125;</span>-<span class="subst">&#123;self.day&#125;</span>&#x27;</span></span><br><span class="line">        </span><br><span class="line">print(Date(<span class="number">1967</span>,<span class="number">4</span>,<span class="number">9</span>)) <span class="comment">#1967-4-9</span></span><br><span class="line">print(Date.now()) <span class="comment">#2021-5-18</span></span><br><span class="line">print(Date.tomorrow()) <span class="comment">#2021-5-19</span></span><br></pre></td></tr></table></figure><p>类方法是将类本身作为对象进行操作的方法，类方法使用<code>@classmethod</code>装饰器，与实例方法不同在于，类方法定义的第一个参数通常命名为<code>cls</code>，且将类本身作为第一个参数进行传递，譬如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Times</span>:</span></span><br><span class="line">    factor=<span class="number">1</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">cls,x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls.factor*x</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoTimes</span>(<span class="params">Times</span>):</span></span><br><span class="line">    factor=<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">print(TwoTimes.mul(<span class="number">4</span>)) <span class="comment">#8</span></span><br></pre></td></tr></table></figure><p>类似于实例方法的属性访问，类方法属性访问同样返回绑定方法，因此上述示例中<code>TwoTimes.mul</code>返回的相当于<code>partial(mul,cls=TwoTimes)</code>，且类方法也能通过实例调用，譬如<code>t=TwoTimes();t.mul(4)</code>，其中<code>t.mul</code>返回的相当于<code>partial(mul,cls=t.__class__)</code></p><p>在之前的<code>Date</code>类示例中我们使用静态方法实现多个创建函数，假设有一个子类<code>EuroDate</code>继承它以输出欧洲日期格式，但是你会发现结果不符合预期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EuroDate</span>(<span class="params">Date</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.day:02d&#125;</span>/<span class="subst">&#123;self.month:02d&#125;</span>/<span class="subst">&#123;self.year&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line">print(EuroDate.now()) <span class="comment">#2021-5-18</span></span><br></pre></td></tr></table></figure><p>输出之所以还是旧格式，这是因为<code>EuroDate.now()</code>返回的是一个<code>Date</code>对象，应采用类方法实现创建函数来避免该错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,year,month,day</span>):</span></span><br><span class="line">        self.year,self.month,self.day=year,month,day</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">now</span>(<span class="params">cls</span>):</span></span><br><span class="line">        t=time.localtime()</span><br><span class="line">        <span class="keyword">return</span> cls(t.tm_year,t.tm_mon,t.tm_mday)</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tomorrow</span>(<span class="params">cls</span>):</span></span><br><span class="line">        t=time.localtime(time.time()+<span class="number">86400</span>)</span><br><span class="line">        <span class="keyword">return</span> cls(t.tm_year,t.tm_mon,t.tm_mday)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.year&#125;</span>-<span class="subst">&#123;self.month&#125;</span>-<span class="subst">&#123;self.day&#125;</span>&#x27;</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EuroDate</span>(<span class="params">Date</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.day:02d&#125;</span>/<span class="subst">&#123;self.month:02d&#125;</span>/<span class="subst">&#123;self.year&#125;</span>&#x27;</span></span><br><span class="line">        </span><br><span class="line">print(EuroDate.now()) <span class="comment">#18/05/2021</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="sxfwkz-2"><p>通常，访问实例或类属性时，会返回所存储的相关值，由<code>@property</code>特性支持的属性，可以在访问时经过计算得到返回值，譬如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,radius</span>):</span></span><br><span class="line">        self.radius=radius</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> math.pi*self.radius**<span class="number">2</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perimeter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*math.pi*self.radius</span><br><span class="line">        </span><br><span class="line">c=Circle(<span class="number">4</span>)</span><br><span class="line">print(<span class="string">f&#x27;半径：<span class="subst">&#123;c.radius&#125;</span>，周长：<span class="subst">&#123;c.perimeter&#125;</span>，面积：<span class="subst">&#123;c.area&#125;</span>&#x27;</span>) <span class="comment">#半径：4，周长：25.132741228718345，面积：50.26548245743669</span></span><br><span class="line"><span class="comment">#c.area=8 #AttributeError: can&#x27;t set attribute #当前area“属性”仅仅是只读的，除非设置setter方法，具体见下</span></span><br></pre></td></tr></table></figure><p>上述示例中，计算面积的<code>area()</code>实例方法和计算周长的<code>perimeter()</code>实例方法，通过装饰器<code>@property</code>修饰后，支持以简单属性的形式访问（不需要加<code>()</code>调用），用户很难发现正在“计算”一个属性，除非在试图重新定义该属性时生成了错误消息（<code>AttributeError</code>异常），这种特性使用方式遵循所谓的统一访问原则，你不需要费力了解何时添加额外的<code>()</code>所带来的不必要的混淆</p><p>事实上，该特性还可以拦截操作，以设置和删除属性，这是通过向特性附加<code>setter</code>和<code>deleter</code>操作来实现的，譬如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__score <span class="comment">#将值实际存储在其他名称中，通常是在加两个下划线前缀，即“私有属性”中，但是注意“私有属性”其实也直接暴露在外，而且易于辨识，你可以通过访问实例的__dict__看到它，可以定义__slots__来禁用__dict__，但是你依旧无法阻止通过setattr(...)的方式进行非法赋值</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span>(<span class="params">self,score</span>):</span></span><br><span class="line">        <span class="keyword">if</span> score&gt;=<span class="number">0</span> <span class="keyword">and</span> score&lt;=<span class="number">100</span>:</span><br><span class="line">            self.__score=score</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0 ~ 100!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s=student(<span class="string">&#x27;zj&#x27;</span>)</span><br><span class="line">s.score=<span class="number">99</span> <span class="comment">#如果设置的数值大于100，将导致错误，因为我们利用特性进行了相关的访问控制</span></span><br><span class="line">print(s.name,s.score) <span class="comment">#zj 99</span></span><br><span class="line"></span><br><span class="line">print(s.__dict__) <span class="comment">#&#123;&#x27;name&#x27;: &#x27;zj&#x27;, &#x27;_student__score&#x27;: 99&#125;</span></span><br><span class="line"></span><br><span class="line">s.__sex=<span class="string">&#x27;female&#x27;</span> <span class="comment">#只有在类定义中绑定的以双下划线打头的实例属性被认为是“私有属性”并被倾轧，在类定义外动态绑定的则不会被认为是私有属性，也不会被倾轧</span></span><br><span class="line">print(s.__dict__) <span class="comment">#&#123;&#x27;name&#x27;: &#x27;zj&#x27;, &#x27;_student__score&#x27;: 99, &#x27;__sex&#x27;: &#x27;female&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>在上述示例中，首先使用<code>@property</code>装饰器将相关方法<code>score()</code>转变成了只读属性，后面的<code>@score.setter</code>装饰器将其他方法与<code>score</code>属性上的设置操作相关联，这个“其他方法”的名称应该与原始特性的名称完全匹配</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="sxfwkz-3"><p>使用<code>@property</code>特性后，对属性的访问将由一系列用户定义的get、set和delete函数控制，这种属性控制方式可以由“描述符”进一步推广，描述符就是一个表示属性值的对象，凡是实现<code>__get__()</code>、<code>__set__()</code>和<code>__delete__()</code>方法的就是描述符，注意描述符只能在类级别上进行实例化，当你通过实例访问一个描述符对象时，会自动调用描述符的<code>__get__()</code>、<code>__set__()</code>或<code>__delete__()</code>，并总是传入实例作为参数之一</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">movie</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,title,score,ratings</span>):</span></span><br><span class="line">        self.title=title</span><br><span class="line">        self.score=score</span><br><span class="line">        self.ratings=ratings</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span>(<span class="params">self,newValue</span>):</span></span><br><span class="line">        <span class="keyword">if</span> newValue&lt;<span class="number">0</span> <span class="keyword">or</span> newValue&gt;<span class="number">10</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;movie&#x27;s score can&#x27;t be negative or greater than 10&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._score=newValue</span><br><span class="line">            </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ratings</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._ratings</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @ratings.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ratings</span>(<span class="params">self,newValue</span>):</span></span><br><span class="line">        <span class="keyword">if</span> newValue&lt;<span class="number">0</span> <span class="keyword">or</span> newValue&gt;<span class="number">10</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;movie&#x27;s ratings can&#x27;t be negative or greater than 10&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._ratings=newValue</span><br><span class="line">            </span><br><span class="line">m=movie(<span class="string">&#x27;后天&#x27;</span>,<span class="number">7.5</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>上述示例中定义了一个通过<code>@property</code>进行属性访问控制的电影类，可以看到<code>score</code>和<code>ratings</code>两个属性拥有相同的访问控制，从而导致上述代码有较高的重复率，而描述符的访问控制可以被多个属性重复利用，需要注意的是你总是应该通过实例而非类名访问描述符，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> weakref <span class="keyword">import</span> WeakKeyDictionary</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">descriptor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,default</span>):</span></span><br><span class="line">        self.default=default</span><br><span class="line">        self.data=WeakKeyDictionary() <span class="comment">#由于描述符是定义在类层级的，因此对于类的所有实例都是可访问的，所以我们定义一个字典，存储类的所有实例及其属性值</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self,instance,owner</span>):</span> <span class="comment">#在访问movie实例m的score属性时，会被解释器解释为m.__class__.score.__get__(m,m.__class__)</span></span><br><span class="line">        <span class="comment">#print(owner) #&lt;class &#x27;__main__.movie&#x27;&gt;</span></span><br><span class="line">        <span class="keyword">if</span> instance==<span class="literal">None</span>: <span class="comment">#如果通过类访问描述符，传入的实例将为None，此时返回描述符对象本身，该操作是通用操作，该设置允许我们能够获取到在类层级定义的描述符对象本身</span></span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> self.data.get(instance,self.default)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self,instance,value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> value&lt;<span class="number">0</span> <span class="keyword">or</span> value&gt;<span class="number">10</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;movie&#x27;s score or ratings can&#x27;t be negative or greater than 10&quot;</span>)</span><br><span class="line">        self.data[instance]=value</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">movie</span>:</span></span><br><span class="line">    score=descriptor(<span class="number">0</span>)</span><br><span class="line">    ratings=descriptor(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,title,score,ratings</span>):</span></span><br><span class="line">        self.title=title</span><br><span class="line">        self.score=score <span class="comment">#注意千万不能通过类名访问描述符对象，譬如movie.score=score，这将导致类的score属性从一个描述符对象转变为一个数值对象，因为这不会触发调用描述符的__set__()方法，不过print(movie.score)还是会触发调用描述符的__get__()方法的，只是此时传入__get__()的instance实例对象是None</span></span><br><span class="line">        self.ratings=ratings</span><br><span class="line"></span><br><span class="line">m1=movie(<span class="string">&#x27;后天&#x27;</span>,<span class="number">7.5</span>,<span class="number">3</span>)</span><br><span class="line">print(m1.score,m1.ratings) <span class="comment">#7.5 3</span></span><br><span class="line"><span class="comment">#m2=movie(&#x27;后天&#x27;,7.5,-3) #ValueError: movie&#x27;s score or ratings can&#x27;t be negative or greater than 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#m1.score=-1 #ValueError: movie&#x27;s score or ratings can&#x27;t be negative or greater than 10</span></span><br><span class="line">movie.score.data[m1]=-<span class="number">1</span> <span class="comment">#在这种基于“实例-属性值”字典实现的描述符下其实你还是可以绕过描述符的访问控制实现非法赋值</span></span><br><span class="line">print(m1.score) <span class="comment">#-1</span></span><br></pre></td></tr></table></figure><p>当访问实例属性的时候，<code>obj.x</code>总是调用<code>__getattribute__()</code>方法（因此你也可以通过重载<code>__getattributr__()</code>进行最简单的属性访问控制，在这种情况下，不要忘记调用父类的<code>__getattributr__()</code>方法以防属性查找失败，所以不太建议这么做），其行为是，1）检查类中是否有同名的数据描述符对象，如果有，则自动变形为<code>obj.__class__.__dict__['x'].__get__(obj,obj.__class__)</code>，否则，2）检查实例字典，即在实例的<code>__dict__</code>中查找，找到则返回，否则，3）检查类字典，即在<code>obj.__class__.__dict__</code>中查找，找到则返回，如果是同名的非数据描述符，则还会自动变形，否则，4）按照MRO顺序依次检查基类字典，如果还找不到，则检查<code>obj</code>所在类是否定义了<code>__getattr__()</code>方法，有则返回<code>__getattr__()</code>的调用结果，否则抛出<code>AttributeError</code></p><p>当访问实例属性并进行赋值的时候，<code>obj.x=value</code>总是调用<code>__setattr__()</code>方法，其行为是，1）如果类中有同名的数据描述符对象，则自动变形为<code>obj.__class__.__dict__['x'].__set__(obj,value)</code>，否则，2）在实例的字典<code>__dict__</code>中查找，有则修改相应的键值，没有则将属性<code>x</code>直接绑定在实例上，即<code>__dict__.update({'x':value})</code>（<code>del obj.x</code>语句将触发调用<code>__delattr__()</code>方法，和<code>obj.x=value</code>触发调用<code>__setattr__()</code>类似，只不过其默认行为是删除<code>obj</code>的<code>__dict__</code>中存储的键值，除非请求的属性正好是一个描述符对象，此时将会执行<code>obj.__class__.__dict__['x'].__delete__(obj)</code>，如果实例字典中没有该属性，则抛出<code>AttributeError</code>）</p><p>注：实现了<code>__set__()</code>和<code>__get__()</code>方法的描述符类被称为数据描述符，如果只实现了<code>__get__()</code>方法，则称为非数据描述符</p><p>上面的描述符示例中采用字典存储所有的实例和属性值，但如果实例是不可哈希对象呢，为此我们还可以直接将属性值绑定到实例（的<code>__dict__</code>）上面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">descriptor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,label,default</span>):</span></span><br><span class="line">        self.label=label</span><br><span class="line">        self.default=default</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self,instance,owner</span>):</span></span><br><span class="line">        <span class="keyword">if</span> instance==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__.get(self.label,self.default)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self,instance,value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> value&lt;<span class="number">0</span> <span class="keyword">or</span> value&gt;<span class="number">10</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;movie&#x27;s score or ratings can&#x27;t be negative or greater than 10&quot;</span>)</span><br><span class="line">        instance.__dict__[self.label]=value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">movie</span>:</span></span><br><span class="line">    score=descriptor(<span class="string">&#x27;score&#x27;</span>,<span class="number">0</span>) <span class="comment">#不同名也行，但这就重蹈@property的覆辙了，譬如名称改为&#x27;_score&#x27;，此时通过“obj.score=非法值”自然会受到访问控制，但是“obj._score=非法值”则不受保护</span></span><br><span class="line">    ratings=descriptor(<span class="string">&#x27;ratings&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,title,score,ratings</span>):</span></span><br><span class="line">        self.title=title</span><br><span class="line">        self.score=score</span><br><span class="line">        self.ratings=ratings</span><br><span class="line"></span><br><span class="line">m1=movie(<span class="string">&#x27;后天&#x27;</span>,<span class="number">7.5</span>,<span class="number">3</span>)</span><br><span class="line">print(m1.score,m1.ratings) <span class="comment">#7.5 3</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    m1.score=-<span class="number">10</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line">    </span><br><span class="line">print(m1.__dict__) <span class="comment">#&#123;&#x27;title&#x27;: &#x27;后天&#x27;, &#x27;score&#x27;: 7.5, &#x27;ratings&#x27;: 3&#125;</span></span><br><span class="line"></span><br><span class="line">m1.__dict__[<span class="string">&#x27;score&#x27;</span>]=-<span class="number">1000</span> <span class="comment">#在这种情况下你可以通过直接修改实例字典来绕过描述符的访问控制，唉，有完美的解决方案吗</span></span><br><span class="line">print(m1.score) <span class="comment">#-1000</span></span><br></pre></td></tr></table></figure><p>上述在类层级定义描述符的时候需要手动传入属性名称字符串，<code>score=descriptor('score',0)</code>，这不太方便，为了隐藏该细节，可以借助元类，使得定义变回<code>score=descriptor(0)</code>这种简洁形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">descriptor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,default,label=<span class="literal">None</span></span>):</span> <span class="comment">#此处参数定义要稍稍修改</span></span><br><span class="line">        self.label=label</span><br><span class="line">        self.default=default</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self,instance,owner</span>):</span></span><br><span class="line">        <span class="keyword">if</span> instance==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__.get(self.label,self.default)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self,instance,value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> value&lt;<span class="number">0</span> <span class="keyword">or</span> value&gt;<span class="number">10</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;movie&#x27;s score or ratings can&#x27;t be negative or greater than 10&quot;</span>)</span><br><span class="line">        instance.__dict__[self.label]=value</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self,instance</span>):</span> <span class="comment">#__delete__()不太常用，主要用来使实例（描述符）属性不可删除，但是你不能在__del__()方法中通过抛出异常阻止对象的删除</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">&#x27;Can\&#x27;t delete this attribute!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">addLabelMeta</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls,name,bases,local_dict</span>):</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> local_dict.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(v,descriptor):</span><br><span class="line">                v.label=k</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(cls,cls).__new__(cls,name,bases,local_dict)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">movie</span>(<span class="params">metaclass=addLabelMeta</span>):</span></span><br><span class="line">    score=descriptor(<span class="number">0</span>)</span><br><span class="line">    ratings=descriptor(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,title,score,ratings</span>):</span></span><br><span class="line">        self.title=title</span><br><span class="line">        self.score=score</span><br><span class="line">        self.ratings=ratings</span><br><span class="line"></span><br><span class="line">m1=movie(<span class="string">&#x27;后天&#x27;</span>,<span class="number">7.5</span>,<span class="number">3</span>)</span><br><span class="line">print(m1.score,m1.ratings) <span class="comment">#7.5 3</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    m1.score=-<span class="number">10</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line">    </span><br><span class="line">print(m1.__dict__) <span class="comment">#&#123;&#x27;title&#x27;: &#x27;后天&#x27;, &#x27;score&#x27;: 7.5, &#x27;ratings&#x27;: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">del</span> m1.score</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line">    </span><br><span class="line">print(m1.score) <span class="comment">#7.5</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div style="display:none"><h2 id="设计模式">设计模式</h2><div class="tabs" id="sjms"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#sjms-1">单例模式</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="sjms-1"><p>所谓单例，即一个类有且只有一个实例，无法创建第二个实例，主要有三种实现单例的方式：</p><ul><li><p>通过<code>__new__()</code>控制实例的创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line">    __instance=<span class="literal">None</span> <span class="comment">#__instance不需要为外界知道，所以可以设为私有属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls,*args,**kwds</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls.__instance:</span><br><span class="line">            cls.__instance=<span class="built_in">super</span>(Singleton,cls).__new__(cls,*args,**kwds)</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mine</span>(<span class="params">Singleton</span>):</span> <span class="comment">#世间只有一个我</span></span><br><span class="line">    <span class="comment">#def __new__(cls,*args,**kwargs): #如果未定义__new__()，则默认调用父类的__new__()，如果定义了，则需手动调用父类的__new__()，所以一定要写成super()形式，特别是mine还继承了其他类（多继承）的情况下，就只能依靠super()机制</span></span><br><span class="line">    <span class="comment">#    ... #其他操作</span></span><br><span class="line">    <span class="comment">#    return super(mine,cls).__new__(cls,*args,**kwargs)</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name=<span class="string">&#x27;muggledy&#x27;</span></span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        </span><br><span class="line">a=mine()</span><br><span class="line">b=mine(<span class="string">&#x27;dy&#x27;</span>)</span><br><span class="line">print(a <span class="keyword">is</span> b) <span class="comment">#True</span></span><br><span class="line">print(a.name) <span class="comment">#dy</span></span><br></pre></td></tr></table></figure></li><li><p>使用类装饰器控制实例的创建（推荐）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Singleton</span>(<span class="params">cls</span>):</span> <span class="comment">#类装饰器，修饰对象是一个类</span></span><br><span class="line">    instances=&#123;&#125; <span class="comment"># 存储所有的“类-单例”键值对</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwds</span>):</span> <span class="comment">#或许命名为get_instance更清晰</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls]=cls(*args,**kwds)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mine</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name=<span class="string">&#x27;muggledy&#x27;</span></span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        </span><br><span class="line">a=mine()</span><br><span class="line">b=mine(<span class="string">&#x27;dy&#x27;</span>)</span><br><span class="line">print(a <span class="keyword">is</span> b) <span class="comment">#True</span></span><br></pre></td></tr></table></figure></li><li><p>通过元类的<code>__call__()</code>方法控制实例的创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonMetaCls</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">cls,*args,**kwargs</span>):</span> <span class="comment">#举例说（下面的注释也都是以mine类为例，即cls参数为mine），mine类的创建：mine=SingletonMetaCls(...)，即mine类本身就是SingletonMetaCls元类的一个实例而已，因此当我们创建类mine的实例，即通过小括号调用mine类时：a=mine(...)，会触发调用SingletonMetaCls中定义的__call__()方法：SingletonMetaCls.__call__(mine,...)，其总是返回一个新的mine类实例，于是我们在call方法中拦截新实例的创建，使其返回旧实例（假设已存在的话）</span></span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment">#mine类的_instance属性用于存储唯一的实例，需要调用new和init方法进行创建和初始化，如果已经存在则只需要重新初始化init即可</span></span><br><span class="line">            cls._instance=cls.__new__(cls,*args,**kwargs) <span class="comment">#此处的_instance存储在类mine的字典__dict__中，该语句也可以替换成cls._instance=super(SingletonMetaCls,cls).__call__(*args,**kwargs)，即cls._instance=type.__call__(cls,*args,**kwargs)，效果是一样的，type类的call方法内部实现也是：o=cls.__new__(cls*args,**kwargs);return o.__init__(*args,**kwargs)</span></span><br><span class="line">        cls._instance.__init__(*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params">metaclass=SingletonMetaCls</span>):</span></span><br><span class="line">    _instance=<span class="literal">None</span> <span class="comment">#该值永远也不会变，也不能变</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mine</span>(<span class="params">Singleton</span>):</span> <span class="comment">#如果没有显式指定metaclass关键字参数或者__metaclass__类属性，则默认设置当前类的元类为继承的第一个基类的元类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name=<span class="string">&#x27;muggledy&#x27;</span></span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">    </span><br><span class="line">a=mine(<span class="string">&#x27;dy&#x27;</span>)</span><br><span class="line">b=mine(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">print(a <span class="keyword">is</span> b) <span class="comment">#True</span></span><br><span class="line">print(Singleton._instance)</span><br><span class="line">print(a.name) <span class="comment">#hello</span></span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></div><p>未完待续…</p><div class="tip fas fa-quote-left"><p>[1] <a href="https://pan.baidu.com/s/17r__wNMxIXTMWhglf3wyuw" rel="external nofollow noreferrer" title="密码：1y2r" target="_blank"><span style="color:red">Python参考手册</span> 第4版 修订版 [美] 大卫·M.比兹利（David M.Beazley）著，谢俊，杨越，高伟 译</a><br>[2] <a href="https://segmentfault.com/a/1190000009157792" rel="external nofollow noreferrer" target="_blank">绑定方法与非绑定方法</a></p></div></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>Python基础 - 面向对象编程</h></span></div><div class="post-copyright__type"><span class="post-copyright-info" id="post-copyright-url"><a href="https://muggledy.top/posts/22901/">https://muggledy.top/posts/22901/</a></span><span>&nbsp;&nbsp;</span><span class="cursorpointer" id="post-url-copyer" onclick="copy_post_url()"><i class="fas fa-paste copy-button"></i></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Muggledy</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2021-05-01</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2021-05-05</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener external nofollow noreferrer" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener external nofollow noreferrer" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div><div class="post-copyright__note"><span class="post-copyright-info"><h>转载或借鉴请注明博客来源噢！</h></span></div></div><script>function copy_post_url(){event.stopPropagation();var e=document.getElementById("post-copyright-url");window.getSelection().selectAllChildren(e),document.execCommand("Copy")}</script><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/09/16/tdDuVfFBgy5bGpr.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-bookmark fa-fw"></i> <span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/176/" title="介绍python程序结构与控制流，同时为了更好地实现模块化，会将实现指定功能的程
序封装为函数..."><img class="cover" src="https://i.loli.net/2021/09/16/CUqYkM2uKDbw69v.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-27</div><div class="title">Python基础 - 程序结构与函数编程</div></div></a></div><div><a href="/posts/5311/" title="Python程序中保存的所有数据都是围绕对象这一概念来构建的，对象包括一些基本的
数据类型，如数字、字符串、列表和字典，也可以通过类的形式创建用户自定义的对象..
."><img class="cover" src="https://cdn.jsdelivr.net/gh/celestezj/Mirror1ImageHosting/img/zjandxiong.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-24</div><div class="title">Python基础 - 类型和对象</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Gitalk</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@v0.1/img/20210202152223.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@latest/img/20210328224511.gif"' alt="avatar"><div class="author-info__name">Muggledy</div><div class="author-info__description">孤筏重洋</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/muggledy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/muggledy" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210209044239.jpg" rel="external nofollow noreferrer" target="_blank" title="WeChat"><i class="fab fa-weixin"></i></a><a class="social-icon" href="mailto:zgjsycfndy2015@163.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=3101266674&amp;site=qq&amp;menu=yes" rel="external nofollow noreferrer" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><a href="/note/"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></a><div class="announcement_content">本人的更新是极慢的~</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">属性访问控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">设计模式</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/35908/" title="Pytorch入门教程"><img src="https://i.loli.net/2021/09/16/LvWYXSJzkF53TB6.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@latest/img/20210328224519.jpg"' alt="Pytorch入门教程"></a><div class="content"><a class="title" href="/posts/35908/" title="Pytorch入门教程">Pytorch入门教程</a><time datetime="2021-06-08T01:39:12.000Z" title="发表于 2021-06-08 09:39:12">2021-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/22901/" title="Python基础 - 面向对象编程"><img src="https://i.loli.net/2021/09/16/tdDuVfFBgy5bGpr.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@latest/img/20210328224519.jpg"' alt="Python基础 - 面向对象编程"></a><div class="content"><a class="title" href="/posts/22901/" title="Python基础 - 面向对象编程">Python基础 - 面向对象编程</a><time datetime="2021-05-01T13:05:41.000Z" title="发表于 2021-05-01 21:05:41">2021-05-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/176/" title="Python基础 - 程序结构与函数编程"><img src="https://i.loli.net/2021/09/16/CUqYkM2uKDbw69v.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@latest/img/20210328224519.jpg"' alt="Python基础 - 程序结构与函数编程"></a><div class="content"><a class="title" href="/posts/176/" title="Python基础 - 程序结构与函数编程">Python基础 - 程序结构与函数编程</a><time datetime="2021-04-27T03:45:30.000Z" title="发表于 2021-04-27 11:45:30">2021-04-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5311/" title="Python基础 - 类型和对象"><img src="https://cdn.jsdelivr.net/gh/celestezj/Mirror1ImageHosting/img/zjandxiong.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@latest/img/20210328224519.jpg"' alt="Python基础 - 类型和对象"></a><div class="content"><a class="title" href="/posts/5311/" title="Python基础 - 类型和对象">Python基础 - 类型和对象</a><time datetime="2021-04-24T12:55:45.000Z" title="发表于 2021-04-24 20:55:45">2021-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/65257/" title="Butterfly魔改部分记录"><img src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/img/20210328214628.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting@latest/img/20210328224519.jpg"' alt="Butterfly魔改部分记录"></a><div class="content"><a class="title" href="/posts/65257/" title="Butterfly魔改部分记录">Butterfly魔改部分记录</a><time datetime="2021-03-25T07:53:40.000Z" title="发表于 2021-03-25 15:53:40">2021-03-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright"><span>&copy;2021</span><span class="onespace">&nbsp;</span><svg style="width:1.5em;height:1.5em" aria-hidden="true"><use xlink:href="#icon-butterfly1"></use></svg><span>By Muggledy</span></div><div class="footer_custom_text"><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io/zh-cn/"><img src="https://img.shields.io/badge/Frame-Hexo-blue"></a>&nbsp;&nbsp;<a target="_blank" rel="noopener external nofollow noreferrer" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-brightgreen"></a>&nbsp;&nbsp;<a target="_blank" rel="noopener external nofollow noreferrer" href="https://pages.github.com/"><img src="https://img.shields.io/badge/Hosted-Github-red"></a>&nbsp;&nbsp;<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsdelivr-blueviolet"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v1.2/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v1.2/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v4.2/js/search/local-search.js"></script><div class="js-pjax"><script>document.getElementsByClassName("mermaid").length&&(window.mermaidJsLoad?mermaid.init():getScript("https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js").then(()=>{window.mermaidJsLoad=!0,mermaid.initialize({theme:"default"}),mermaid.init()}))</script><script>function loadValine(){function e(){new Valine(Object.assign({el:"#vcomment",appId:"b7x9hYzkDTy4reR4khezoDcf-gzGzoHsz",appKey:"ReeSRhiVzefUKIsJwSvUD6qV",placeholder:"快来评论吧(请注意“最新评论”只关联了Gitalk评论系统哦)~",avatar:"monsterid",meta:"nick,mail,link".split(","),pageSize:"10",lang:"zh-CN",recordIP:!1,serverURLs:"",emojiCDN:"",emojiMaps:"",enableQQ:!0,path:window.location.pathname,requiredFields:["nick,mail"],visitor:!1,master:"5f452633ebd48518f8778c240d946335".split(","),friends:"a483c79213701a5644bec62de88f974d,34c64a0cb78287b2ae889cda5d9d2a91,574fbd33aa74a09d671f4608af20fd2b".split(",")},null))}"function"==typeof Valine?e():getScript("https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js").then(e)}{function loadOtherComment(){loadValine()}setTimeout(loadValine,0)}</script><script>function addGitalkSource(){const e=document.createElement("link");e.rel="stylesheet",e.href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css",document.getElementsByTagName("head")[0].appendChild(e)}function loadGitalk(){function e(){new Gitalk(Object.assign({clientID:"05956758b57064d95a57",clientSecret:"3c4ddd74e671e3d79aac8417e708f69ff93b3e28",repo:"muggledy.github.io",owner:"muggledy",admin:["muggledy"],id:"3fad989e9b1adf5b0e4f07ef9f71a015",language:"zh-CN",perPage:10,distractionFreeMode:!1,pagerDirection:"last",createIssueManually:!1,updateCountCallback:commentCount},null)).render("gitalk-container")}"function"==typeof Gitalk?e():(addGitalkSource(),getScript("https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js").then(e))}function commentCount(e){let t=document.querySelector("#post-meta .gitalk-comment-count");t&&(t.innerHTML=e)}{function loadOtherComment(){loadGitalk()}loadGitalk()}</script></div><script>window.addEventListener("load",()=>{const e=()=>{fetch("https://api.github.com/repos/muggledy/muggledy.github.io/issues/comments?sort=updated&direction=desc&per_page=6&page=1",{headers:{Accept:"application/vnd.github.v3.html+json"}}).then(e=>e.json()).then(e=>{(e=>{let a="";Promise.all(e.map(e=>fetch(e.url).then(e=>e.json()).then(e=>"utterances-bot"===e.user.login?(a=e.body.match(/https?\:\/\/[^\" ]+/gi).slice(-1),a[0]):(a=e.body.match(/https?\:\/\/[^\" ]+/i),a[0])))).then(a=>{e=e.map((e,t)=>({...e,url:a[t]})),saveToLocal.set("github-newest-comments",JSON.stringify(e),5/1440),t(e)})})(e.map(e=>{return{avatar:e.user.avatar_url,content:(t=e.body_html,""===t||(t=(t=(t=(t=t.replace(/<img.*?src="(.*?)"?[^\>]+>/gi,"[图片]")).replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi,"[链接]")).replace(/<pre><code>.*?<\/pre>/gi,"[代码]")).replace(/<[^>]+>/g,"")).length>150&&(t=t.substring(0,150)+"..."),t),nick:e.user.login,url:e.issue_url,date:e.updated_at,githubUrl:e.html_url};var t}))}).catch(e=>{document.querySelector("#card-newest-comments .aside-list").innerHTML="无法获取评论，请确认相关配置是否正确以及网络是否通畅"})},t=e=>{let t="";if(e.length)for(let a=0;a<e.length;a++){t+="<div class='aside-list-item'>";{const n="src";t+=`<a href='${e[a].url}' class='thumbnail'><img ${n}='${e[a].avatar}' alt='${e[a].nick}'></a>`}t+=`<div class='content'>\n        <a class='comment' href='${e[a].url}'>${e[a].content}</a>\n        <div class='name'><span>${e[a].nick} / </span><time datetime="${e[a].date}">${btf.diffDate(e[a].date,!0)}</time></div>\n        </div></div>`}else t+="没有评论";let a=document.querySelector("#card-newest-comments .aside-list");a.innerHTML=t,window.lazyLoadInstance&&window.lazyLoadInstance.update(),window.pjax&&window.pjax.refresh(a)},a=()=>{if(document.querySelector("#card-newest-comments .aside-list")){const a=saveToLocal.get("github-newest-comments");a?t(JSON.parse(a)):e()}};a(),document.addEventListener("pjax:complete",a)})</script><script src="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v1.2/js/t_chart.js"></script><script src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/data/funny_title/funny-title-js.js"></script><script async src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/data/font_animal/font_animal.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/muggledy/muggledy.github.io@v1.2/js/cal_rs.js"></script><script src="https://cdn.jsdelivr.net/gh/celestezj/ImageHosting/data/visitors_map/vis_m.js"></script><script async src="https://at.alicdn.com/t/font_2494703_el3qb7r0dxv.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#web_bg","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:complete",(function(){void 0!==window.ifExe_addHighlightTool&&(window.ifExe_addHighlightTool=!0),void 0!==window.ifExe_clickFnOfTagHide&&(window.ifExe_clickFnOfTagHide=!0),void 0!==window.ifExe_addTableWrap&&(window.ifExe_addTableWrap=!0),void 0!==window.ifExe_addPhotoFigcaption&&(window.ifExe_addPhotoFigcaption=!0),void 0!==window.ifExe_jqLoadAndRun_jg&&(window.ifExe_jqLoadAndRun_jg=!0),void 0!==window.ifExe_jqLoadAndRun_fb&&(window.ifExe_jqLoadAndRun_fb=!0),window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:send",(function(){if("object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>function dogo(){var o,s="/posts/17177/,/posts/65257/,/posts/35908/,/posts/176/,/posts/22901/,/posts/5311/";for(s=s.split(",");s[o=Math.floor(Math.random()*s.length)]==getRelativeUrl(););pjax.loadUrl(s[o])}</script><div class="dyminimenu"><ul><li onclick="wll_menu(1)"><span>📝 添加mini便签</span></li><li onclick="wll_menu(2)"><span>🆑 清空当前页面</span></li></ul></div><script data-pjax>function history_calendar_injector_config(){var i=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载history_calendar"),i.insertAdjacentHTML("afterbegin",'<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>')}document.getElementsByClassName("sticky_layout")[0]&&"/"===location.pathname&&history_calendar_injector_config()</script><script data-pjax src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script></body><script>document.addEventListener("touchmove",(function(e){e.preventDefault()}),!1)</script><script async data-pjax>IsPC()&&btf.isJqueryLoad(image_preview_wrapper),btf.isJqueryLoad(dybubblefn)</script></html>